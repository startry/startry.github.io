<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Startry Blog</title>
  <subtitle>随便乱写, 目前专攻iOS研发~</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://startry.com/"/>
  <updated>2016-03-17T11:54:10.000Z</updated>
  <id>http://startry.com/</id>
  
  <author>
    <name>Startry</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在Pod库中使用xcasset的拷贝陷阱</title>
    <link href="http://startry.com/2016/03/17/the-trap-of-image-resource/"/>
    <id>http://startry.com/2016/03/17/the-trap-of-image-resource/</id>
    <published>2016-03-17T11:54:10.000Z</published>
    <updated>2016-03-17T11:54:10.000Z</updated>
    
    <content type="html">&lt;p&gt;本篇文章来自笔者工作中遇到一个难解的BUG - 在App中用&lt;code&gt;UIImage&lt;/code&gt;的&lt;code&gt;imageNamed:&lt;/code&gt;方法读取的图片始终是&lt;strong&gt;不正确&lt;/strong&gt;的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://blog.startry.com/img/blog_image_repeate_intro.png&quot; alt=&quot;暴走示意&quot;&gt;&lt;/p&gt;
&lt;p&gt;场景条件回放:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;有多张同名图片存在工程下, 比如都叫&lt;code&gt;pic_same_test&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;同名图片有存在被工程引用的子Bundle中, 主Bundle中和xcasset中&lt;/li&gt;
&lt;li&gt;同名图片未被工程引用进来, 但是放置在工程物理目录下的某个xcasset中&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;试想一下, 这个时候你如果使用下述代码去读取该图片, 会发生取到哪种图片呢?&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;UIImage *image = [UIImage imageNamed:@&amp;#34;pic_same_test&amp;#34;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在上述的条件场景中, 当我在应用中用UIImage去读取&lt;strong&gt;A&lt;/strong&gt;图片的时候, 总是会读取到了错误的&lt;strong&gt;B&lt;/strong&gt;图片。因为笔者最初的排查方向只在&lt;strong&gt;条件1&lt;/strong&gt;和&lt;strong&gt;条件2&lt;/strong&gt;两个方向去查找, 没有去深究未被工程引用的部分, 导致了整个思路方向被引向了错误的方向, 极大的加深了BUG的排查难度。&lt;/p&gt;
&lt;p&gt;笔者在这个问题上纠结了很久, 在&lt;a href=&quot;http://stackoverflow.com/questions/36008210/uiimage-load-wrong-image-in-main-bundle&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Stackoverflow&lt;/a&gt;和&lt;a href=&quot;https://forums.developer.apple.com/message/124162&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;苹果开发者论坛&lt;/a&gt;都根据这个场景进行了提问, 最终在开发者论坛中经过昵称为&lt;em&gt;Bob133&lt;/em&gt;的高人指点, 将问题的&lt;font color=&quot;orange&quot;&gt;突破口&lt;/font&gt;定位在了&lt;a href=&quot;https://developer.apple.com/library/prerelease/ios/documentation/Xcode/Reference/xcode_ref-Asset_Catalog_Format/index.html#//apple_ref/doc/uid/TP40015170-CH18-SW1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;xcasset&lt;/a&gt;上。&lt;/p&gt;
&lt;h2 id=&quot;神秘的错误图片&quot;&gt;神秘的错误图片&lt;/h2&gt;&lt;p&gt;事情的起因是因为笔者在开发的某App的时候突然爆出了一个图片锯齿的BUG, 可是笔者的代码在线上已经稳定运行了几个月了, 怎么可能会突然抽风呢? &lt;/p&gt;
&lt;p&gt;处于笔者对UIImage的了解, 第一反应想到的就是&lt;strong&gt;缓存&lt;/strong&gt;。这里的&lt;strong&gt;缓存&lt;/strong&gt;不是UIImage加载图片的加速缓存, 而是在打包时候的资源不重复copy的&lt;strong&gt;缓存&lt;/strong&gt;。因此, 笔者对这个BUG的存在性持有怀疑的态度, 二话不说自己做起了实验, 执行了下述操作:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;删除Project对应的&lt;strong&gt;Derived Data&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;对项目执行&lt;strong&gt;clean&lt;/strong&gt;操作&lt;/li&gt;
&lt;li&gt;删除目标设备的项目App&lt;/li&gt;
&lt;li&gt;重新打包编译整个App&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;经过上述四部操作和漫长的打包等待, 结果当然是呵呵哒了~ 如果结果正常就不会出现本篇博文了! 没错, 经过上述四部操作, 图片依旧还是&lt;strong&gt;错误&lt;/strong&gt;的! &lt;/p&gt;
&lt;p&gt;呵呵, 删除缓存不行, 那就不是缓存问题, 笔者怀疑打出来的包里面有图片串位的可能, 心想根目录下的图是不是就是错误的。不多说, 提取ipa, 显示包内容, 包内容根目录下的图竟然是&lt;strong&gt;正确&lt;/strong&gt;的!!! &lt;/p&gt;
&lt;p&gt;在包内容目录下, 我想要取的图片名字一样的图片总共就两张, 一张在根目录下, 另外一张在子Bundle下面。既然总共就2张图片, 那我就尝试在工程里&lt;strong&gt;删除掉子Bundle下的另外一张图片&lt;/strong&gt;, 然后执行上述四部操作重新来过。结果大家想必还是知道的, 图片照样是错误的, 但是打包出来的文件包根目录下就只有一张&lt;strong&gt;正确&lt;/strong&gt;的图片! &lt;/p&gt;
&lt;p&gt;这个尼玛不是一张幽灵图片么? 笔者当时脑洞大开, 甚至怀疑到是否iCloud同步下来的, 可是笔者的测试机压根就没有绑定iCloud。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;PS: 当时忽略了Assets.car是因为工程里引用的Image.assets里并没有这张同名的文件, 源文件没有, 那自然就不会怀疑打包后的内容。另外, 笔者比较懒, 懒得去提取car文件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;产生的原因&amp;amp;解决方案&quot;&gt;产生的原因&amp;amp;解决方案&lt;/h2&gt;&lt;p&gt;针对这个幽灵图片, 笔者在&lt;strong&gt;XCode&lt;/strong&gt;全局搜索, 也就搜索到前文提到的两者图片。那么这个图片究竟是从哪里来的呢? &lt;/p&gt;
&lt;p&gt;笔者在这个问题上纠结了超过十个小时, 并分别在&lt;a href=&quot;https://forums.developer.apple.com/message/124162&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;苹果开发论坛&lt;/a&gt;和&lt;a href=&quot;http://stackoverflow.com/questions/36008210/uiimage-load-wrong-image-in-main-bundle&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Stackoverflow&lt;/a&gt;提出的疑问, 但是疑问有误导回答者往Bundle排查的嫌疑。&lt;/p&gt;
&lt;p&gt;但是世界上开发牛人这么多, 稍微误导下问题也不大, 在&lt;a href=&quot;https://forums.developer.apple.com/message/124162&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;苹果开发者论坛&lt;/a&gt;中的用户&lt;strong&gt;bob133&lt;/strong&gt;说他曾经遇到过类似的场景, 也排查了好久, 让我仔细检查下是不是&lt;code&gt;xcasset&lt;/code&gt;捣的鬼。&lt;/p&gt;
&lt;p&gt;笔者基于&lt;strong&gt;bob133&lt;/strong&gt;的提示, 想到是否真的&lt;code&gt;xcasset&lt;/code&gt;有问题。笔者通过&lt;strong&gt;XCode&lt;/strong&gt;全局搜索了项目里的&lt;strong&gt;xcasset&lt;/strong&gt;, 并没有找到错误的那张显示图片。直到这个时候, 笔者才想到要把加密的&lt;code&gt;Assets.car&lt;/code&gt;文件提取出来看看。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://blog.startry.com/img/blog_asset_car_mogujie.png&quot; alt=&quot;ThemeEngine Demo&quot;&gt;&lt;/p&gt;
&lt;p&gt;图片示例提取的是国内知名女性购物平台某某街的App, 可以从上图看出该App的图片使用也存在非常不规范的地方, 同一名字的图片被打入了这么多张。设想一下, 假如在这里写下述代码,  取到的究竟是上图中四张的哪张呢? =。=&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;UIImage *image = [UIImage imageNamed:@&amp;#34;address_icon_location&amp;#34;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Assets.car的提取工具很多, 笔者使用的是&lt;a href=&quot;https://github.com/alexzielenski/ThemeEngine&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ThemeEngine&lt;/a&gt;。通过&lt;a href=&quot;https://github.com/alexzielenski/ThemeEngine&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ThemeEngine&lt;/a&gt;提取的&lt;code&gt;Assets.car&lt;/code&gt;文件中&lt;font color=&quot;orange&quot;&gt;果然找到错误的图片&lt;/font&gt;! 原来UIImage读取错误图片的根源是在这里啊!&lt;/p&gt;
&lt;p&gt;总之, 打包后读取的问题图片已经找到了, 藏在二进制文件&lt;code&gt;Assets.car&lt;/code&gt;中。&lt;/p&gt;
&lt;h4 id=&quot;幽灵图片从哪里来&quot;&gt;幽灵图片从哪里来&lt;/h4&gt;&lt;p&gt;在打包生产的&lt;code&gt;Assets.car&lt;/code&gt;竟然会出现错误的图片, 那一定还是工程目录下打包进去的。那究竟是什么地方打包进去的呢? &lt;/p&gt;
&lt;p&gt;笔者首先想到的突破点是打包编译过程的&lt;code&gt;Copy Pods Resources&lt;/code&gt;过程, 通过编译选项笔者发现有一个物理目录下的&lt;code&gt;Example&lt;/code&gt;里的&lt;code&gt;XXX.assets&lt;/code&gt;被打包进入了最终的&lt;code&gt;Asset.car&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;笔者尝试删除该目录下的&lt;code&gt;Example&lt;/code&gt;工程, 果然编译出来的App可以读取到了&lt;strong&gt;正确&lt;/strong&gt;的图片。&lt;/p&gt;
&lt;p&gt;问题根源已经找到了, 笔者查看&lt;code&gt;Copy Pods Resouces&lt;/code&gt;下的核心脚本&lt;code&gt;Pods_resources.sh&lt;/code&gt;, 发现一段很牛B的代码段:&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Find all other xcassets (this unfortunately includes those of path pods and other targets).&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;OTHER_XCASSETS=$(find &lt;span class=&quot;string&quot;&gt;&quot;&lt;span class=&quot;variable&quot;&gt;$PWD&lt;/span&gt;&quot;&lt;/span&gt; -iname &lt;span class=&quot;string&quot;&gt;&quot;*.xcassets&quot;&lt;/span&gt; -type d)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;read&lt;/span&gt; line; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; [[ &lt;span class=&quot;variable&quot;&gt;$line&lt;/span&gt; != &lt;span class=&quot;string&quot;&gt;&quot;`realpath &lt;span class=&quot;variable&quot;&gt;$PODS_ROOT&lt;/span&gt;`*&quot;&lt;/span&gt; ]]; &lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	XCASSET_FILES+=(&lt;span class=&quot;string&quot;&gt;&quot;&lt;span class=&quot;variable&quot;&gt;$line&lt;/span&gt;&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fi&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;done&lt;/span&gt; &amp;lt;&amp;lt;&amp;lt;&lt;span class=&quot;string&quot;&gt;&quot;&lt;span class=&quot;variable&quot;&gt;$OTHER_XCASSETS&lt;/span&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我去啊。。。怎么会有这样的代码段, 而且从0.35的CocoaPods版本开始就早已存在。笔者当时使用的&lt;a href=&quot;https://github.com/CocoaPods/CocoaPods/tree/0.39-stable&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;0.39.stable&lt;/a&gt;的CocoaPods版本。关于这个问题, 笔者顺藤摸瓜, 找到了一个相关的&lt;a href=&quot;https://github.com/CocoaPods/CocoaPods/issues/1546&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CocoaPods issue - Pods copy resource script overrides default xcasset bahaviour&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;这个资源覆盖的issue截止笔者发文之前依旧还open着。笔者先回归正题, 为什么笔者的代码在线上跑了几个月后会突然出问题了呢? 关键代码在这里:&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; [[ -n &lt;span class=&quot;string&quot;&gt;&quot;&lt;span class=&quot;variable&quot;&gt;$&amp;#123;WRAPPER_EXTENSION&amp;#125;&lt;/span&gt;&quot;&lt;/span&gt; ]] &amp;amp;&amp;amp; [ &lt;span class=&quot;string&quot;&gt;&quot;`xcrun --find actool`&quot;&lt;/span&gt; ] &amp;amp;&amp;amp; [ -n &lt;span class=&quot;string&quot;&gt;&quot;&lt;span class=&quot;variable&quot;&gt;$XCASSET_FILES&lt;/span&gt;&quot;&lt;/span&gt; ]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fi&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上述的Copy脚本执行条件是满足这个if语句, 这个条件语句有三个条件:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;有WRAPPER_EXTENSION, pod库依赖的资源文件默认都是&lt;code&gt;bundle&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;xcode命令行支持actool, actool是用来合并xcasset的官方工具&lt;/li&gt;
&lt;li&gt;有添加过任意一个&lt;code&gt;xcasset&lt;/code&gt;相关的文件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;条件1和条件2一直都没有改变过, 那么客观条件只有第3条有改变过的可能, 追朔代码:&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;install_resource&lt;/span&gt;&lt;/span&gt;()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;$1&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  *.xcassets)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      ABSOLUTE_XCASSET_FILE=$(realpath &lt;span class=&quot;string&quot;&gt;&quot;&lt;span class=&quot;variable&quot;&gt;$&amp;#123;PODS_ROOT&amp;#125;&lt;/span&gt;/&lt;span class=&quot;variable&quot;&gt;$1&lt;/span&gt;&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      XCASSET_FILES+=(&lt;span class=&quot;string&quot;&gt;&quot;&lt;span class=&quot;variable&quot;&gt;$ABSOLUTE_XCASSET_FILE&lt;/span&gt;&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      ;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  /*)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;原来如此, 笔者所用的工程里依赖的Pod库里只要有任意一个Pod库被添加过一次&lt;code&gt;xcasset&lt;/code&gt;文件, 则会触发这个全资源拷贝的脚本语句。这也是为啥之前工程没事, 好端端突然就出问题的原因。&lt;/p&gt;
&lt;p&gt;防止大家误解, 这里条件3的添加&lt;code&gt;xcasset&lt;/code&gt;需要通过引用库的podspec指定添加, 添加后通过主工程&lt;code&gt;pod_install&lt;/code&gt;或&lt;code&gt;pod_update&lt;/code&gt;生产的脚本引入产生。&lt;/p&gt;
&lt;p&gt;示例语句(写在podspec中):&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;s.resource = &lt;span class=&quot;string&quot;&gt;&#39;DemoLib/Pod/AnyName.xcassets&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;总而言之, CocoaPods判断如果任意的Pod库里通过描述文件引入了xcasset文件, 就会触发根目录下所有xcasset文件扫描打包car的执行操作。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;解决方案&quot;&gt;解决方案&lt;/h4&gt;&lt;p&gt;针对该问题的解决方案有很多, 熟悉了CocoaPods的特性后怎么样都可以解决这个问题:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法一:&lt;/strong&gt; 删除所有物理目录下多余的xcasset, 本身在源代码根目录下放置没有用到库本身就是非常危险的行为。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法二:&lt;/strong&gt; 通过Podfile Hook去屏蔽Pod库资源的Copy和合成, 替换核心脚本, 定向指定自己需要Copy的资源。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法三:&lt;/strong&gt; 逃避的方法, 不要在Pod库中使用xcasset。本身CocoaPods的初衷并没有打算支持资源文件的, 后续演变成目前的形态。(不适用xcasset默认png压缩不会执行, 可能需要手动执行, 并且图片容易被提取)&lt;/p&gt;
&lt;h4 id=&quot;追根溯源&quot;&gt;追根溯源&lt;/h4&gt;&lt;p&gt;作为一个极具盛名的开源库, 怎么可能会写这么大的一个BUG呢? 有因必有果, 有一个关键问题还是没有找出来, 为什么两年来没有人给这个问题提Pull Request呢?&lt;/p&gt;
&lt;p&gt;笔者本着好奇之心去探索CocoaPods的相关issue和commit记录, 找到了一个关键提交节点:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;0.36.4 (2015-04-16)&lt;/p&gt;
&lt;p&gt;Bug Fixes&lt;/p&gt;
&lt;p&gt;Fixes various problems with Pods that use xcasset bundles. Pods that use xcassets can now be used with the pod :path option.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/kylef&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Kyle Fuller&lt;/a&gt; &lt;a href=&quot;https://github.com/CocoaPods/CocoaPods/issues/1549&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;#1549&lt;/a&gt; &lt;a href=&quot;https://github.com/CocoaPods/CocoaPods/pull/3383&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;#3384&lt;/a&gt; &lt;a href=&quot;https://github.com/CocoaPods/CocoaPods/pull/3358&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;#3358&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;该解决BUG对应的Merge issue是&lt;a href=&quot;https://github.com/CocoaPods/CocoaPods/pull/3405&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;#3405&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过该关键节点引申出了一个BUG Fix的&lt;a href=&quot;https://github.com/CocoaPods/CocoaPods/commit/44cde6feb61360bc530d85ea52a418ffe023c7ed&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;commit - Do not discard .xcassets from the main project&lt;/a&gt;和&lt;a href=&quot;https://github.com/CocoaPods/CocoaPods/pull/2212&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;issue - Only include *.xcassets from Pods&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;从提交记录可以看出这两次提交分别是为了解决支持&lt;code&gt;:path&lt;/code&gt;属性和打包&lt;code&gt;xcasset&lt;/code&gt;时候遗漏了主工程的&lt;code&gt;xcasset&lt;/code&gt;的问题。&lt;/p&gt;
&lt;p&gt;原来这个暴力的拷贝脚本是用来&lt;font color=&quot;orange&quot;&gt;将主工程的&lt;code&gt;xcasset&lt;/code&gt;和Pod的&lt;code&gt;xcasset&lt;/code&gt;一起利用actool合成car用的&lt;/font&gt;。因为主工程的&lt;code&gt;xcasset&lt;/code&gt;命名不规律和文件存储位置的不规律, 和actool的特性有限。CocoaPods的研发者暂时也没有更好的办法, 所以采用这种暴力的方式！&lt;/p&gt;
&lt;font color=&quot;orange&quot;&gt;广大的网友如果有更好的方法, 可以帮助CocoaPods开发者解决该问题。笔者想了半天, 没有想出什么靠谱的方法。&lt;/font&gt;

&lt;p&gt;PS: 如果估计针对主工程的&lt;code&gt;xcasset&lt;/code&gt;做标志位的话, 和直接利用hook去屏蔽一些对应的资源文件本质上是没有差距的, 因为都需要在主工程里做额外的操作。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;&lt;p&gt;UIImage加载重名图片本身就存在问题, 因为图片不应该重名出现在工程里。但是, 在大型App开发中, 因为参与人员流动和数量的问题, 就不可避免的会出现各种各样的复杂情况。本文将笔者遇到的资源图片错误加载梳理了一下, 因为对CocoaPods和&lt;code&gt;xcasset&lt;/code&gt;共同使用的不了解, 导致了排查的困难。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CocoaPods在Pod里引用了任意一个xcasset相关的文件后, 就会去根目录搜索所有的xcasset组合成为最终的car&lt;/strong&gt;。CocoaPods设定这样脚本的原因是无法精确的将主工程下的&lt;code&gt;xcasset&lt;/code&gt;寻找到, 只能采用暴力的方式去解决, 暂时也没有更好的解决方案！&lt;/p&gt;
&lt;p&gt;PS: 本人技术水平有限, 如果有错误的地方, 请各位大大及时指出哈~~&lt;/p&gt;
&lt;h4 id=&quot;参考&quot;&gt;参考&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.apple.com/library/prerelease/ios/documentation/Xcode/Reference/xcode_ref-Asset_Catalog_Format/index.html#//apple_ref/doc/uid/TP40015170-CH18-SW1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Apple - Asset Catalog Format Reference&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/36008210/uiimage-load-wrong-image-in-main-bundle&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Stackoverflow - UIImage load wrong image in main bundle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://forums.developer.apple.com/message/124162&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Apple Developer Forum&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/alexzielenski/ThemeEngine&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Github - ThemeEngine&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/CocoaPods/CocoaPods&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub - CoocaPods&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章来自笔者工作中遇到一个难解的BUG - 在App中用&lt;code&gt;UIImage&lt;/code&gt;的&lt;code&gt;imageNamed:&lt;/code&gt;方法读取的图片始终是&lt;strong&gt;不正确&lt;/strong&gt;的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://blog.
    
    </summary>
    
    
      <category term="CocoaPods" scheme="http://startry.com/tags/CocoaPods/"/>
    
      <category term="xcasset" scheme="http://startry.com/tags/xcasset/"/>
    
  </entry>
  
  <entry>
    <title>我只是想要截个屏(续)</title>
    <link href="http://startry.com/2016/02/26/Screenshots-WKWebView/"/>
    <id>http://startry.com/2016/02/26/Screenshots-WKWebView/</id>
    <published>2016-02-26T08:26:23.000Z</published>
    <updated>2016-02-26T08:26:23.000Z</updated>
    
    <content type="html">&lt;p&gt;上两天写了一篇《&lt;a href=&quot;http://blog.startry.com/2016/02/24/Screenshots-With-SwViewCapture/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;我只是想要截个屏&lt;/a&gt;》的博文, 来描述了在书写&lt;a href=&quot;https://github.com/startry/SwViewCapture&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SwViewCapture&lt;/a&gt;中遇到的一些坎坷和解决方案。在《我只是想要截个屏》中并没有找到针对WKWebView的全内容截图的相对完美的解决方案, 只是用一种滚动的暴力的方式去截图然后组装临时解决。&lt;/p&gt;
&lt;p&gt;本文主要在上篇文章中做一些粗略的补充, 来描述SwViewCapture中是怎么更好的解决&lt;a href=&quot;https://developer.apple.com/library/prerelease/ios/documentation/WebKit/Reference/WKWebView_Ref/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;WKWebView&lt;/a&gt;的截屏问题, 还有怎么找到这种取巧的解决方案的~ &lt;/p&gt;
&lt;p&gt;PS: 如果大家想直接看实现原理, 请跳过&lt;strong&gt;几次失败尝试&lt;/strong&gt;章节~&lt;/p&gt;
&lt;h2 id=&quot;几次失败尝试&quot;&gt;几次失败尝试&lt;/h2&gt;&lt;p&gt;阅读过《&lt;a href=&quot;blog.startry.com/2016/02/24/Screenshots-With-SwViewCapture/&quot;&gt;我只是想要截个屏&lt;/a&gt;》的童鞋们可能都知道, 对于WKWebView的截图, 只能使用View的&lt;code&gt;drawViewHierarchyInRect:afterScreenUpdates:&lt;/code&gt;方法去获取截图。在此前我曾尝试用如下几种方案去截图, 均以&lt;strong&gt;失败&lt;/strong&gt;收尾。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将WKWebView的frame拉长和ContentSize的高度保持一致, 然后截图&lt;/li&gt;
&lt;li&gt;将WKWebView的frame拉长和ContentSize的高度一致, 然后通过WKWebView的&lt;code&gt;snapshotViewAfterScreenUpdates&lt;/code&gt;获取的view进行截图&lt;/li&gt;
&lt;li&gt;对WKWebView内部的WKContentView直接截图&lt;/li&gt;
&lt;li&gt;将WKScrollView对应的Screen进行拉伸, 然后对WKWebView进行等价拉伸, 再截图&lt;/li&gt;
&lt;li&gt;使用私有API&lt;code&gt;_snapshotRect:intoImageOfWidth:completionHandler&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上述第一、二、三种方法是笔者自己脑洞尝试, 可是截图要么完全是空白, 要么就只能显示屏幕区域的图。&lt;/p&gt;
&lt;p&gt;第四种和第五种是对WKWebView源码不了解的窥看后, 进行一种投机取巧尝试。&lt;/p&gt;
&lt;p&gt;既然已经实在找不到解决方案了, 笔者就去官网下载&lt;a href=&quot;http://www.opensource.apple.com/source/WebKit2/WebKit2-7601.1.46.9/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;源码&lt;/a&gt;, 希望能够找到突破口。WKWebView是开源的, 其源码放置在苹果官方开源网站&lt;a href=&quot;opensource.apple.com&quot;&gt;http://opensource.apple.com&lt;/a&gt;中, 项目名字为WebKit2。&lt;/p&gt;
&lt;p&gt;笔者以为下载到源码了, 至少能够找到一个突破口, 在打开工程项目后, 笔者就发现自己错了, 这个工程&lt;strong&gt;太庞大&lt;/strong&gt;了。。。&lt;/p&gt;
&lt;p&gt;WKWebView的组成笔者尚不熟悉, iOS的WKWebView底层更多的是WebKit的底层实现, 如果彻底从理解去阅读代码, 估计半个月甚至大半年都不一定读的完~ 有这个心思去阅读代码, 还不如先去阅读&lt;a href=&quot;https://book.douban.com/subject/25910556/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《WebKit技术内幕》&lt;/a&gt;这本书~ &lt;/p&gt;
&lt;p&gt;笔者自知不可能从阅读理解源码进行着手, 那就只能直奔要点: 关键字跟踪!笔者一开从&lt;code&gt;WKWebView.mm&lt;/code&gt;文件进行突破, 去寻找遮盖关键字&lt;code&gt;unobscured&lt;/code&gt;, 从这个关键字中&lt;a href=&quot;http://www.opensource.apple.com/source/WebKit2/WebKit2-7601.1.46.9/UIProcess/API/Cocoa/WKWebView.mm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;发现遮盖区域和scrollView的window&lt;/a&gt;相关, 因此尝试第四种方法, 修改window的大小~ 失败的结果唯一能够告诉笔者的就是: &lt;strong&gt;没有找到遮盖视图不渲染的根源!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;笔者在第一次寻找关键字失败后尝试从&lt;code&gt;snapshot&lt;/code&gt;这个关键字去突破, 结果发现了私有API&lt;code&gt;_snapshotRect:intoImageOfWidth:completionHandler&lt;/code&gt;。这也是第五种方法的尝试来源。通过&lt;code&gt;snapshot&lt;/code&gt;关键字其实还发现了隐藏在&lt;code&gt;WKWebView.mm&lt;/code&gt;底下的&lt;a href=&quot;http://www.opensource.apple.com/source/WebKit2/WebKit2-7601.1.46.9/UIProcess/API/Cocoa/WKWebView.mm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;_takeViewSnapshot&lt;/a&gt;方法, 可是该方法返回的对象是C++对象, 笔者就没有从Object-C层级对方法进行调用尝试。&lt;/p&gt;
&lt;p&gt;结合&lt;code&gt;snapshot&lt;/code&gt;和&lt;code&gt;unobscured&lt;/code&gt;两个关键字的搜索, 笔者在底层一串跟踪, 发现了WebPage、DrawingArea等一系列概念, 笔者偶然间在WebPage的初始化方法中发现有个&lt;code&gt;WebPageCreationParameters&lt;/code&gt;参数作为构造WebPage的初始参数, 其中包含了如下几个参数&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; PLATFORM(IOS)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    WebCore::FloatSize screenSize;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    WebCore::FloatSize availableScreenSize;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt; textAutosizingWidth;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通过全局搜索&lt;code&gt;availableScreenSize&lt;/code&gt;, 在&lt;a href=&quot;http://www.opensource.apple.com/source/WebKit2/WebKit2-7601.1.46.9/UIProcess/ios/WebPageProxyIOS.mm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;WebPageProxyIOS.mm&lt;/a&gt;源码中发现, WebPage的屏幕尺寸是根据&lt;code&gt;WKGetAvailableScreenSize()&lt;/code&gt;和&lt;code&gt;WKGetScreenSize()&lt;/code&gt;获取的, 核心代码如下:&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;FloatSize WebPageProxy::screenSize()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; FloatSize(WKGetScreenSize());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;FloatSize WebPageProxy::availableScreenSize()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; FloatSize(WKGetAvailableScreenSize());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;终于有些眉目了, 一全局搜索&lt;code&gt;WKGetAvailableScreenSize&lt;/code&gt;就&lt;strong&gt;崩溃&lt;/strong&gt;了~  在WebKit2开源中并没有这个方法的定义, 并且无法通过&lt;code&gt;Google&lt;/code&gt;和&lt;code&gt;Apple Developer&lt;/code&gt;搜索到相关信息… T_T&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最鸡血的来了, 跟踪了几个小时, 笔者放弃了…&lt;/strong&gt;  没错, 笔者直到最后都没有从源码中找到解决方案~ =。=&lt;/p&gt;
&lt;h2 id=&quot;WKWebView截图方案&quot;&gt;WKWebView截图方案&lt;/h2&gt;&lt;p&gt;虽然没有通过源码找到解决方案, 但是通过改变Window的尝试让我的脑洞打开, 想到了另外一种和滚动截图很相似的暴力的解决方式。&lt;/p&gt;
&lt;p&gt;PS: 滚动截图是笔者在&lt;a href=&quot;blog.startry.com/2016/02/24/Screenshots-With-SwViewCapture/&quot;&gt;我只想要截个屏&lt;/a&gt;中所描述的暴力解决截图的方式。实现方式就是滚动一页截取一页, 最后组装成一张长图。&lt;/p&gt;
&lt;p&gt;笔者想: &lt;em&gt;既然WKWebView的渲染区域是屏幕范围固定的, 那我不滚动视图, 不断的往上推视图呢?&lt;/em&gt; &lt;/p&gt;
&lt;p&gt;不断往上推视图的意思就是改变View的origin的y轴, 每截取一张图片后去上移View的高度(高度等价于该WKWebView在界面中的显示范围)和拉长WKWebView的总高度, 直到截取到了最后一张图并组装。&lt;/p&gt;
&lt;p&gt;这个思路有个小小的问题, 就是笔者曾经尝试通过放大WKWebView本身去截图, 但是却截出一片空白的情况。透过这个问题可以假设, 我不断上移y轴并放大高度的最后一张情况和上述有问题的情况完全一致, 可以猜测这个方法是无法正确的截取WKWebView的图的。&lt;/p&gt;
&lt;p&gt;笔者用了一种很巧妙的方法去躲避了这个问题, 就是去截取WKWebView的父视图, 因为无论WKWebView怎么改变, 通过WKWebView父视图截图是可以正确获取对应的界面的(笔者实验的)。 &lt;/p&gt;
&lt;p&gt;通过优化后大致的流程如下: &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基于WKWebView的尺寸伪造一个UIView, 并拉长至ContentSize高度&lt;/li&gt;
&lt;li&gt;将伪造的UIView作为WKWebView的父视图&lt;/li&gt;
&lt;li&gt;放置一张大画布长度和WKWebView的ContentSize高度一致&lt;/li&gt;
&lt;li&gt;对父视图进行普通截图并放置在大画布中&lt;/li&gt;
&lt;li&gt;将WKWebView的高度上移一个父视图的高度&lt;/li&gt;
&lt;li&gt;循环执行步骤3和步骤4直到总高度和WKWebView的ContentSize高度一致&lt;/li&gt;
&lt;li&gt;读取画布中的图像并返回&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;大致思路如图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://blog.startry.com/img/blog_swvc_wkwebview_solution.png&quot; alt=&quot;WKWebView合成示意&quot;&gt;&lt;/p&gt;
&lt;p&gt;思路核心代码如下:&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; containerView  = &lt;span class=&quot;type&quot;&gt;UIView&lt;/span&gt;(frame: &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.bounds)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.removeFromSuperview()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;containerView.addSubview(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; totalSize = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.scrollView.contentSize&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; page      = floorf(&lt;span class=&quot;type&quot;&gt;Float&lt;/span&gt;( totalSize.height / containerView.bounds.height))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;UIGraphicsBeginImageContextWithOptions&lt;/span&gt;(totalSize, &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;UIScreen&lt;/span&gt;.mainScreen().scale)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; index &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;...&lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;(page) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// async for, action need package a method&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; splitFrame = &lt;span class=&quot;type&quot;&gt;CGRectMake&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;CGFloat&lt;/span&gt;(index) * containerView.frame.size.height, containerView.bounds.size.width, containerView.frame.size.height) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; myFrame = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.frame&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        myFrame.origin.y = -(&lt;span class=&quot;type&quot;&gt;CGFloat&lt;/span&gt;(index) * containerView.frame.size.height)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.frame = myFrame &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	containerView.drawViewHierarchyInRect(splitFrame, afterScreenUpdates: &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; capturedImage = &lt;span class=&quot;type&quot;&gt;UIGraphicsGetImageFromCurrentImageContext&lt;/span&gt;()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;UIGraphicsEndImageContext&lt;/span&gt;()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通过这种方式果然可以截取完整的WKWebView, 并且不存在&lt;code&gt;position: fixed;&lt;/code&gt;的标签重复的问题。&lt;/p&gt;
&lt;font color=&quot;orange&quot;&gt;上述代码起示意作用, 实际循环部分需要等待延迟, 因为需要等待WKWebView在改变frame之后准备完毕执行下一次循环。&lt;/font&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;&lt;p&gt;因为WKWebView只能渲染屏幕范围大小左右的视图范围, 因此笔者就利用这个点, 不断的去改变WKWebView的frame去截图, 然后组装成为一张内容截图。通过这种方式可以巧妙的躲避过因为滚动视图产生的部分页面元素重复的问题。&lt;/p&gt;
&lt;p&gt;其实WKWebView现在在iOS开发应用中并没有UIWebView广泛, 做截图相关功能的开发者也可能会优先采用UIWebView最为搭载容器, 但是多多少少本篇文章应该还是会帮助到一些使用WKWebView的先驱者的~&lt;/p&gt;
&lt;p&gt;另: 本文提供的解决方案可能只是众多解决方案的其中一种, 并且相当的耗时也消耗内存, 希望大家可以一起想想能否有更优的解决方案~ 希望多多交流~ 如果有&lt;strong&gt;更好的方案&lt;/strong&gt;, 跪求&lt;strong&gt;Pull Request&lt;/strong&gt;或者提交&lt;strong&gt;issue&lt;/strong&gt;到&lt;a href=&quot;https://github.com/SwViewCapture&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SwViewCapture&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;PS: 鉴于个人水平有限, 有错误之处, 请大家及时指出~ 谢谢~&lt;/p&gt;
&lt;h4 id=&quot;参考文献&quot;&gt;参考文献&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://www.opensource.apple.com/source/WebKit2/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Apple Open Source - WebKit2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.apple.com/library/prerelease/ios/documentation/WebKit/Reference/WKWebView_Ref/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;iOS Developer library - WKWebView&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;blog.startry.com/2016/02/24/Screenshots-With-SwViewCapture/&quot;&gt;我只是想要截个屏&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;上两天写了一篇《&lt;a href=&quot;http://blog.startry.com/2016/02/24/Screenshots-With-SwViewCapture/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;我只是想要截个屏&lt;/a&gt;》的博文, 来描述
    
    </summary>
    
    
      <category term="Screenshots" scheme="http://startry.com/tags/Screenshots/"/>
    
      <category term="WKWebView" scheme="http://startry.com/tags/WKWebView/"/>
    
      <category term="iOS" scheme="http://startry.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>我只是想要截个屏</title>
    <link href="http://startry.com/2016/02/24/Screenshots-With-SwViewCapture/"/>
    <id>http://startry.com/2016/02/24/Screenshots-With-SwViewCapture/</id>
    <published>2016-02-24T13:03:08.000Z</published>
    <updated>2016-02-24T13:03:08.000Z</updated>
    
    <content type="html">&lt;p&gt;想必使用iPhone的用户, 大家都知道按照Home键+电源键就可以截屏了。 截屏对于产品经理、工程师、设计师都比较重要。那么在iOS中用代码截屏也是再常用不过的功能了~ 那么在iOS研发中, 怎么样才能有效的截屏呢? 笔者在上周用了2天时间去写了一个Swift版本的截图开源库 - &lt;a href=&quot;https://github.com/startry/SwViewCapture&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SwViewCapture&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;起初笔者有一个小小的想法, 怎么样去截取整个网页甚至整个滚动视图的内容呢? 造一个支持该功能的开源库会不会受欢迎呢?  基于CocoaChina+ App的分享思路以及笔者自己的一点小想法, 笔者决定写一个方便Swift开发者使用的截屏库, 支持截取页面载体所有内容的库。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;该想法的起源来自于&lt;a href=&quot;http://weibo.com/u/1746852880&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@子循&lt;/a&gt;的一个开源App - &lt;a href=&quot;https://github.com/zixun/CocoaChinaPlus&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CocoaChina+&lt;/a&gt;, 在该App中, 用户可以分享用户正在浏览的页面内容, 也就是WebView的内容。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大家可能好奇, 就这么一个截屏, 需要写2天么? 一开始笔者的想法很简单: 无非就写一个截屏库。笔者真正实际写起来的时候, 才发现原来光光一个截屏也有这么多的坎等着我去踩。笔者代码截屏中遇到的困难在此处梳理了一下, 防止大家也重复采坑。&lt;/p&gt;
&lt;h2 id=&quot;简化截屏API&quot;&gt;简化截屏API&lt;/h2&gt;&lt;p&gt;在刚开始写&lt;a href=&quot;https://github.com/startry/SwViewCapture&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SwViewCapture&lt;/a&gt;的时候, 笔者想实现的简单点, 先实现基础的截屏功能, 可以将任意的View直接转化成一张UIImageView。&lt;/p&gt;
&lt;h4 id=&quot;截屏基础实现&quot;&gt;截屏基础实现&lt;/h4&gt;&lt;p&gt;这个功能估计大部分iOS研发者都涉及到过, 在iOS7以前就一直用CoreGraphic的方式去Draw出对应的图。关键代码如下:&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;UIGraphicsBeginImageContextWithOptions&lt;/span&gt;(bounds.size, &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;UIScreen&lt;/span&gt;.mainScreen().scale)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.layer.renderInContext(context!)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; capturedImage = &lt;span class=&quot;type&quot;&gt;UIGraphicsGetImageFromCurrentImageContext&lt;/span&gt;()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;UIGraphicsEndImageContext&lt;/span&gt;()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上图代码的关键代码&lt;code&gt;renderInContext&lt;/code&gt;是&lt;code&gt;CALayer&lt;/code&gt;的方法, &lt;code&gt;CALayer&lt;/code&gt;是CoreGraphic底层的图层, 组成UIView。UIGraphic等相关操作Context是Quartz 2D框架中的API, 而Quartz 2D是CoreGraphic的其中一个组成。&lt;/p&gt;
&lt;p&gt;仅仅4行代码基本已经能够满足大部分的需求了~ 大部分是因为笔者在目前除了在WKWebView上此截图方法截图失败, 暂时还有在其他的View上截图失败, 有待继续检查。那么WKWebView又有什么问题呢?&lt;/p&gt;
&lt;h4 id=&quot;截屏遇上WKWebView&quot;&gt;截屏遇上WKWebView&lt;/h4&gt;&lt;p&gt;笔者在写&lt;a href=&quot;https://github.com/startry/SwViewCapture&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SwViewCapture&lt;/a&gt;的时候, 尝试去截取WKWebView的图。截图的结果返回给我的就仅仅只是一张背景图, 显然&lt;strong&gt;截图失败&lt;/strong&gt;。通过搜索StackOverflow和Google, 我发现WKWebView并不能简单的使用&lt;code&gt;layer.renderInContext&lt;/code&gt;的方法去绘制图形。&lt;/p&gt;
&lt;p&gt;如果直接调用&lt;code&gt;layer.renderInContext&lt;/code&gt;需要获取对应的Context, 但是在WKWebView中执行&lt;code&gt;UIGraphicsGetCurrentContext()&lt;/code&gt;的返回结果是nil &lt;em&gt;(具体的原理暂时还不明, 待笔者知晓之后会补充)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/24727499/wkwebview-screenshots&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;StackOverflow&lt;/a&gt;提供了一种解决思路是使用&lt;code&gt;UIView&lt;/code&gt;的&lt;code&gt;drawViewHierarchyInRect&lt;/code&gt;方法去截取屏幕视图。&lt;/p&gt;
&lt;p&gt;通过直接调用WKWebView的&lt;code&gt;drawViewHierarchyInRect&lt;/code&gt;方法(&lt;code&gt;afterScreenUpdates&lt;/code&gt;参数必须为&lt;code&gt;true&lt;/code&gt;), 可以成功的截取WKWebView的屏幕内容。&lt;/p&gt;
&lt;h4 id=&quot;页面嵌套的问题&quot;&gt;页面嵌套的问题&lt;/h4&gt;&lt;p&gt;在查找资料设法解决WKWebView截屏问题的时候, 无意中搜索到Chrome开源项目&lt;a href=&quot;https://www.chromium.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;chromium&lt;/a&gt;的截屏源码&lt;a href=&quot;https://chromium.googlesource.com/chromium/src.git/+/46.0.2478.0/ios/chrome/browser/snapshots/snapshot_manager.mm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SnapshotManager&lt;/a&gt;。笔者在阅读源码的时候发现自己漏考虑了一个大场景:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基础的UIView包含WKWebView场景下的截屏&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考&lt;a href=&quot;https://chromium.googlesource.com/chromium/src.git/+/46.0.2478.0/ios/chrome/browser/snapshots/snapshot_manager.mm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SnapshotManager&lt;/a&gt;中的解决方案, 定义一个递归函数去判断是否包含了WKWebView:&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;func&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;swContainsWKWebView&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Bool&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.isKindOfClass(&lt;span class=&quot;type&quot;&gt;WKWebView&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; subView &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.subviews &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (subView.swContainsWKWebView()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;最终普通截屏&lt;/strong&gt;的方案为:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;view中任意一个子View包含WKWebView, 则采用&lt;code&gt;drawViewHierarchyInRect&lt;/code&gt;的方式去截取视图&lt;/li&gt;
&lt;li&gt;view中任意一个子View都不包含WKWebView, 则采用&lt;code&gt;renderInContext&lt;/code&gt;的方式去截图&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大家可能好奇为啥不全部采用&lt;code&gt;drawViewHierarchyInRect&lt;/code&gt;的方式好了, 还多此一举来个判断, 引用chromium源码&lt;a href=&quot;https://chromium.googlesource.com/chromium/src.git/+/46.0.2478.0/ios/chrome/browser/snapshots/snapshot_manager.mm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SnapshotManager&lt;/a&gt;中的注释来解释为什么&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;  -drawViewHierarchyInRect:afterScreenUpdates:YES is buggy as of iOS 8.3.&lt;/p&gt;
&lt;p&gt;   Using it afterScreenUpdates:YES creates unexpected GPU glitches, screen&lt;/p&gt;
&lt;p&gt;   redraws during animations, broken pinch to dismiss on tablet, etc.  For now&lt;/p&gt;
&lt;p&gt;   only using this with WKWebView, which depends on -drawViewHierarchyInRect.&lt;/p&gt;
&lt;p&gt;   TODO(justincohen): Remove this (and always use drawViewHierarchyInRect)&lt;/p&gt;
&lt;p&gt;   once the iOS 8 bugs have been fixed.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;PS: 写iOS的这些年来, 多多少少已经碰到不少的iOS系统原生BUG, 也是醉了&lt;/p&gt;
&lt;p&gt;截止到笔者写本篇博客的时候, &lt;a href=&quot;https://www.chromium.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;chromium&lt;/a&gt;项目master上仍旧还存在该段注释。&lt;/p&gt;
&lt;p&gt;笔者将上述基础截屏功能封装了一下, 在&lt;a href=&quot;https://github.com/startry/SwViewCapture&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SwViewCapture&lt;/a&gt;库中, 仅仅需要一行代码即可实现截图功能:&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;view.swCapture &amp;#123; (capturedImage) -&amp;gt; &lt;span class=&quot;type&quot;&gt;Void&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// Do something with capturedImage(UIImage)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;截取内容实现&quot;&gt;截取内容实现&lt;/h2&gt;&lt;p&gt;普通截屏实现了, 那么就开始想怎么去实现全内容的截屏。开发一个复杂的功能, 第一步就是先把功能简单化实现, 那么笔者一开始就拿&lt;code&gt;UIWebView&lt;/code&gt;作为实验对象去实现内容的截取功能。那么问题来了, 怎么实现呢? &lt;/p&gt;
&lt;p&gt;通过打印UIWebView内部的UIScrollView的尺寸, 可以初步了解到UIWebView的内容本质上其实是承载在内部的UIScrollView中的。那么一个简单的耗内存的实现思路就冒出来了:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;将UIWebView的长宽修改为UIScrollView的内容尺寸大小, 然后将UIWebView用普通截图的方式截取出来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;基于上述这个简单的想法, 笔者立马想到是否可以&lt;strong&gt;直接对UIWebView内部的UIScrollView进行长宽修改操作并截屏&lt;/strong&gt;, 如果可行的话, 则可以直接引申使用在UITableView以及基础的UIScrollView上了。&lt;/p&gt;
&lt;p&gt;基本实现代码如下:&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;UIGraphicsBeginImageContext&lt;/span&gt;(scrollView.contentSize)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; savedContentOffset = scrollView.contentOffset&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; savedFrame = scrollView.frame&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;scrollView.contentOffset = &lt;span class=&quot;type&quot;&gt;CGPointZero&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;scrollView.frame = &lt;span class=&quot;type&quot;&gt;CGRectMake&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, scrollView.contentSize.width, scrollView.contentSize.height)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;scrollView.layer.renderInContext(&lt;span class=&quot;type&quot;&gt;UIGraphicsGetCurrentContext&lt;/span&gt;()!)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; image = &lt;span class=&quot;type&quot;&gt;UIGraphicsGetImageFromCurrentImageContext&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;scrollView.contentOffset = savedContentOffset;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;scrollView.frame = savedFrame;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;UIGraphicsEndImageContext&lt;/span&gt;()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个场景下, UIScrollView可以被正常的截图, 那么引申修改应用在UIWebView上应该不是什么难事吧? &lt;/p&gt;
&lt;p&gt;PS: UIWebView有个get方法可以获取对应的UIScrollView&lt;/p&gt;
&lt;h4 id=&quot;iOS8的诡异BUG&quot;&gt;iOS8的诡异BUG&lt;/h4&gt;&lt;p&gt;在基本的场景下, 该方法都可以正常的截取UIScrollView, 但是在iOS8环境下会出现尾部可视区域为黑色的异常BUG。(这个BUG可能和UIScrollView在被UINavigationController托管下的VC下产生的)&lt;/p&gt;
&lt;p&gt;通过一阵搜索Stackoverflow和CocoaChina+的源码提示, 有一个比较合适的&lt;a href=&quot;http://stackoverflow.com/questions/3539717/getting-a-screenshot-of-a-uiscrollview-including-offscreen-parts/3539944#28343200&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;解决方法&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; add scrollview to another temp view and render it. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;把UIScrollView单独拎出来, 放在其他临时的UIView里单独渲染。通过该方法果然可以将iOS8的渲染问题给屏蔽掉。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://blog.startry.com/img/blog_swvc_bug_solution.png&quot; alt=&quot;改进方案合成示意&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;异步渲染粗暴解决方案&quot;&gt;异步渲染粗暴解决方案&lt;/h4&gt;&lt;p&gt;将之前所描述的截图应用到实际场景中, 笔者发现有些网页的元素是异步加载的, 即只有页面滚动到对应的部分, 才会执行渲染加载(笔者的博客首页主题就是这种场景)。另外, UIScrollView和UITableView中也不缺乏这种场景。&lt;/p&gt;
&lt;p&gt;对于这种异步的方式, 没有一种完美的解决方案, 笔者只能解决一种暴力的方式解决部分案例:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;截屏前滚动ScrollView至底部, 再滚动回首部&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;截图闪屏问题&quot;&gt;截图闪屏问题&lt;/h4&gt;&lt;p&gt;通过&lt;a href=&quot;http://stackoverflow.com/questions/3539717/getting-a-screenshot-of-a-uiscrollview-including-offscreen-parts/3539944#28343200&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Stackovetflow - Getting a Screenshot of a UIScrollView including offscreen parts&lt;/a&gt;中的方式修复了&lt;code&gt;iOS8的截图多个黑色区域的诡异BUG&lt;/code&gt;后, 在实际截图中发现了另外一个问题:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将屏幕中正在显示的View拎出来放置在其他View中渲染, 渲染完毕后再恢复, 可能会出现一闪而过的情况。 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上述现象产生的原因大家估计都知道: &lt;strong&gt;因为View离开当前视图的时候, 触发了界面渲染, 显示界面中的视图已经不在显示界面中, 自然就变成了背景色。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;既然要做一个截屏库, 那么这个问题也是需要解决的, 总不能让人家调用截屏API的时候闪一下吧?&lt;/p&gt;
&lt;p&gt;笔者思考了一下, &lt;font color=&quot;orange&quot;&gt;决定引入一张当前view的截图并遮盖在此view的父view上, 让大家视觉产生一种幻觉, 来掩盖真正的视图的操作。&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;基于iOS7中View提供的API - &lt;code&gt;snapshotViewAfterScreenUpdates&lt;/code&gt;, 可以直接生产一个截屏视图View, 剩下的工作如下:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过&lt;code&gt;snapshotViewAfterScreenUpdates&lt;/code&gt;产生假的遮盖View&lt;/li&gt;
&lt;li&gt;选择目标视图的parentView, 和目标视图在parentView的层级&lt;/li&gt;
&lt;li&gt;将遮盖view添加到目标视图的parentView中的相同层级中&lt;/li&gt;
&lt;li&gt;执行真正的截图逻辑&lt;/li&gt;
&lt;li&gt;将假的遮盖View从视图中移除&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://blog.startry.com/img/blog_swvc_fake_cover.png&quot; alt=&quot;伪图遮盖示意&quot;&gt;&lt;/p&gt;
&lt;p&gt;通过上述方法, 截图闪屏的问题就完美解决了~ &lt;/p&gt;
&lt;h4 id=&quot;setFrame破坏&quot;&gt;setFrame破坏&lt;/h4&gt;&lt;p&gt;大家注意到在执行全内容截屏的时候, 会动态的去修改UIScrollView的frame, 然后执行相应的逻辑内容。在执行截图逻辑功能的时候, 往往会涉及异步的操作, 那么在下述场景下截图可能会出现异常:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户在对应的&lt;code&gt;layoutSubView&lt;/code&gt;中设置修改了需要截图的view的&lt;code&gt;frame&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;用户在截图过程中对需要截图的view的&lt;code&gt;frame&lt;/code&gt;进行了操作&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其实场景2包含了场景1, 总结下就是&lt;strong&gt;在截图过程中, 任意的frame操作都会对截图行为造成破坏, 但是frame操作可能是由layoutSubView等系统函数触发的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;既然出现这个问题, 那么笔者就要解决这个问题, 笔者能够想到的就是&lt;strong&gt;在截图过程中无效化对该View任意的frame操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;既然已经想到了解决方案, 那么就设计代码实现。笔者一开始尝试的方法是&lt;strong&gt;通过运行时对UIView绑定一个&lt;code&gt;isCapturing&lt;/code&gt;的属性, 然后override目标视图的&lt;code&gt;frame&lt;/code&gt;的&lt;code&gt;set&lt;/code&gt;和&lt;code&gt;get&lt;/code&gt;方法, 在&lt;code&gt;set&lt;/code&gt;方法中通过判断是否截图中去实现是否调用super的frame操作&lt;/strong&gt;。但是在实际操作中发现, 目标视图的&lt;code&gt;frame&lt;/code&gt;中&lt;code&gt;set&lt;/code&gt;和&lt;code&gt;get&lt;/code&gt;的操作并单纯的做了读取和写入的操作, 还有系统的对该视图的操作逻辑存在, 因此&lt;font color=&quot;red&quot;&gt;不能通过该方式去禁用frame&lt;/font&gt;。&lt;/p&gt;
&lt;p&gt;在override frame的方案失败后, 笔者又尝试了下述方案:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;利用&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Cocoa/Reference/ObjCRuntimeRef/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Runtime&lt;/a&gt;在截图前替换目标view的setFrame方法, 然后在截图结束后, 用运行时将其复原&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;技术实现如下:&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; method: &lt;span class=&quot;type&quot;&gt;Method&lt;/span&gt; = class_getInstanceMethod(object_getClass(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;), &lt;span class=&quot;type&quot;&gt;Selector&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;setFrame:&quot;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; swizzledMethod: &lt;span class=&quot;type&quot;&gt;Method&lt;/span&gt; = class_getInstanceMethod(object_getClass(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;), &lt;span class=&quot;type&quot;&gt;Selector&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;swSetFrame:&quot;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        method_exchangeImplementations(method, swizzledMethod)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// capturing&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// capturing&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;method_exchangeImplementations(swizzledMethod, method)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;PS: &lt;code&gt;swSetFrame&lt;/code&gt;方法是一个空方法, 用来无效化设置frame&lt;/p&gt;
&lt;p&gt;这里抛给大家一个问题: 约束是否也有相同的问题呢? &lt;/p&gt;
&lt;p&gt;&lt;em&gt;关于SwViewCapture库对约束的处理是笔者将来的优化点之一&lt;/em&gt;&lt;/p&gt;
&lt;h4 id=&quot;截取内容又遇见WKWebView&quot;&gt;截取内容又遇见WKWebView&lt;/h4&gt;&lt;p&gt;基础的截图功能和BUG都已经解决的差不多了, 那么来试试最麻烦的WKWebView吧。经过简单测试, 通过前面封装UIScrollView的截图方式果然&lt;font color=&quot;red&quot;&gt;不能对WKWebView进行全内容截图&lt;/font&gt;。&lt;/p&gt;
&lt;p&gt;笔者好奇WKWebView的组成结构, 就通过扫描subview的方式打印了WKWebView:&lt;/p&gt;
&lt;p&gt;打印方式:&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; subView &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; (webView?.subviews)! &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;v name: &lt;span class=&quot;subst&quot;&gt;\(subView.&lt;span class=&quot;keyword&quot;&gt;dynamicType&lt;/span&gt;)&lt;/span&gt;&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;(subView.&lt;span class=&quot;keyword&quot;&gt;dynamicType&lt;/span&gt;) == &lt;span class=&quot;string&quot;&gt;&quot;WKScrollView&quot;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;comment&quot;&gt;// Do something&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; subSubView &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; subView.subviews &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;sub name: &lt;span class=&quot;subst&quot;&gt;\(subSubView.&lt;span class=&quot;keyword&quot;&gt;dynamicType&lt;/span&gt;)&lt;/span&gt;&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;(subSubView.&lt;span class=&quot;keyword&quot;&gt;dynamicType&lt;/span&gt;) == &lt;span class=&quot;string&quot;&gt;&quot;WKContentView&quot;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;comment&quot;&gt;// Do something&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;打印结果:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;WKWebView&lt;ul&gt;
&lt;li&gt;WKScrollView&lt;ul&gt;
&lt;li&gt;WKContentView&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;WKScrollView&lt;/code&gt;的基类是&lt;code&gt;UIWebScrollView&lt;/code&gt;, &lt;code&gt;UIWebScrollView&lt;/code&gt;的基类是&lt;code&gt;UIScrollView&lt;/code&gt;, 并且WKContentView下包含了和实际网页内容一样的宽和高。那么是否可以通过获取WKWebView下面的&lt;code&gt;WKScrollView&lt;/code&gt;进行截图呢? &lt;/p&gt;
&lt;p&gt;笔者开心的以为找到了突破口, 赶紧尝试截图。结果无论是对WKWebView本身截图或者对其任意一个子类截图, 结果截图的结果仍旧还是空白一片。&lt;/p&gt;
&lt;p&gt;在上述两个方式都失败的无奈情况下, 笔者暂时没有特别好的解决方案, 绝对先临时采用暴力的渲染方式去合成一张大截图:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;截取屏幕显示范围大小的视图, 滚动, 按页截图, 滚动, 按页截图, 循环操作直到滚动到最后一页, 最后将所有截取的图片合成为一张大图。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://blog.startry.com/img/blog_swvc_wkwebview.png&quot; alt=&quot;截图合成示意&quot;&gt;&lt;/p&gt;
&lt;p&gt;通过上述截图方案截取的图片仍存在&lt;font color=&quot;red&quot;&gt;不完美&lt;/font&gt;的部分, 尤其针对标签为&lt;code&gt;position: fixed;&lt;/code&gt;的&lt;code&gt;div&lt;/code&gt;元素。标签为&lt;code&gt;position: fixed;&lt;/code&gt;的&lt;code&gt;div&lt;/code&gt;元素会循环出现在生产的大图上。&lt;/p&gt;
&lt;p&gt;针对这种场景, &lt;strong&gt;笔者暂时不计划处理&lt;/strong&gt;, 因为WKWebView的这种截图方式暂时还不是笔者理想的截图方式, 需要急用的童鞋们可以暂时使用业务逻辑方式去处理:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;扫描&lt;code&gt;position: fixed;&lt;/code&gt;的元素&lt;/li&gt;
&lt;li&gt;计算&lt;code&gt;postion: fixed;&lt;/code&gt; 的元素距离顶部和尾部的高度&lt;/li&gt;
&lt;li&gt;根据顶部和尾部的距离分别进行对应的显示和隐藏操作&lt;/li&gt;
&lt;/ol&gt;
&lt;font color=&quot;orange&quot;&gt;关于WKWebView截图, 如果大伙计大家谁有更好一些的截图方案, 请告知, 相互学习提高; 本人也会不断尝试新的方式, 看看能否和UIWebView一样完美的截取WKWebView; 笔者认为WKWebView绝对是有办法完美截取所有内容的, 只是暂时没有找到&lt;/font&gt;

&lt;p&gt;基于前面内容截图的实现描述, 笔者将API简化封装, 只需要使用&lt;a href=&quot;https://github.com/startry/SwViewCapture&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SwViewCapture&lt;/a&gt;的时候, 调用如下代码即可使用:&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;view.swContentCapture &amp;#123; (capturedImage) -&amp;gt; &lt;span class=&quot;type&quot;&gt;Void&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// Do something with capturedImage(UIImage)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;关于性能&quot;&gt;关于性能&lt;/h2&gt;&lt;h4 id=&quot;绘图性能问题&quot;&gt;绘图性能问题&lt;/h4&gt;&lt;p&gt;编写客户端程序的大家可能都知道, 只有主线程可以操作视图。因为iOS和Android系统在底下做了保护, 非主线程操作视图的行为都可能产生不可预计的后果, 因此系统发现在非主线程进行视图操作的时候, 往往会主动抛出异常。CoreGraphic(draw)的方式绘制视图是可以支持多线程操作, 绘制过程也不会被视图展现出来。&lt;/p&gt;
&lt;p&gt;在写&lt;a href=&quot;https://github.com/startry/SwViewCapture&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SwViewCapture&lt;/a&gt;的时候, 我曾尝试着用&lt;strong&gt;异步(其他线程)&lt;/strong&gt;的方式去操作绘图过程, 在&lt;code&gt;renderInContext&lt;/code&gt;和&lt;code&gt;drawViewHierarchyInRect&lt;/code&gt;下均作过尝试。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;renderInContext&lt;/code&gt;对异步绘制支持的挺好, 并没有出现截图失败以及系统闪退的情况。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;drawViewHierarchyInRect&lt;/code&gt;对多线程并不能友好支持, 可能因为&lt;code&gt;drawViewHierarchyInRect&lt;/code&gt;是UIView的方法的缘故, 在GCD异步线程中用&lt;code&gt;drawViewHierarchyInRect&lt;/code&gt;绘制的图像会出现绘制丢失和失败的情况。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;鉴于&lt;code&gt;drawViewHierarchyInRect&lt;/code&gt;方法对线程支持的友好性不够, 笔者在第一版本的&lt;a href=&quot;https://github.com/startry/SwViewCapture&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SwViewCapture&lt;/a&gt;中并没有考虑去使用多线程的方式去优化性能, 是需要进一步改进和尝试的地方。&lt;/p&gt;
&lt;h4 id=&quot;内存过大问题&quot;&gt;内存过大问题&lt;/h4&gt;&lt;p&gt;笔者在第一版本的&lt;a href=&quot;https://github.com/startry/SwViewCapture&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SwViewCapture&lt;/a&gt;中没有去考虑内存问题, 因此如果非常长的UIScrollView去截取图片的时候可能会出现卡顿甚至闪退的现象。 &lt;/p&gt;
&lt;p&gt;笔者认为在截图之前, 用户自己应该大概知道自己要截图的视图的大小, 需要进行一定的预先处理。笔者计划在以后引入区域块截图的方式让用户自定义的去控制截取视图的大小, 这样来规避可能存在的截图导致内存过大的问题。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;&lt;p&gt;笔者一开始只是想实现一个截取网页内容的一个小功能, 在实现过程中发现截图竟然也可以踩出这么的坑, 便将采坑的过程总结成这篇文章, 供大家参考。同时, 将采坑实现的产物以Swift库&lt;a href=&quot;https://github.com/startry/SwViewCapture&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SwViewCapture&lt;/a&gt;的形式开源在Github上。&lt;/p&gt;
&lt;p&gt;笔者将题目取为&lt;code&gt;我只是想截个屏&lt;/code&gt;, 是一种自嘲的方式来描述程序员实现一个功能的艰辛啊~&lt;/p&gt;
&lt;p&gt;PS: 本人水平有限, 有错误之处请大家及时指出~~ 如果觉得文章有用, 可以&lt;a href=&quot;http://blog.startry.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;多多来访&lt;/a&gt;哇~&lt;/p&gt;
&lt;h4 id=&quot;参考链接&quot;&gt;参考链接&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/24727499/wkwebview-screenshots&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;StackOverflow - WKWebView Screenshots&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/3539717/getting-a-screenshot-of-a-uiscrollview-including-offscreen-parts&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;StackOvetflow - Getting a Screenshot of a UIScrollView including offscreen parts&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/startry/SwViewCapture&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SwViewCapture&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/zixun/CocoaChinaPlus&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CocoaChina+&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://chromium.googlesource.com/chromium/src.git/+/46.0.2478.0/ios/chrome/browser/snapshots/snapshot_manager.mm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;chromium - SnapshotManager&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Cocoa/Reference/ObjCRuntimeRef/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Object-C Runtime Reference&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;想必使用iPhone的用户, 大家都知道按照Home键+电源键就可以截屏了。 截屏对于产品经理、工程师、设计师都比较重要。那么在iOS中用代码截屏也是再常用不过的功能了~ 那么在iOS研发中, 怎么样才能有效的截屏呢? 笔者在上周用了2天时间去写了一个Swift版本的截图开
    
    </summary>
    
    
      <category term="Screenshots" scheme="http://startry.com/tags/Screenshots/"/>
    
      <category term="iOS" scheme="http://startry.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS界面跳转的一些优化方案</title>
    <link href="http://startry.com/2016/02/14/Think-Of-UIViewController-Switch/"/>
    <id>http://startry.com/2016/02/14/Think-Of-UIViewController-Switch/</id>
    <published>2016-02-14T07:39:11.000Z</published>
    <updated>2016-02-14T07:39:11.000Z</updated>
    
    <content type="html">&lt;p&gt;App应用程序开发, 界面跳转是基础中的基础, 几乎没有一个App是用不到界面跳转的, 那么怎么样去书写界面跳转代码才是比较合理的呢?&lt;/p&gt;
&lt;p&gt;大家可能在想跳转无非就2种方式, 能有什么内容? 其实并不是这样子的, 对于研发老手来说, 大型应用几乎都是利用URLScheme进行全方位的解决方案; 对于研发新手来说, 他们可能并没有遇到多路口界面跳转的瓶颈, 只会使用一些常用跳转, 并不会意识到界面跳转潜在的一些问题, 甚至无法严格区分Present和Push的操作区别~&lt;/p&gt;
&lt;p&gt;本文将针对界面跳转提出一些优化解决方案~&lt;/p&gt;
&lt;h3 id=&quot;常用跳转方式&quot;&gt;常用跳转方式&lt;/h3&gt;&lt;p&gt;iOS常用的跳转方式只有两种&lt;a href=&quot;https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UIViewController_Class/#//apple_ref/doc/uid/TP40006926-CH3-SW96&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Present&lt;/a&gt;和&lt;a href=&quot;https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UINavigationController_Class/index.html#//apple_ref/doc/uid/TP40006934-CH3-SW13&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Push&lt;/a&gt;。Push和Present最直观的区别是默认的转场效果, Present的默认转场效果是自下而上的, Push的转场效果是自右到左的。Push往往需要搭配&lt;a href=&quot;https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UINavigationController_Class/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;UINavigationController&lt;/a&gt;来使用。&lt;/p&gt;
&lt;p&gt;Push跳转使用示意:&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;UIViewController *nextViewController = [[UIViewController alloc] init];&amp;#10;nextViewController.title = @&amp;#34;&amp;#31532;&amp;#20108;&amp;#20010;&amp;#30028;&amp;#38754;&amp;#34;;&amp;#10;&amp;#10;[self.navigationController pushViewController:nextViewController animated:YES];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Present跳转使用示意:&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;UIViewController *nextViewController = [[UIViewController alloc] init];&amp;#10;nextViewController.title = @&amp;#34;&amp;#31532;&amp;#20108;&amp;#20010;&amp;#30028;&amp;#38754;&amp;#34;;&amp;#10;&amp;#10;[self presentViewController:nextViewContrller animated:YES completed:nil];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在大部分情况下, iOS研发者都在滥用Push的跳转方式, 往往一个App仅仅包含一个UINavigationController。产生滥用的原因是因为Present的跳转太过难于定制转场效果, 仅仅只能使用系统提供的4种打开方式。&lt;/p&gt;
&lt;p&gt;在满足产品要求的前提下, 其实可以基于&lt;strong&gt;模块内跳转&lt;/strong&gt;和&lt;strong&gt;模块外跳转&lt;/strong&gt;的思量去考虑采用Present的方式还是Push的方式去跳转界面。&lt;/p&gt;
&lt;p&gt;PS: 还有一种界面切换方式是利用&lt;a href=&quot;https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UIViewController_Class/#//apple_ref/doc/uid/TP40006926-CH3-SW86&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ChildViewController&lt;/a&gt;, 进行独立界面的控制。需要高度定制的界面可以采用这种方式, 例如基于地图或者相机的应用。基于ChildViewController的方式内容篇幅太长, 在本文就暂时不介绍了, 以后再补充~&lt;/p&gt;
&lt;h3 id=&quot;常用跳转方式瓶颈&quot;&gt;常用跳转方式瓶颈&lt;/h3&gt;&lt;p&gt;常用的跳转方式其实已经几乎可以满足我们所有的跳转, 但是&lt;strong&gt;欠缺一层业务层次的高层级封装&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;举一个实际使用场景, 某App支持4种页面打开方式:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Push推送&lt;/li&gt;
&lt;li&gt;App外部网页打开&lt;/li&gt;
&lt;li&gt;App内部网页打开&lt;/li&gt;
&lt;li&gt;应用内点击打开&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://blog.startry.com/img/blog_sheme_directly.png&quot; alt=&quot;多入口示意&quot;&gt;&lt;/p&gt;
&lt;p&gt;这四种方式均跳转到DetailViewController界面。普通的跳转依然可以满足该场景, 最简单的解决方案是在四个不同的地方都写一个独立的界面打开逻辑。&lt;/p&gt;
&lt;p&gt;作为一名业务模块人才, 如此不复用代码合理么? 作为一名App架构师, 如此冗余四份入口代码合适么? &lt;/p&gt;
&lt;p&gt;如果您觉得不合适, 那自然需要去抽离代码到统一的地方去书写一套统一的管理逻辑; 如果您觉得合适, 那么您会设想什么方案去根据外部网页以及Push内容去转化代码至普通跳转代码呢?&lt;/p&gt;
&lt;h3 id=&quot;URLScheme解决方案&quot;&gt;URLScheme解决方案&lt;/h3&gt;&lt;p&gt;我们先根据前面提到的四种场景进行场景分析:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;外部网页场景:&lt;ul&gt;
&lt;li&gt;只能使用iOS自带的URLScheme的方式去打开App, 然后通过AppDelegate中事件去获取对应的URL进行匹配&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Push推送场景:&lt;ul&gt;
&lt;li&gt;在extra字段中定义个链接字段, 链接字段是个字符串或者数字代号, 用于在AppDelegate中事件去获取对应的代号进行匹配; 既然代码是自定义的, 那自然可以定义成一个URL了&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;内部网页场景&lt;ul&gt;
&lt;li&gt;熟悉iOS WebView开发的童鞋们都知道, UIWebView的JS交互本质上是通过截获URL请求去实现的, 那么既然是传递URL地址, 就可以和外部网页使用相关的方式, 只不过在不同的位置进行对应的URL匹配&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;应用内点击打开&lt;ul&gt;
&lt;li&gt;可以采用普通打开方式, 也可以通过一个抽离的URLScheme匹配器去匹配打开&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据上述四个场景, 我们可以发现, 解决上述四个应用场景, 我们需要的是引入一个抽离的URLScheme匹配器去匹配打开轮转界面~ &lt;/p&gt;
&lt;p&gt;利用URLScheme的方式进行一层封装, 几乎可以完美解决多入口打开App的逻辑复用问题。&lt;/p&gt;
&lt;p&gt;PS: 一般情况下, URLScheme的抽离器不需要自己封装, 可以使用开源现成的, 很少场景需要高度定制。&lt;/p&gt;
&lt;p&gt;开源URLScheme解决方案:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/clayallsopp/routable-ios&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Routable&lt;/a&gt; Android和iOS均支持的一款权威的应用内URL跳转路由, 几乎可以满足所有需求&lt;ul&gt;
&lt;li&gt;代码切入性比较低, 没有冗余的继承封装。&lt;/li&gt;
&lt;li&gt;可以指定NavigationController, 方便定制ChildController的跳转&lt;/li&gt;
&lt;li&gt;可以多个Router组合使用, 灵活性高&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/gaosboy/urlmanager&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;urlmananger&lt;/a&gt; 国内技术问题网站&lt;a href=&quot;https://segmentfault.com.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;segmentfault.com&lt;/a&gt;开发者抽离的一个跳转器&lt;ul&gt;
&lt;li&gt;需要嵌入继承和绑定使用NavigationController, 架构设计层级嵌入性很高, 没有Routable合理&lt;/li&gt;
&lt;li&gt;无法多个组合使用, 灵活性没有Routable高&lt;/li&gt;
&lt;li&gt;封装层次高, 快速使用可以采用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;个人比较倾向使用Routable, 因为并没有在架构上对代码进行嵌入, 比较符合开发者口味~&lt;/p&gt;
&lt;p&gt;以Routable作为示例, 本文可以通过如下代码在App启动的时候就提前注册(PS: Push点击打开执行Optional参数之前注册)&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[[Routable sharedRouter] map:@&amp;#34;detail/:id&amp;#34; toController:[DetailController class]];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;假设您的App URLScheme前缀为&lt;code&gt;demo123&lt;/code&gt;, 您只需要在上述四个场景分别传递&lt;code&gt;demo123://detail/88&lt;/code&gt;过来即可。&lt;code&gt;88&lt;/code&gt;只是示例的一个随意乱写的id编号, 作为Restful分格的参数进行处理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://blog.startry.com/img/blog_scheme_routable.png&quot; alt=&quot;Routable改造示意&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;URLScheme些许问题&quot;&gt;URLScheme些许问题&lt;/h3&gt;&lt;p&gt;URLScheme进行界面跳转的解决方案也不是完美的, 个人开发时候遇到最大的问题就是传值问题&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;怎么传递对象值&lt;ul&gt;
&lt;li&gt;URLScheme原则上不支持传递复杂的对象, 通过URLScheme方式打开的界面理论上每个界面都相对保持逻辑独立(逻辑独立的代价往往是牺牲细微的用户体验), 逻辑独立的界面可以有更好的架构设计&lt;/li&gt;
&lt;li&gt;通过外部URL或者Push的方式是无法传递对象的, 可以不用考虑传递对象的场景&lt;/li&gt;
&lt;li&gt;应用内界面跳转可以根据实际场景去区分使用URLScheme的方式还是普通的方式进行界面跳转控制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;怎么传递URL值&lt;ul&gt;
&lt;li&gt;URLScheme打开的界面有时候也需要传递URL值用于对应的界面, 最常见的是打开图片管理器以及打开WebView的界面, 这种场景可以采用约定加密的方式进行处理, 对传递的URL进行URIEncode和取值时候的URIDecode。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Push长度限制&lt;ul&gt;
&lt;li&gt;坑爹的APNs规定了Push内容的总长度不能大于255字节, 那么URLScheme的参数传递就收到限制。&lt;/li&gt;
&lt;li&gt;最常用的解决方案是压缩字段名字和内容, 传递的字段劲量用一个单词表示, 值字段可以隐藏掉URLScheme的前缀, 只保留后缀以及参数。&lt;/li&gt;
&lt;li&gt;还有一种通过的Push长度解决方案是, push只是触发器, 触发App请求去获取真正的内容来绕过长度限制。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;传值对象&quot;&gt;传值对象&lt;/h4&gt;&lt;p&gt;此处针对应用内跳转使用url scheme还是普通方式进行一些议论, 个人觉得一套应用里如果有两种方式跳转, 虽然灵活性高, 但是比较难以控制, 因此最好都采用一套方式跳转, 那自然是使用url scheme。那复杂传值的问题依旧无法得到解决。&lt;/p&gt;
&lt;p&gt;有些开发者为了省时间, 直接通过类似Notification的方式或者用单例对象去维护进行值传递, 也不失为一个方法。&lt;/p&gt;
&lt;p&gt;但是我在思考, 有没有一种相对完美的解决方案, 能够将传值问题彻底用url scheme进行传递呢?&lt;/p&gt;
&lt;p&gt;结合本人喜欢使用的库&lt;a href=&quot;https://github.com/icanzilb/JSONModel&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JSONModel&lt;/a&gt;, 我想到了一种暴力且耗时的解决方案, 但是至少不产生耦合哈~&lt;/p&gt;
&lt;p&gt;暴力解决方案步骤:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;JSON化对象&lt;/li&gt;
&lt;li&gt;将对象JSON字符串Base64加密&lt;/li&gt;
&lt;li&gt;将Base64加密后的字符串作为url参数传递&lt;/li&gt;
&lt;li&gt;接受者处理参数的时候反Base64解密&lt;/li&gt;
&lt;li&gt;将解密后的JSON对象用模型实例化&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;针对暴力解决方案, 本人设想了&lt;em&gt;四个自问自答&lt;/em&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么不直接Base64对象而需要将其JSON字符串话呢?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答: 为了接受者解密后的直观性。在大型App开发过程中, 解密者解析后不一定知道用哪个模型去实例化JSON字符串, 通过这种方式, 解密者可以不关心接受数据后的模型实例而自由发挥。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;利用这种方式暴力解决后, url会不会很长?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答: 这种方式传递的url会超级长, 但是在应用内进行页面处理的场景, 不需要可以的去考虑url的长度。但是url的长度可能会影响解析的性能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么不直接通过广播或者单例维护的方式传值?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答: 为了解耦。 大型App维护的时候, 如果一个内存对象是公用的, 是十分难以维护的, 应该尽量减少传递对象之间的耦合。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么需要base64加密而不直接采用uriencode的方式?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答: 为了解决模型嵌套的问题。因为一个模型里可能会嵌套另外一个模型, 当然通过JSON字符串本身可以实现模型嵌套的解决, 那可以有更加节省性能的解决方案。&lt;/p&gt;
&lt;p&gt;本人水平有限, 此处的暴力的方式是目前本人觉得&lt;strong&gt;相对耦合度低并且比较好的一种解决方案&lt;/strong&gt;。对于目前的iOS手机设备来说, 这点JSON以及解密的性能并不能影响整个App的运行, 因此采用这种方式进行暴力解决。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;&lt;p&gt;页面轮转在小型的App并不需要针对单独进行优化设计, 但是对于上20w行代码的大型App来说, 往往都是需要针对优化的。&lt;/p&gt;
&lt;p&gt;本文引用了市面上最通用的URLScheme的解决方案来进行页面跳转的设计优化, 并建议采用开源库&lt;a href=&quot;https://github.com/clayallsopp/routable-ios&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Routable&lt;/a&gt;来进行统一管理。&lt;/p&gt;
&lt;p&gt;根据个人在界面跳转开发中遇到的困难, 提出了几个相应的瓶颈和对应的解决方案。针对传递对象值提出了一种暴力但是耦合度比较低的解决方案。&lt;/p&gt;
&lt;p&gt;PS: 本人水平有限, 有错误的地方还望大家及时指出~ 谢谢!&lt;/p&gt;
&lt;h4 id=&quot;参考文献&quot;&gt;参考文献&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UIViewController_Class/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Apple官方文档 - UIViewController&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UINavigationController_Class/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Apple官方文档 - UINavigationController&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.apple.com/library/ios/featuredarticles/iPhoneURLScheme_Reference/Introduction/Introduction.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Apple官方文档 - URLScheme&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.apple.com/library/prerelease/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Chapters/Introduction.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Apple官方文档 - APNs&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;App应用程序开发, 界面跳转是基础中的基础, 几乎没有一个App是用不到界面跳转的, 那么怎么样去书写界面跳转代码才是比较合理的呢?&lt;/p&gt;
&lt;p&gt;大家可能在想跳转无非就2种方式, 能有什么内容? 其实并不是这样子的, 对于研发老手来说, 大型应用几乎都是利用URLSch
    
    </summary>
    
    
      <category term="iOS" scheme="http://startry.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>2015年&amp;羊年总结</title>
    <link href="http://startry.com/2016/02/05/2015_conclusion/"/>
    <id>http://startry.com/2016/02/05/2015_conclusion/</id>
    <published>2016-02-05T06:24:07.000Z</published>
    <updated>2016-02-05T06:25:17.000Z</updated>
    
    <content type="html">&lt;p&gt;既然决定要长期坚持写博客, 那么产出水帖也是必然的了~ 本文是个人今年的总结, 并没有啥技术含量哈~ 整年总结是以下四个字:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;知足常乐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在某种程度上也算是自我安慰, 因为今年并没有实现重大的自我突破~ 在工作、家庭都没有取得什么实质性的进展, 但是也并没有过的不好~ &lt;/p&gt;
&lt;h4 id=&quot;工作&quot;&gt;工作&lt;/h4&gt;&lt;p&gt;2015年更换了一份工作, 心有不舍的离开了一起成长的&lt;a href=&quot;http://d.souche.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;车牛&lt;/a&gt;, 加入了滴滴快的代驾团队, 成为了滴滴大家庭的一只小桔子。。。&lt;/p&gt;
&lt;p&gt;在快速的体验了一次从0到1的过程之后, 收获了很多成长(包括但是不限于技术), 但是在经济和家庭上却陷入了困境, 让我自己重新思考自己当前的阶段。在仔细斟酌和思考后定下来了一个大致的目标, 放弃了所有创业公司的机会, 目标加入一个相对稳定高速成长的公司。&lt;/p&gt;
&lt;p&gt;今年的工作目标就是深耕, 磨练心智优先于拓展技能。在重新出发寻找工作的时候就给自己制定了目标: &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;无论在公司的发展前景如何, 至少在公司深耕两年以上 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2015年在工作上并没有取得实质性的突破, 并没有达到自己心里的预期, 但是欲速则不达, 需要慢慢积累~ &lt;/p&gt;
&lt;p&gt;做好自己是最优的~ ^_^ 知足常乐但是还是要不忘自我突破~&lt;/p&gt;
&lt;h4 id=&quot;家庭&quot;&gt;家庭&lt;/h4&gt;&lt;p&gt;2015年对于我个人算是收获家庭的一年~ 但是我说没有实质性的进展, 是因为暂时还没有让老婆有个安定的家, 也暂时没法给予她一个再普通不过的婚礼~&lt;/p&gt;
&lt;p&gt;2015年3月家里多了一个成员, 帅气的阿拉斯加犬&lt;strong&gt;“加多宝”&lt;/strong&gt;。做研发职位的工程师陪伴家人的时间没法和朝9晚5的工作一样那么多, 老婆大人就买了一个大狗狗陪她, 本人家庭地位直线下降塞~ 其实加多宝刚来的时候萌萌嗒~ &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://blog.startry.com/img/blog_jiaduobao.png&quot; alt=&quot;预编译Setting示例&quot;&gt;&lt;/p&gt;
&lt;p&gt;2015年9月正式和老婆领了证, 但是因为种种原因还没有正式的对外进行一次酒宴, 这也是未来2年内的努力目标~ 家庭方面看上去过的非常圆满, 实际上让老婆背负了很多很多~ 知足常乐但是不能让老婆一直背负压力, 所以需要更加努力~&lt;/p&gt;
&lt;p&gt;2015年还有一颗未来的种子在不断的孕育长大~ 是今年最大的收获之一~ 也是人生最大的转折之一&lt;/p&gt;
&lt;h4 id=&quot;技术&quot;&gt;技术&lt;/h4&gt;&lt;p&gt;2015年是本人的一个技术深入的瓶颈年, 在这一整年并没有在iOS领域深入突破, 基本还是保持在原有的水平的基础上进行了一些细节的补充~ &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;技术上开始写博客进行记录和还原, 但是因为刚开始写, 写的也不是很好。&lt;/li&gt;
&lt;li&gt;接触了上亿用户用户的App, 参与协同开发也是一种成长&lt;/li&gt;
&lt;li&gt;尝试在&lt;a href=&quot;stackoverflow.com/users/5238614/startry&quot;&gt;Stackoverflow&lt;/a&gt;回答一些iOS技术问题, 扩散影响力, 因为回复的不多, 效果也不佳&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;遗憾的是整年并没有产出什么开源库, 也并没有什么开源库的维护~ 这块短板需要突破改进~&lt;/p&gt;
&lt;h4 id=&quot;2016&quot;&gt;2016&lt;/h4&gt;&lt;p&gt;年终总结已完毕, 展望一下未来吧~ 2016年努力能够更加的突破自己~ 无论技术、家庭还是工作; 技术需要成长和寻找深入点, 工作需要更加挑战自己, 家庭希望自己能够多帮老婆减少点负担~ 关键还是要坚持, 无论做什么事情, 坚持做重要! 另外还要一直保持一颗”知足常乐”的心态~&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;既然决定要长期坚持写博客, 那么产出水帖也是必然的了~ 本文是个人今年的总结, 并没有啥技术含量哈~ 整年总结是以下四个字:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;知足常乐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在某种程度上也算是自我安慰, 因为今年并没有实现重大的自
    
    </summary>
    
    
      <category term="随笔" scheme="http://startry.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Pods依赖库快速开发入门</title>
    <link href="http://startry.com/2015/12/22/pod-repo-dev-quick-start/"/>
    <id>http://startry.com/2015/12/22/pod-repo-dev-quick-start/</id>
    <published>2015-12-22T11:27:51.000Z</published>
    <updated>2015-12-22T11:27:51.000Z</updated>
    
    <content type="html">&lt;p&gt;CocoaPods是所有iOS开发熟知的一个第三方类库依赖管理工具。只要稍微有些经验的iOS开发者都会使用三方依赖库管理工具来管理工程依赖, CocoaPods是目前最火热权威的管理工具。&lt;/p&gt;
&lt;p&gt;CocoaPods的基本使用现在网站上遍历都是的教程, 官方文档的简明教程也足够清晰明朗。本篇文章主要告诉大家&lt;strong&gt;如何去开发一个CocoaPods依赖库&lt;/strong&gt;, 重点内容分三块:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如何创建一个Pod Repo&lt;/li&gt;
&lt;li&gt;如何将库提交到中央Spec库或私有Spec库中供大家使用&lt;/li&gt;
&lt;li&gt;如何在开发中添加resource、framework以及其它依赖&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;创建一个Pod_Repo&quot;&gt;创建一个Pod Repo&lt;/h3&gt;&lt;h4 id=&quot;通过模板创建&quot;&gt;通过模板创建&lt;/h4&gt;&lt;p&gt;关于如何创建一个Pod Repo, &lt;a href=&quot;http://weibo.com/wtlucky&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@wtlucky_星魂丨飘渺灬&lt;/a&gt;的一篇博文&lt;a href=&quot;http://blog.wtlucky.com/blog/2015/02/26/create-private-podspec/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;使用Cocoapods创建私有podspec&lt;/a&gt;里有介绍如何使用&lt;code&gt;pod lib create (libName)&lt;/code&gt;去创建一个Pod Repo。简单示例如下:&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;pod lib create STDemoKit&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;执行如上命令, 根据lib需要选择对应的语言(Objc/Swift)、是否需要生产示例项目以及是否需要基础测试target等选项, 就会生产一个默认的名叫&lt;code&gt;STDemoKit&lt;/code&gt;的Pod库。&lt;/p&gt;
&lt;p&gt;就这么一行命令, 自己动手敲一把, 绝对印象会加深很多的~&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;手动创建&quot;&gt;手动创建&lt;/h4&gt;&lt;p&gt;CocoaPods会利用自带的模板去创建, 非常简单方便使用, 本文就不再赘述, 只是描述下如何手动去创建一个Pod Repo。&lt;/p&gt;
&lt;p&gt;手动创建CocoaPods库的关键在于描述文件&lt;strong&gt;podspec&lt;/strong&gt;, 手动创建私有库的第一步就是复制或新建一个podspec。(podspec格式描述固定, 直接从&lt;a href=&quot;https://guides.cocoapods.org/making/specs-and-specs-repo.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方网站&lt;/a&gt;复制来的快)&lt;/p&gt;
&lt;p&gt;手动创建私有库的关键两行代码在于:&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;constant&quot;&gt;Pod::Spec&lt;/span&gt;.new &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; |spec|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  spec.name          = &lt;span class=&quot;string&quot;&gt;&#39;STDemoKit&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  spec.source_files  = &lt;span class=&quot;string&quot;&gt;&#39;MyLib/Classes/**/*.&amp;#123;h,m,c&amp;#125;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;## 补充必要的一些描述, 用于通过lint校验&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在podspec所在文件夹下创建一个名为&lt;strong&gt;MyLib&lt;/strong&gt;的文件夹, 并在&lt;strong&gt;MyLib&lt;/strong&gt;文件夹下创建一个名为&lt;strong&gt;Classes*&lt;/strong&gt;的文件夹, 放置自己实现的示例代码在该文件夹下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://blog.startry.com/img/blog_create_pod_simple_demo.png&quot; alt=&quot;自己动手创建podspec示例&quot;&gt;&lt;/p&gt;
&lt;p&gt;通过上述的步骤, 已经创建了自己的pod库, 然后需要的是本地测试, 测试自己的创建的本地库需要再创建一个Example工程, 同时在Podfile中指定本地库所在位置, 示例如下:&lt;/p&gt;
&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;pod &lt;span class=&quot;string&quot;&gt;&quot;STDemoKit&quot;&lt;/span&gt;, :path =&amp;gt; &lt;span class=&quot;string&quot;&gt;&quot;~/目标库地址&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在Podfile中指定本地的库地址后, 执行下&lt;code&gt;pod install&lt;/code&gt;即可测试自己创建的库了。&lt;/p&gt;
&lt;h3 id=&quot;如何提交库到Spec&quot;&gt;如何提交库到Spec&lt;/h3&gt;&lt;p&gt;在告诉读者怎么提交库到Spec的时候, 需要问大家一个问题: &lt;strong&gt;什么是Spec?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我引用和翻译一下&lt;a href=&quot;https://guides.cocoapods.org/making/specs-and-specs-repo.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方文档的描述&lt;/a&gt;: &lt;/p&gt;
&lt;p&gt;PodSpec(Spec)是一个用来描述一个固定版本的Pod库的文件, 根据版本推移, 一个库会有多个PodSpec(Spec)文件去描述它。该描文件描述了该版本库的引用地址、需要引用的文件、应用编译配置项以及类似库名字、库版本和描述相关的其它元数据。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A Podspec, or Spec, describes a version of a Pod library. One Pod, over the course of time, will have many Specs. It includes details about where the source should be fetched from, what files to use, the build settings to apply, and other general metadata such as its name, version, and description.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;利用CocoaPods模板创建的库的podspec描述文件如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://blog.startry.com/img/blog_podspec_demo.png&quot; alt=&quot;PodSepc文件示例&quot;&gt;&lt;/p&gt;
&lt;p&gt;回归主题: &lt;strong&gt;怎么提交Spec&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.wtlucky.com/blog/2015/02/26/create-private-podspec/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;使用Cocoapods创建私有podspec&lt;/a&gt;中有一个章节&lt;strong&gt;《向Spec Repo提交podspec》&lt;/strong&gt;, 该章节有&lt;font color=&quot;red&quot;&gt;详细&lt;/font&gt;的说明介绍如果向Pod库提交podspec, 本文只是列出两个命令, 方便大家快速查阅, 分别是&lt;strong&gt;提交podspec&lt;/strong&gt;和&lt;strong&gt;验证podspec有效性&lt;/strong&gt;的命令。&lt;/p&gt;
&lt;p&gt;一般情况下, 都需要先执行下有效性验证才会去向Spec库提交自己的podspec, 这个是开发者的基本素质吧~&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;验证podspec有效性命令&lt;/strong&gt;:&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 需要在podspec文件所在目录下执行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pod lib lint&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;提交podspec命令&lt;/strong&gt;:&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;pod repo push 索引库名 STDebugConsole.podspec&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;补充&lt;/strong&gt;:&lt;br&gt;关于索引库, 有区分官方库和非官方库。一般大公司都会维护一个&lt;strong&gt;官方索引库&lt;/strong&gt;和&lt;strong&gt;自有索引库&lt;/strong&gt;。&lt;strong&gt;官方索引库&lt;/strong&gt;一般是&lt;a href=&quot;https://github.com/CocoaPods/Specs&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;git官方库&lt;/a&gt;的一个镜像, 为了加快公司内对库索引更新的速度。&lt;strong&gt;自由索引库&lt;/strong&gt;一般维护了公司业务产品自有依赖的基础组件和业务组件。&lt;/p&gt;
&lt;h3 id=&quot;Repo添加文件依赖&quot;&gt;Repo添加文件依赖&lt;/h3&gt;&lt;p&gt;在实际工程开发过程中, 我发现很多童鞋都不了解怎么去添加资源文件到工程中, 其实我自己一开始也不太了解哈, 后面在工程应用中逐渐熟悉起来的。我结合自己的使用经验以及参考&lt;a href=&quot;https://guides.cocoapods.org/making/specs-and-specs-repo.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CocoaPods官方描述文档&lt;/a&gt;, 在这里简单描述一下。&lt;/p&gt;
&lt;p&gt;我先举几个常用的实际场景:&lt;/p&gt;
&lt;h4 id=&quot;添加framework&quot;&gt;添加framework&lt;/h4&gt;&lt;p&gt;假设我们已经通过前面说的模板去创建了一个私有库&lt;strong&gt;STShareKit&lt;/strong&gt;, 然后我需要往&lt;strong&gt;STShareKit&lt;/strong&gt;库添加分享库&lt;strong&gt;ShareSDK.framework&lt;/strong&gt;, 我是不是直接和开发普通工程一样直接往文件目录一拖就好了呢? &lt;font color=&quot;orange&quot;&gt;实践证明这种方式是不可取的&lt;/font&gt;。&lt;/p&gt;
&lt;p&gt;因为STShareKit本身是一个库, 如果直接网里面拖framework, 只会把对应的target引用写进项目的pbproj下, 只是一次性的被根项目引用, 并且不能被库本身引用, 因此通过纯粹的拖动是不可取的。(其实本人觉得如果Xcode做的智能点, 应该是可以解决这个问题的, 吐槽下)&lt;/p&gt;
&lt;p&gt;参考前面&lt;strong&gt;PodSepc文件示例&lt;/strong&gt;的podspec文件描述, 核心解决关键在于下述代码:&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;s.vendored_frameworks = [&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;string&quot;&gt;&#39;Pod/Frameworks/*.framework&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;s.frameworks = &lt;span class=&quot;string&quot;&gt;&#39;UIKit&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;Foundation&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通过在podspec中添加上述两个文件描述并执行一次&lt;code&gt;pod install&lt;/code&gt;, 一个可以解决第三方动态库, 一个可以添加本身库依赖的系统库。&lt;/p&gt;
&lt;p&gt;大家会不会好奇通过podspec描述的文件是怎么添加上去的, 是怎么被主工程和库给引用的。对Xcode环境配置熟悉的童鞋肯定能够猜到, 环境配置不是在pbproj描述下就是通过xcconfig进行注入的。如果大家对xcconfig想要进一步了解, 请大家移步我之前写的文章&lt;a href=&quot;http://blog.startry.com/2015/07/24/iOS_EnvWithXcconfig/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《iOS开发必备 - 环境变量配置(Debug &amp;amp; Release)》&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;那么我们打开STShareKit.xcconfig文件进行一探究竟。(需要在引用工程执行完&lt;code&gt;pod install&lt;/code&gt;命令才会生成)。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;FRAMEWORK_SEARCH_PATHS = $(inherited) &lt;span class=&quot;string&quot;&gt;&quot;&lt;span class=&quot;variable&quot;&gt;$&amp;#123;PODS_ROOT&amp;#125;&lt;/span&gt;/../Pod/Frameworks&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;GCC_PREPROCESSOR_DEFINITIONS = $(inherited) COCOAPODS=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;HEADER_SEARCH_PATHS = &lt;span class=&quot;string&quot;&gt;&quot;&lt;span class=&quot;variable&quot;&gt;$&amp;#123;PODS_ROOT&amp;#125;&lt;/span&gt;/Headers/Private&quot;&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;# ...此处有省略&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;第一行&lt;strong&gt;FRAMEWORK_SEARCH_PATHS&lt;/strong&gt;基本已经解除了大家的困惑了吧~&lt;/p&gt;
&lt;h4 id=&quot;添加资源文件&quot;&gt;添加资源文件&lt;/h4&gt;&lt;p&gt;添加资源文件的方式和添加第三方framework的方式相同, 核心解决关键在下述代码:&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;s.resource_bundles = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;string&quot;&gt;&#39;STShareKit&#39;&lt;/span&gt; =&amp;gt; [&lt;span class=&quot;string&quot;&gt;&#39;Pod/Assets/*.png&#39;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里有个特殊的地方, 通过上述写法书写的方式在&lt;code&gt;pod&lt;/code&gt;命令执行过程中会创建一个名为&lt;strong&gt;ONESDriver.bundle&lt;/strong&gt;的bundle来包含所有防止在物理目录&lt;code&gt;Pod/Assets&lt;/code&gt;下的资源文件。&lt;/p&gt;
&lt;p&gt;添加资源文件还有另外一种方式(&lt;strong&gt;不推荐&lt;/strong&gt;):&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;s.resources = &lt;span class=&quot;string&quot;&gt;&#39;Pod/Assets/**/*&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通过这种方式写法会被所有的资源文件不添加bundle直接copy进入主工程, 很容易发生重名冲突等问题, 不建议用这个写法~&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;补充:&lt;/strong&gt; 大家如果把上述描述文件修改和下面一样, 大家猜猜会发生什么事情呢? (库名为STShareKit)&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;s.resource_bundles = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;string&quot;&gt;&#39;STShareUI&#39;&lt;/span&gt; =&amp;gt; [&lt;span class=&quot;string&quot;&gt;&#39;Pod/Assets/*.png&#39;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;接下来抛给大家一个问题, 资源文件是怎么添加到主工程里的, 是通过xcconfig吗?&lt;br&gt;我一开始以为是通过xcconfig进行配置, 后面并没有找到对应的配置项目, 在工程下面的Build Phases, CocoaPods会默认添加一个执行脚本:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://blog.startry.com/img/blog_repo_copy_build_phases.png&quot; alt=&quot;Build Phases拷贝脚本&quot;&gt;&lt;/p&gt;
&lt;p&gt;打开Target Support Files目录下Pods文件夹下的Pods-resources.sh脚本文件, 全局搜索STShareKit.bundle, 可以发现在脚本里有如下代码:&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;install_resource &lt;span class=&quot;string&quot;&gt;&quot;$&amp;#123;BUILT_PRODUCTS_DIR&amp;#125;/STShareKit.bundle&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;看到这行代码基本已经解释了整个bundle是怎么进去到主工程里的了, 具体的细节请大家自行研究&lt;strong&gt;install_resource&lt;/strong&gt;的实现。&lt;/p&gt;
&lt;h4 id=&quot;源代码分目录(区分group)&quot;&gt;源代码分目录(区分group)&lt;/h4&gt;&lt;p&gt;做个私有库开发或者细心的童鞋会发现, 本身在开发库时候明明已经区分了物理目录的, 但是在引用工程里的Pods文件夹却是平铺展开的。对于&lt;strong&gt;处女座&lt;/strong&gt;的开发者来说, 都是一怔灾难, 平铺看上怎么都是别扭的。以知名库&lt;a href=&quot;https://github.com/icanzilb/JSONModel&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JSONModel&lt;/a&gt;为例子:&lt;/p&gt;
&lt;p&gt;开发库时候的目录分级:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://blog.startry.com/img/blog_menu_level_sub_jsonmodel.png&quot; alt=&quot;JSONModel源码中目录&quot;&gt;&lt;/p&gt;
&lt;p&gt;引用库时候的目录分级:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://blog.startry.com/img/blog_menu_level_flat_jsonmodel.png&quot; alt=&quot;JSONModel引入后目录&quot;&gt;&lt;/p&gt;
&lt;p&gt;是不是看到这个平级目录很抓狂~ &lt;a href=&quot;https://guides.cocoapods.org/making/specs-and-specs-repo.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方Guide&lt;/a&gt;来解救有代码整齐强迫症的童鞋们了, 在&lt;strong&gt;A specification with subspecs&lt;/strong&gt;章节, 有如下的一个样本podspec&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;constant&quot;&gt;Pod::Spec&lt;/span&gt;.new &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; |spec|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	spec.name          = &lt;span class=&quot;string&quot;&gt;&#39;ShareKit&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	spec.source_files  = &lt;span class=&quot;string&quot;&gt;&#39;Classes/ShareKit/&amp;#123;Configuration,Core,Customize UI,UI&amp;#125;/**/*.&amp;#123;h,m,c&amp;#125;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;# ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	spec.subspec &lt;span class=&quot;string&quot;&gt;&#39;Evernote&#39;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; |evernote|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	evernote.source_files = &lt;span class=&quot;string&quot;&gt;&#39;Classes/ShareKit/Sharers/Services/Evernote/**/*.&amp;#123;h,m&amp;#125;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;spec.subspec &lt;span class=&quot;string&quot;&gt;&#39;Facebook&#39;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; |facebook|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	facebook.source_files   = &lt;span class=&quot;string&quot;&gt;&#39;Classes/ShareKit/Sharers/Services/Facebook/**/*.&amp;#123;h,m&amp;#125;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	facebook.compiler_flags = &lt;span class=&quot;string&quot;&gt;&#39;-Wno-incomplete-implementation -Wno-missing-prototypes&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	facebook.dependency &lt;span class=&quot;string&quot;&gt;&#39;Facebook-iOS-SDK&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;呵呵, 有强迫症的童鞋是否已经找到了救星了呢? 通过描述subspec来对代码进行不同的层级区分, 这样使得引用的库能够有一定的层次感, 阅读和逻辑结构更加清晰。&lt;/p&gt;
&lt;p&gt;想要了解的更加清晰, 可以参考知名库&lt;a href=&quot;https://github.com/AFNetworking/AFNetworking&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;AFNetworking&lt;/a&gt;的&lt;a href=&quot;https://github.com/AFNetworking/AFNetworking/blob/master/AFNetworking.podspec&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;podspec&lt;/a&gt;实现以及引用时候其生产的目录结构!&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;&lt;p&gt;关于如何使用如何使用CocoaPods创建私有库, 个人感觉&lt;a href=&quot;http://blog.wtlucky.com/blog/2015/02/26/create-private-podspec/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;使用Cocoapods创建私有podspec&lt;/a&gt;已经写的非常的详细, 本篇文章的意义不大。本篇文章对于开发私有库时候的文件等资源文件添加的细节进行了一些补充, 方便大家更加快速的入门, 对于各路高手来说, 这篇文章只有带人引路的作用。&lt;/p&gt;
&lt;p&gt;PS: 水平有限, 有错误的地方请及时指出~&lt;/p&gt;
&lt;h4 id=&quot;参考文献&quot;&gt;参考文献&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.wtlucky.com/blog/2015/02/26/create-private-podspec/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;使用Cocoapods创建私有podspec&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://guides.cocoapods.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CocoaPods官方指南&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;CocoaPods是所有iOS开发熟知的一个第三方类库依赖管理工具。只要稍微有些经验的iOS开发者都会使用三方依赖库管理工具来管理工程依赖, CocoaPods是目前最火热权威的管理工具。&lt;/p&gt;
&lt;p&gt;CocoaPods的基本使用现在网站上遍历都是的教程, 官方文档的简明
    
    </summary>
    
    
      <category term="CocoaPods" scheme="http://startry.com/tags/CocoaPods/"/>
    
      <category term="framework" scheme="http://startry.com/tags/framework/"/>
    
  </entry>
  
  <entry>
    <title>搭建博客的简单自述</title>
    <link href="http://startry.com/2015/12/03/Power-source-of-writing/"/>
    <id>http://startry.com/2015/12/03/Power-source-of-writing/</id>
    <published>2015-12-03T02:40:16.000Z</published>
    <updated>2015-12-03T02:40:16.000Z</updated>
    
    <content type="html">&lt;p&gt;这篇不是技术博客哇~ 只是想记录下自己搭建博客的初衷和想法, 同时分享下过程中的平台和工具~ (典型的充数节奏)&lt;/p&gt;
&lt;p&gt;搭建博客这件事情从大学的时候就想开始做了, 但是一直拖延到毕业后1年多才开始搭建, 中间的想法变化了好几次, 想把思想变化的过程记录在本篇文章中和会访问该地址的朋友们分享下哇~&lt;/p&gt;
&lt;p&gt;搭建博客的核心观点引用&lt;a href=&quot;http://book.douban.com/subject/6021440/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《黑客与画家》&lt;/a&gt;中的一句话:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;创造优美事物的方式往往不是从头做起, 而是在现有成果的基础上做一些小小的调整, 或者将已有的观点用比较新的方式组合起来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以说, 我的博客内容80%属于重新思考总结, 20%属于偏门内容原创哈~ 在&lt;strong&gt;搭建的想法&lt;/strong&gt;中我给自己列举了5个搭建博客的理由哈~&lt;/p&gt;
&lt;font color=&quot;gray&quot;&gt;PS: 本文虽涉及平台&amp;amp;工具较多, 纯粹是笔者处于自己喜欢沿途寻找收获, 并没有任何商业相关利益驱动, 以笔者目前的影响力, 也产生不了任何利益~ &lt;/font&gt;

&lt;h3 id=&quot;搭建的想法&quot;&gt;搭建的想法&lt;/h3&gt;&lt;p&gt;最初想要搭建博客是看网上大神们都在分享自己的技术心得, 出于功利心希望自己也有一个博客能够被别人访问。但是技术水平有限, 这个想法很快就被自己拍掉了。&lt;/p&gt;
&lt;p&gt;大学的时候尝试在&lt;a href=&quot;http://www.cnblogs.com/chenxing/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;博客园&lt;/a&gt;和&lt;a href=&quot;http://blog.csdn.net/chlqk&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CSDN&lt;/a&gt;上记录一些关键字和面试题, 但是漫无目的, 自己看也觉得乏味, 每次写的技术博客都是不同领域的也没有深度, 坚持了1、2个月就果断放弃了。&lt;/p&gt;
&lt;p&gt;后来我进入了国内某互联网巨头的数字业务部, 参与写作软件的开发, 又重新让我想起了坚持写博客这件事情。这时候才开始重新思考一个问题, 我为什么要写博客?&lt;/p&gt;
&lt;p&gt;我给自己想了好几种理由, 感觉都不是很充分, 最让我自己接受的一个理由是: 记录给自己看, 用于温习技术。&lt;/p&gt;
&lt;p&gt;呵呵, 记录给自己看我干嘛要写博客, 用Snippets+Evernote不就好了。那么除了记录给自己看自然要分享给所有人, 如果要分享给所有的人, 那别人写过的博客有什么好写的呢? 基于以上思考, 目前我个人觉得我需要坚持写的博客有如下几点:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;提高自己的写作水平(语文表达太差也是硬伤)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;记录自己曾经的技术, 用于温习&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;写别人没有写过的技术或对别人的技术做总结汇总&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;梳理自己脑袋中不是那么清晰的技术点&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;希望能够稍微提高一点点影响力&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那么给自己需要坚持写博客的理由都想好了, 那么就赶紧动起来找个平台把博客环境给整好呗~&lt;/p&gt;
&lt;h3 id=&quot;寻找合适的承载&quot;&gt;寻找合适的承载&lt;/h3&gt;&lt;p&gt;我们是搞技术的人, 写博客的环境总不能太随便。环境分两个: &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;本地写作工具&lt;/li&gt;
&lt;li&gt;承载博客的平台&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;寻找本地写作工具&quot;&gt;寻找本地写作工具&lt;/h4&gt;&lt;p&gt;写作可以在线写也可以在本地写, 对于长期习惯于本地编码的工程师来说，更加喜欢在本地写完后提交到远程, 因此我就没有考虑过远程写作的工具。&lt;br&gt;本地的写作软件也各式各样, 在Mac上支持Macdown的比较优秀的有Ulysses、Mou、马克飞象和Macdown。&lt;br&gt;Ulysses是个专业的写作软件, 对于我来说感觉不够轻量级, 而且还要收费, 因此没有采用。&lt;/p&gt;
&lt;p&gt;有几个月我采用了&lt;strong&gt;Mou&lt;/strong&gt;作为本地写作工具, Mou虽然也是收费的, 但是界面直观表达, 属于我喜欢的类型的本地写作编辑器, 我有很长一段时间坚持使用Mou去书写Markdown相关内容直到它越来越卡。。一次卡甚至要一分钟。在今年中旬, 我就开始寻找Mou的替代品, 这时候才发现了一款神器&lt;strong&gt;Macdown&lt;/strong&gt;, 模仿Mou写的开源Markdown编辑工具。&lt;strong&gt;Macdown&lt;/strong&gt;有好多优点, 简洁、开源、实用是我最喜欢的三点~ 不过我觉得在其开源主页的嘲讽语句也挺有个性哈哈，引用一下~ (亮点自找…)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;MacDown is an open source Markdown editor for OS X, released under the MIT License. The author stole the idea from Chen Luo’s Mou so that people can make crappy clones.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;寻找承载博客的平台&quot;&gt;寻找承载博客的平台&lt;/h4&gt;&lt;p&gt;大部分程序员没有足够的经验, 都宁可做代码搬运工，而不做代码生产者, 我就属于那种经验不足的, 因此我更愿意做搬运工, 而且我还会优先找最现成的~ 那最现成的自然是网络现有的博客平台~&lt;/p&gt;
&lt;p&gt;大学时候尝试写博客, 要不就是&lt;a href=&quot;&quot;&gt;WordPress&lt;/a&gt;, 要不就使用博客平台, 比如&lt;a href=&quot;&quot;&gt;CSDN&lt;/a&gt;或者&lt;a href=&quot;&quot;&gt;博客园&lt;/a&gt;。但是这些平台的排版都很一般, 并且对Markdown支持不是很好, 虽然你可以直接复制粘贴HTML进去, 但还是很麻烦。除了对Markdown的支持不好外, 这些博客平台的可定制性以及界面美观度都相当的落后, 自然就不在考虑范围内了。&lt;/p&gt;
&lt;p&gt;一定要找一个靠谱的线上在线写作的平台的话, 我会考虑&lt;a href=&quot;http://jianshu.io&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;简书&lt;/a&gt;, 因为它的板面风格十分的简洁实用, 同时对Markdown的支持也是比较不错的~ 如果不是一定要想自己搭建一个博客平台, 用&lt;strong&gt;简书&lt;/strong&gt;确实是一个不错的选择~&lt;/p&gt;
&lt;p&gt;我开始寻找博客平台的时候是2013年中旬, 这时候&lt;strong&gt;简书&lt;/strong&gt;虽然积累了不少用户, 但是我周边的人都还不了解它, 我担心&lt;strong&gt;简书&lt;/strong&gt;会在多年以后不再维护(事实证明它越来越好了), 所以并没有使用简书, 而是选择了自己搭建一个博客平台。&lt;/p&gt;
&lt;h3 id=&quot;搭建自己的半静态博客&quot;&gt;搭建自己的半静态博客&lt;/h3&gt;&lt;p&gt;既然已经决定自己搭建一个静态博客，那么就是一个选型的问题了。先列出一些备选方案:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;WordPress&lt;/li&gt;
&lt;li&gt;Ghost&lt;/li&gt;
&lt;li&gt;Octopress + Github Page&lt;/li&gt;
&lt;li&gt;Hexo   + Github Page&lt;/li&gt;
&lt;li&gt;自己从头写一个&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;WordPress&lt;/strong&gt;是我在2012年使用过一段时间的博客系统, 博客的风格均模仿&lt;a href=&quot;http://weibo.com/u/1401880315&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;左耳朵耗子&lt;/a&gt;的&lt;a href=&quot;http://coolshell.cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;酷壳&lt;/a&gt;(当时膜拜该博客, 并一直在其中学习知识)。当时博客系统里就搭载了学生时代写的两篇文章&lt;a href=&quot;http://blog.csdn.net/chlqk/article/details/7864188&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《百人戴帽子问题》&lt;/a&gt;和&lt;a href=&quot;http://blog.csdn.net/chlqk/article/details/7862482&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《JAVA反射机制 - 简单的IoC容器实现》&lt;/a&gt;, 但是却被无数的垃圾评论和爬虫攻击, 整体的体验让人不敢恭维。每次进入后台管理系统总有无数的更新提醒和上百个攻击评论, 整个后台管理系统也相当的复杂, 因此在这次重新搭建博客的备选方案中, 第一个被排除的就是&lt;strong&gt;WordPress&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;经过第一次搭建重博客的体验后, 我更倾向于搭建一个轻量级的博客, 所以我就不怎么去研究当时最火热的Ghost博客(众筹的一个典型成功案例)。轻量级的博客我更喜欢在本地书写, 在服务端显示, 博客更多的是承载一个显示的作用, 很不凑巧这个点子早有大牛已经实现, 而且在Ruby和Github社区早已火热, 那个点子的承载体就是&lt;a href=&quot;http://octopress.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Octopress&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;第一次了解到&lt;strong&gt;Octopress&lt;/strong&gt;纯属凑巧, 我只是把我想要实现的功能用关键字在搜索引擎中搜索, 看看是否有类似的工具, 然后就发现有人介绍如何使用&lt;strong&gt;Octopress+Github Page&lt;/strong&gt;搭建静态博客。我按照教程用&lt;strong&gt;Octopress&lt;/strong&gt;试验了几把。。体验果然好爽~ 本地任意的工具书写博客, 基于&lt;strong&gt;Octopress&lt;/strong&gt;的命令生成页面, 配合Git命令管理上传, 简直完美。(顺带提一下, Octopress是基于&lt;a href=&quot;http://jekyllrb.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Jekyll&lt;/a&gt;实现的)&lt;/p&gt;
&lt;p&gt;在把&lt;strong&gt;Octopress&lt;/strong&gt;当作我的理想博客工具后, 我尝试寻找着有没有更多语言版本的静态博客工具, 我发现有个基于Node.js实现的静态博客系统&lt;a href=&quot;https://hexo.io&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;。Hexo的两个特点让我更加喜欢:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;命令更加简化 - 封装层次更深, 作为工具来说, 更深层次的封装也不是坏事哇, 因为体验更加好了~&lt;/li&gt;
&lt;li&gt;基于Node.js实现 - 相对Ruby, 我更加熟悉JavaScript和Node.js, 处于本身技能熟悉度的偏好考虑&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么除非选择自己写, 否则&lt;strong&gt;Hexo&lt;/strong&gt;就是我的理想选择了, 我个人比较懒, 网络上有的东西能拿现成的就拿现成的, 自己写这个想法就被我抛弃了, 最终就选择了Hexo作为我的博客平台工具。&lt;/p&gt;
&lt;h3 id=&quot;坚持&quot;&gt;坚持&lt;/h3&gt;&lt;p&gt;好了, 博客的环境搭好了, 劝说自己的理由也想好了, 那么剩下的就是一件事情&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;font size=&quot;3px&quot;&gt;坚持! &lt;/font&gt;&lt;font size=&quot;5px&quot;&gt;坚持! &lt;/font&gt;&lt;font size=&quot;6px&quot;&gt;坚持! &lt;/font&gt;&lt;font size=&quot;8px&quot;&gt;坚持!&lt;/font&gt;

&lt;h5 id=&quot;快速链接&quot;&gt;快速链接&lt;/h5&gt;&lt;p&gt;这里提供本篇文章提到的平台以及工具给大家快速访问:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;平台: &lt;a href=&quot;http://jianshu.io&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;简书&lt;/a&gt;、&lt;a href=&quot;https://wordpress.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;WordPress&lt;/a&gt;、&lt;a href=&quot;http://blog.csdn.net/chlqk&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CSDN&lt;/a&gt;、&lt;a href=&quot;http://www.cnblogs.com/chenxing/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;博客园&lt;/a&gt;、&lt;a href=&quot;https://pages.github.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Github Page&lt;/a&gt;、&lt;a href=&quot;http://coolshell.cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;酷壳&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;工具: &lt;a href=&quot;http://blog.ghost.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Ghost&lt;/a&gt;、&lt;a href=&quot;http://macdown.uranusjr.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Macdown&lt;/a&gt;、&lt;a href=&quot;http://www.sublimetext.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Sublime&lt;/a&gt;、&lt;a href=&quot;http://octopress.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Octopress&lt;/a&gt;、&lt;a href=&quot;http://jekyllrb.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Jekyll&lt;/a&gt;、&lt;a href=&quot;https://hexo.io&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;、&lt;a href=&quot;http://www.maxiang.io&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;马克飞象&lt;/a&gt;、&lt;a href=&quot;http://mouapp.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Mou&lt;/a&gt;、&lt;a href=&quot;http://www.ulyssesapp.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Ulysses&lt;/a&gt;、&lt;a href=&quot;http://www.iwriter.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;iWriter&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这篇不是技术博客哇~ 只是想记录下自己搭建博客的初衷和想法, 同时分享下过程中的平台和工具~ (典型的充数节奏)&lt;/p&gt;
&lt;p&gt;搭建博客这件事情从大学的时候就想开始做了, 但是一直拖延到毕业后1年多才开始搭建, 中间的想法变化了好几次, 想把思想变化的过程记录在本篇文章中和
    
    </summary>
    
    
      <category term="随笔" scheme="http://startry.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Podfile.lock背后的那点事</title>
    <link href="http://startry.com/2015/10/28/Somthing-about-Podfile-lock/"/>
    <id>http://startry.com/2015/10/28/Somthing-about-Podfile-lock/</id>
    <published>2015-10-28T07:09:00.000Z</published>
    <updated>2015-10-28T07:09:00.000Z</updated>
    
    <content type="html">&lt;p&gt;大部分的iOS开发者应该都曾使用过CocoaPods去管理工程的依赖, 但是你们有没有留意一个小小的文件&lt;strong&gt;Podfile.lock&lt;/strong&gt;呢?&lt;/p&gt;
&lt;p&gt;通常我们需要使用CocoaPods去管理依赖, 都会执行一次&lt;code&gt;pod install&lt;/code&gt;。 在&lt;code&gt;install&lt;/code&gt;命令的执行过程中会改变被执行Project的配置项, 同时也会生产一个Podfile.lock文件。&lt;/p&gt;
&lt;p&gt;那么, 这个Podfile.lock的作用究竟就是干嘛的呢?&lt;/p&gt;
&lt;h2 id=&quot;初步窥探&quot;&gt;初步窥探&lt;/h2&gt;&lt;p&gt;两个问题:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;什么是Podfile.lock呢? &lt;/li&gt;
&lt;li&gt;&lt;code&gt;pod install&lt;/code&gt;和&lt;code&gt;pod update&lt;/code&gt;在工作的时候又分别对Podfile.lock文件做了什么事情呢?&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;Podfile-lock的作用&quot;&gt;Podfile.lock的作用&lt;/h4&gt;&lt;p&gt;熟悉CocoaPods的开发者都知道Podfile.lock是用来团队协作的, 防止库更新影响到其他协同开发的人。&lt;a href=&quot;http://guides.cocoapods.org/using/using-cocoapods.html#what-is-podfilelock&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方文档&lt;/a&gt;描述该文件是用来追踪每一个生成Pod的版本的。原文如下:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This file is generated after the first run of &lt;font color=&quot;red&quot;&gt; pod install&lt;/font&gt;, and tracks the version of each Pod that was installed. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其实在&lt;a href=&quot;http://weibo.com/tangqiaoboy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@唐巧大神&lt;/a&gt;博客&lt;a href=&quot;http://www.devtang.com/blog/2014/05/25/use-cocoapod-to-manage-ios-lib-dependency/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《用CocoaPods做iOS程序的依赖管理》&lt;/a&gt;中有提到update和install的区别以及Podfile.lock的关系, 原文引用如下:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当你执行pod install之后，除了 Podfile 外，CocoaPods 还会生成一个名为Podfile.lock的文件，Podfile.lock 应该加入到版本控制里面，不应该把这个文件加入到.gitignore中。因为Podfile.lock会锁定当前各依赖库的版本，之后如果多次执行pod install 不会更改版本，要pod update才会改Podfile.lock了。这样多人协作的时候，可以防止第三方库升级时造成大家各自的第三方库版本不一致&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;前置实验&quot;&gt;前置实验&lt;/h4&gt;&lt;p&gt;这个已经基本总结了接下来我要做的一个实验, 但是对于很多人来说, 没有做够实验, 是无法深入去理解的, 因此我把接下来的初步窥探过程给罗列了出来:&lt;/p&gt;
&lt;p&gt;Podfile文件写入如下执行语句:&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;pod &lt;span class=&quot;string&quot;&gt;&#39;STDebugConsole&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;0.1.0&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;执行完后生成Podfile.lock文件如下:&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;constant&quot;&gt;PODS&lt;/span&gt;&lt;span class=&quot;symbol&quot;&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  - &lt;span class=&quot;constant&quot;&gt;STDebugConsole&lt;/span&gt; (&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;constant&quot;&gt;DEPENDENCIES&lt;/span&gt;&lt;span class=&quot;symbol&quot;&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  - &lt;span class=&quot;constant&quot;&gt;STDebugConsole&lt;/span&gt; (= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;constant&quot;&gt;SPEC&lt;/span&gt; &lt;span class=&quot;constant&quot;&gt;CHECKSUMS&lt;/span&gt;&lt;span class=&quot;symbol&quot;&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;constant&quot;&gt;STDebugConsole&lt;/span&gt;&lt;span class=&quot;symbol&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;57&lt;/span&gt;c3e311e788dc1cb14f0c6aea33a931c00871cb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;constant&quot;&gt;COCOAPODS&lt;/span&gt;&lt;span class=&quot;symbol&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;38.2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;修改原Podfile, 去掉后面的版本信息后重新执行&lt;code&gt;pod install&lt;/code&gt;:&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;pod &lt;span class=&quot;string&quot;&gt;&#39;STDebugConsole&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;产生的Podfile.lock如下:&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;constant&quot;&gt;PODS&lt;/span&gt;&lt;span class=&quot;symbol&quot;&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  - &lt;span class=&quot;constant&quot;&gt;STDebugConsole&lt;/span&gt; (&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;constant&quot;&gt;DEPENDENCIES&lt;/span&gt;&lt;span class=&quot;symbol&quot;&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  - &lt;span class=&quot;constant&quot;&gt;STDebugConsole&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;constant&quot;&gt;SPEC&lt;/span&gt; &lt;span class=&quot;constant&quot;&gt;CHECKSUMS&lt;/span&gt;&lt;span class=&quot;symbol&quot;&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;constant&quot;&gt;STDebugConsole&lt;/span&gt;&lt;span class=&quot;symbol&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;57&lt;/span&gt;c3e311e788dc1cb14f0c6aea33a931c00871cb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;constant&quot;&gt;COCOAPODS&lt;/span&gt;&lt;span class=&quot;symbol&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;38.2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;对比可以发现&lt;code&gt;DEPENDENCIES&lt;/code&gt;下的库没有了版本信息。&lt;/p&gt;
&lt;p&gt;PS: 前面的步骤只是铺垫, 为了防止STDebugConsole库升级到最新的版本做的&lt;font color=&quot;orange&quot;&gt;前置步骤&lt;/font&gt;。&lt;/p&gt;
&lt;h4 id=&quot;实验主体&quot;&gt;实验主体&lt;/h4&gt;&lt;p&gt;修改Podfile文件, 添加至少大于某个版本的信息:&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;pod &lt;span class=&quot;string&quot;&gt;&#39;STDebugConsole&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;~&amp;gt; 0.1.0&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;重新执行&lt;code&gt;pod install&lt;/code&gt;, 对比Podfile.lock文件如下:&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;constant&quot;&gt;PODS&lt;/span&gt;&lt;span class=&quot;symbol&quot;&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  - &lt;span class=&quot;constant&quot;&gt;STDebugConsole&lt;/span&gt; (&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;constant&quot;&gt;DEPENDENCIES&lt;/span&gt;&lt;span class=&quot;symbol&quot;&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  - &lt;span class=&quot;constant&quot;&gt;STDebugConsole&lt;/span&gt; (~&amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;constant&quot;&gt;SPEC&lt;/span&gt; &lt;span class=&quot;constant&quot;&gt;CHECKSUMS&lt;/span&gt;&lt;span class=&quot;symbol&quot;&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;constant&quot;&gt;STDebugConsole&lt;/span&gt;&lt;span class=&quot;symbol&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;57&lt;/span&gt;c3e311e788dc1cb14f0c6aea33a931c00871cb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;constant&quot;&gt;COCOAPODS&lt;/span&gt;&lt;span class=&quot;symbol&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;38.2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们可以发现基本的PODS版本信息都没有发生过变化, 只有DEPENDNCIES信息发生变化。&lt;/p&gt;
&lt;p&gt;接下来我们重新执行一次&lt;code&gt;pod install&lt;/code&gt;, 对比Podfile.lock发现并没有发生任何变化。这时候执行&lt;code&gt;pod update&lt;/code&gt;, 可以发现STDebugConsole库的版本信息发生了变化。&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;constant&quot;&gt;PODS&lt;/span&gt;&lt;span class=&quot;symbol&quot;&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  - &lt;span class=&quot;constant&quot;&gt;STDebugConsole&lt;/span&gt; (&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;1.1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;constant&quot;&gt;DEPENDENCIES&lt;/span&gt;&lt;span class=&quot;symbol&quot;&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  - &lt;span class=&quot;constant&quot;&gt;STDebugConsole&lt;/span&gt; (~&amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;constant&quot;&gt;SPEC&lt;/span&gt; &lt;span class=&quot;constant&quot;&gt;CHECKSUMS&lt;/span&gt;&lt;span class=&quot;symbol&quot;&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;constant&quot;&gt;STDebugConsole&lt;/span&gt;&lt;span class=&quot;symbol&quot;&gt;:&lt;/span&gt; f07227199c0f906953e84f1d12e1fec4a9fc60d7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;constant&quot;&gt;COCOAPODS&lt;/span&gt;&lt;span class=&quot;symbol&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;38.2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通过上述几个实验, 可以得出:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;pod install只会将Podfile的信息写入到Podfile.lock, 但是不修改Pods已安装的依赖库的版本信息。pod update不但会将Podfile的信息写入到Podfile.lock文件中, 还会更新Pods已安装的依赖库的版本信息。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;深入窥探&quot;&gt;深入窥探&lt;/h2&gt;&lt;p&gt;Install和Update的区别大家都是知道了吧，但是它的背后究竟是怎么工作的呢? 如果大家有看过我之前写的&lt;a href=&quot;http://blog.startry.com/2015/09/29/Something-about-Pod-Install-And-Pod-Update/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《pod install和pod update背后那点事》&lt;/a&gt;或者自己去研究过CocoaPods的&lt;a href=&quot;https://github.com/CocoaPods/CocoaPods&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;源码&lt;/a&gt;, 就会发现在Pods源码下&lt;code&gt;pod installl&lt;/code&gt;和&lt;code&gt;pod update&lt;/code&gt;两个命令均在&lt;a href=&quot;https://github.com/CocoaPods/CocoaPods/blob/0.39.0.beta.4/lib/cocoapods/command/project.rb&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;project.rb&lt;/a&gt;有所体现。&lt;/p&gt;
&lt;p&gt;在project.rb中有两个继承Command的类, 分别叫做Update和Install, 用于分别执行&lt;code&gt;pod install&lt;/code&gt;命令和&lt;code&gt;pod update&lt;/code&gt;命令。Command类核心的执行方法是一个叫做&lt;code&gt;run&lt;/code&gt;的方法, 在Update和Install类的run方法中均有调用到一个叫&lt;code&gt;run_install_with_update(update)&lt;/code&gt;的方法。那么我们是否可以猜测, 在该方法中传递的布尔值正是决定Podfile.lock不同的地方之处呢?&lt;/p&gt;
&lt;p&gt;呵呵, 核心的问题来了:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;run_install_with_update&lt;/code&gt;方法的参数是怎么和Podfile.lock进行交互操作?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;想要知道答案? ╮(╯▽╰)╭ 没有什么好办法, 要不搜人家总结, 要么就只能去跟CocoaPods的源码了。&lt;/p&gt;
&lt;p&gt;PS: 本文的源码依旧基于&lt;a href=&quot;https://github.com/CocoaPods/CocoaPods/tree/0.39.0.beta.4&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CocoaPods Tag 0.39.0.beta.4&lt;/a&gt;哦~~&lt;/p&gt;
&lt;p&gt;跟踪Installer的update属性, 我们可以发现最终被传入了Analyzer类的update属性, 并通过一个&lt;a href=&quot;https://github.com/CocoaPods/CocoaPods/blob/0.39.0.beta.4/lib/cocoapods/installer/analyzer.rb&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;方法&lt;/a&gt;重新定义返回了一个Ruby的&lt;a href=&quot;http://www.ibm.com/developerworks/cn/opensource/os-cn-rubysbl/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Symbol&lt;/a&gt;类&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;update_mode&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; !update&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;symbol&quot;&gt;:none&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;elsif&lt;/span&gt; update == &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;symbol&quot;&gt;:all&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;elsif&lt;/span&gt; !update[&lt;span class=&quot;symbol&quot;&gt;:pods&lt;/span&gt;].&lt;span class=&quot;keyword&quot;&gt;nil&lt;/span&gt;?&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;symbol&quot;&gt;:selected&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;从上述代码, 我们可以看出, 如果执行Cocoapods的话, 会返回值为&lt;code&gt;:all&lt;/code&gt;的Symbol, 因此我们使用&lt;code&gt;update_mode == :all&lt;/code&gt;去搜索Analyzer这个类, 会发现在以下三个方法中被调用到:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;generate_version_locking_dependencies&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pods_to_fetch&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dependencies_to_fetch&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体问题具体分析, 三个方法逐个击破:&lt;/p&gt;
&lt;h4 id=&quot;调用时机&quot;&gt;调用时机&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pods_to_fetch&lt;/code&gt;在&lt;code&gt;dependencies_to_fetch&lt;/code&gt;和&lt;code&gt;fetch_external_sources&lt;/code&gt;方法中均有被调用, &lt;/li&gt;
&lt;li&gt;&lt;code&gt;dependencies_to_fetch&lt;/code&gt;本身又只在&lt;code&gt;fetch_external_sources&lt;/code&gt;方法中被调用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fetch_external_sources&lt;/code&gt;和&lt;code&gt;generate_version_locking_dependencies&lt;/code&gt;属于平行方法, 均在Analyzer类的核心方法analyze中被调用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Analyzer类的核心方法&lt;a href=&quot;https://github.com/CocoaPods/CocoaPods/blob/0.39.0.beta.4/lib/cocoapods/installer/analyzer.rb&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;analyze&lt;/a&gt;:&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;analyze&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(allow_fetches = &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	validate_podfile!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	validate_lockfile_version!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;variable&quot;&gt;@result&lt;/span&gt; = &lt;span class=&quot;constant&quot;&gt;AnalysisResult&lt;/span&gt;.new&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; config.integrate_targets?&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;variable&quot;&gt;@result&lt;/span&gt;.target_inspections = inspect_targets_to_integrate&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		verify_platforms_specified!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;variable&quot;&gt;@result&lt;/span&gt;.podfile_state = generate_podfile_state&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;variable&quot;&gt;@locked_dependencies&lt;/span&gt;  = generate_version_locking_dependencies&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	store_existing_checkout_options&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	fetch_external_sources &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; allow_fetches&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;variable&quot;&gt;@result&lt;/span&gt;.specs_by_target = validate_platforms(resolve_dependencies)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;variable&quot;&gt;@result&lt;/span&gt;.specifications  = generate_specifications&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;variable&quot;&gt;@result&lt;/span&gt;.targets         = generate_targets&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;variable&quot;&gt;@result&lt;/span&gt;.sandbox_state   = generate_sandbox_state&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;variable&quot;&gt;@result&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Analyzer类的核心方法是在&lt;code&gt;resolve_dependencies&lt;/code&gt;方法中被调用的, 该方法在我之前的文章&lt;a href=&quot;http://blog.startry.com/2015/09/29/Something-about-Pod-Install-And-Pod-Update/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《pod install和pod update背后那点事》&lt;/a&gt;中有提到, 属于&lt;code&gt;pod install&lt;/code&gt;背后执行的十大方法中的第二个方法, 在终端执行输出&lt;code&gt;Analyzing dependencies&lt;/code&gt;的时候被调用执行。&lt;/p&gt;
&lt;h4 id=&quot;依赖Lock管理&quot;&gt;依赖Lock管理&lt;/h4&gt;&lt;p&gt;&lt;code&gt;generate_version_locking_dependencies&lt;/code&gt;&lt;a href=&quot;https://github.com/CocoaPods/CocoaPods/blob/0.39.0.beta.4/lib/cocoapods/installer/analyzer.rb#L400&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;源码&lt;/a&gt;:&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;generate_version_locking_dependencies&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; update_mode == &lt;span class=&quot;symbol&quot;&gt;:all&lt;/span&gt; || !lockfile&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;constant&quot;&gt;LockingDependencyAnalyzer&lt;/span&gt;.unlocked_dependency_graph&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		pods_to_update = result.podfile_state.changed + result.podfile_state.deleted&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		pods_to_update += update[&lt;span class=&quot;symbol&quot;&gt;:pods&lt;/span&gt;] &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; update_mode == &lt;span class=&quot;symbol&quot;&gt;:selected&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		pods_to_update += podfile.dependencies.select(&amp;amp;&lt;span class=&quot;symbol&quot;&gt;:local?&lt;/span&gt;).map(&amp;amp;&lt;span class=&quot;symbol&quot;&gt;:name&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;constant&quot;&gt;LockingDependencyAnalyzer&lt;/span&gt;.generate_version_locking_dependencies(lockfile, pods_to_update)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;unlocked_dependency_graph&lt;/code&gt;&lt;a href=&quot;https://github.com/CocoaPods/CocoaPods/blob/0.39.0.beta.4/lib/cocoapods/installer/analyzer/locking_dependency_analyzer.rb&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;源码&lt;/a&gt;:&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;self&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;unlocked_dependency_graph&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;constant&quot;&gt;Molinillo::DependencyGraph&lt;/span&gt;.new&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;generate_version_locking_dependencies&lt;/code&gt;&lt;a href=&quot;https://github.com/CocoaPods/CocoaPods/blob/0.39.0.beta.4/lib/cocoapods/installer/analyzer/locking_dependency_analyzer.rb#L20&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;源码&lt;/a&gt;:&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;self&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;generate_version_locking_dependencies&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(lockfile, pods_to_update)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	dependency_graph = &lt;span class=&quot;constant&quot;&gt;Molinillo::DependencyGraph&lt;/span&gt;.new&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; lockfile&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		explicit_dependencies = lockfile.to_hash[&lt;span class=&quot;string&quot;&gt;&#39;DEPENDENCIES&#39;&lt;/span&gt;] || []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		explicit_dependencies.each &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; |string|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			dependency = &lt;span class=&quot;constant&quot;&gt;Dependency&lt;/span&gt;.new(string)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			dependency_graph.add_root_vertex(dependency.name, &lt;span class=&quot;keyword&quot;&gt;nil&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		pods = lockfile.to_hash[&lt;span class=&quot;string&quot;&gt;&#39;PODS&#39;&lt;/span&gt;] || []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		pods.each &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; |pod|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			add_to_dependency_graph(pod, [], dependency_graph)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		pods_to_update = pods_to_update.flat_map &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; |u|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			root_name = &lt;span class=&quot;constant&quot;&gt;Specification&lt;/span&gt;.root_name(u).downcase&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			dependency_graph.vertices.keys.select &amp;#123; |n| &lt;span class=&quot;constant&quot;&gt;Specification&lt;/span&gt;.root_name(n).downcase == root_name &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		pods_to_update.each &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; |u|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			dependency_graph.detach_vertex_named(u)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	dependency_graph&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通过上述源码, 可以看出update和install的区别分在&lt;a href=&quot;https://github.com/CocoaPods/CocoaPods/blob/0.39.0.beta.4/lib/cocoapods/installer/analyzer/locking_dependency_analyzer.rb&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;LockingDependencyAnalyzer&lt;/a&gt;类的&lt;a href=&quot;https://github.com/CocoaPods/CocoaPods/blob/0.39.0.beta.4/lib/cocoapods/installer/analyzer/locking_dependency_analyzer.rb#L53&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;unlocked_dependency_graph&lt;/code&gt;&lt;/a&gt;和&lt;a href=&quot;https://github.com/CocoaPods/CocoaPods/blob/0.39.0.beta.4/lib/cocoapods/installer/analyzer/locking_dependency_analyzer.rb#L20&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;generate_version_locking_dependencies&lt;/code&gt;&lt;/a&gt;方法中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果执行update操作, 执行&lt;code&gt;unlocked_dependency_graph&lt;/code&gt;方法, 会返回一个全新的&lt;a href=&quot;https://github.com/CocoaPods/Molinillo/blob/0.3.1/lib/molinillo/dependency_graph.rb&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Molinillo::DependencyGraph&lt;/a&gt;对象; &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果执行install操作, 会执行下列操作:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;生成一个全新的Molinillo::DependencyGraph的对象&lt;/li&gt;
&lt;li&gt;根据Podfile.lock加载所有需要Lock的依赖&lt;/li&gt;
&lt;li&gt;根据外部预先处理的&lt;code&gt;pods_to_update&lt;/code&gt;参数剔除需要更新的依赖&lt;/li&gt;
&lt;li&gt;返回最终剔除的需要更新后的所有需要锁定的依赖&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;PS: 此处的&lt;a href=&quot;https://github.com/CocoaPods/Molinillo/tree/0.3.1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Molinillo&lt;/a&gt;是CocoaPods的另外一个子项目, 专门用于处理CocoaPods的依赖关系, 引用官方介绍如下:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A generic dependency-resolution implementation.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;检测依赖改动&quot;&gt;检测依赖改动&lt;/h4&gt;&lt;p&gt;从依赖Lock管理章节可以看出, 在已有Podfile的前提下, 是需要根据&lt;code&gt;pods_to_updte&lt;/code&gt;这个参数来进行控制调整。结合&lt;code&gt;generate_version_locking_dependencies&lt;/code&gt;的源码分析, 咱们可以看出满足需要更新的条件是以下任一一个:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Podfile的状态是&lt;font color=&quot;orange&quot;&gt;changed&lt;/font&gt;和&lt;font color=&quot;orange&quot;&gt;deleted&lt;/font&gt;的依赖&lt;/li&gt;
&lt;li&gt;被预先标记需要需要的库(update参数属于数组的情况下)&lt;/li&gt;
&lt;li&gt;在Podfile中被指定&lt;code&gt;:local&lt;/code&gt;参数的库&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第一条和第三条都比较好理解, 但是第二条update参数属于数组的情况下, 怎么理解呢?&lt;/p&gt;
&lt;p&gt;首先, 这个update是个什么鬼? update是在外部方法&lt;code&gt;run_install_with_update&lt;/code&gt;中传入的参数, 该参数可能是个数组, 可能是个BOOL值, 在这里我们回归以下Update这个Command的类的&lt;a href=&quot;https://github.com/CocoaPods/CocoaPods/blob/0.39.0.beta.4/lib/cocoapods/command/project.rb#L107&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;实现&lt;/a&gt;:&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Update&lt;/span&gt; &lt;span class=&quot;inheritance&quot;&gt;&amp;lt; &lt;span class=&quot;parent&quot;&gt;Command&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# ... 省略&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;initialize&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(argv)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;variable&quot;&gt;@pods&lt;/span&gt; = argv.arguments! &lt;span class=&quot;keyword&quot;&gt;unless&lt;/span&gt; argv.arguments.empty?&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		verify_podfile_exists!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;@pods&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          verify_lockfile_exists!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;comment&quot;&gt;#... 省略&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          run_install_with_update(&lt;span class=&quot;symbol&quot;&gt;:pods&lt;/span&gt; =&amp;gt; &lt;span class=&quot;variable&quot;&gt;@pods&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;constant&quot;&gt;UI&lt;/span&gt;.puts &lt;span class=&quot;string&quot;&gt;&#39;Update all pods&#39;&lt;/span&gt;.yellow &lt;span class=&quot;keyword&quot;&gt;unless&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;@pods&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          run_install_with_update(&lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#... 省略&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;从上述Update类的实现可以看出&lt;code&gt;:pods&lt;/code&gt;这个属性是根据命令行参数读取的, 呵呵, 熟悉&lt;code&gt;pod update&lt;/code&gt;命令的程序猿们是否已经猜出了大概, 不多说, 敲入以下命令看结果:&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;pod update --help&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;http://blog.startry.com/img/blog_pod_update_help.png&quot; alt=&quot;pod update help&quot;&gt;&lt;/p&gt;
&lt;p&gt;原来update数组里面存的是命令行显示指定的库的集合。&lt;/p&gt;
&lt;p&gt;那么到目前为止问题都解决了么, 没有! 会触发更新的三个任意条件的第一条, Podfile的state又是怎么计算出来的呢? changed和deleted是依据什么去标记的呢?&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;run_install_with_update&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(update)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	installer = &lt;span class=&quot;constant&quot;&gt;Installer&lt;/span&gt;.new(config.sandbox, config.podfile, config.lockfile)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	installer.update = update&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	installer.install!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通过&lt;code&gt;run_install_with_update&lt;/code&gt;的&lt;a href=&quot;https://github.com/CocoaPods/CocoaPods/blob/0.39.0.beta.4/lib/cocoapods/command/project.rb#L68&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;实现&lt;/a&gt;, 我们可以看出来大部分的文件都是config里预先记载的。而在&lt;a href=&quot;https://github.com/CocoaPods/CocoaPods/blob/0.39.0.beta.4/lib/cocoapods/config.rb&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;config.rb&lt;/a&gt;的实现中有如下代码:&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;podfile&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;variable&quot;&gt;@podfile&lt;/span&gt; ||= &lt;span class=&quot;constant&quot;&gt;Podfile&lt;/span&gt;.from_file(podfile_path) &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; podfile_path&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;attr_writer&lt;/span&gt; &lt;span class=&quot;symbol&quot;&gt;:podfile&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;lockfile&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;variable&quot;&gt;@lockfile&lt;/span&gt; ||= &lt;span class=&quot;constant&quot;&gt;Lockfile&lt;/span&gt;.from_file(lockfile_path) &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; lockfile_path&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Podfile类和Lockfile的类的定义都无法在CocoaPods工程中搜索出来。笔者通过在CocoaPods依赖库的模糊搜索, 找出该两个库隐藏在CocoaPods下的&lt;a href=&quot;https://github.com/CocoaPods/Core&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Core&lt;/a&gt;依赖工程中。&lt;/p&gt;
&lt;p&gt;T_T ~ 好吧, 只能继续clone依赖工程了&lt;/p&gt;
&lt;p&gt;找到了Lockfile类和Podfile类, 下一步就是定位状态变化是在哪里的哇。在文章前半部分提到的Analyzer类的analyze方法中有个&lt;a href=&quot;https://github.com/CocoaPods/CocoaPods/blob/0.39.0.beta.4/lib/cocoapods/installer/analyzer.rb#L190&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;generate_podfile_state&lt;/code&gt;&lt;/a&gt;方法的调用。 看名字就像是生成状态的地方, 我们跟进去这个方法可以找出该方法的核心在于Lockfile类的&lt;a href=&quot;https://github.com/CocoaPods/Core/blob/0.39.0.beta.4/lib/cocoapods-core/lockfile.rb#L255&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;detect_changes_with_podfile&lt;/code&gt;&lt;/a&gt;方法。&lt;/p&gt;
&lt;p&gt;Lockfile检测状态变化核心&lt;a href=&quot;https://github.com/CocoaPods/Core/blob/0.39.0.beta.4/lib/cocoapods-core/lockfile.rb#L255&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;源码&lt;/a&gt;:&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;detect_changes_with_podfile&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(podfile)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	result = &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	[&lt;span class=&quot;symbol&quot;&gt;:added&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;:changed&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;:removed&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;:unchanged&lt;/span&gt;].each &amp;#123; |k| result[k] = [] &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	installed_deps = dependencies.map &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; |dep|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		dependencies_to_lock_pod_named(dep.root_name)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;.flatten&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	all_dep_names  = (dependencies + podfile.dependencies).map(&amp;amp;&lt;span class=&quot;symbol&quot;&gt;:name&lt;/span&gt;).uniq&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	all_dep_names.each &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; |name|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		installed_dep = installed_deps.find &amp;#123; |d| d.name == name &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		podfile_dep   = podfile.dependencies.find &amp;#123; |d| d.name == name &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; installed_dep.&lt;span class=&quot;keyword&quot;&gt;nil&lt;/span&gt;?  &lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt; key = &lt;span class=&quot;symbol&quot;&gt;:added&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;elsif&lt;/span&gt; podfile_dep.&lt;span class=&quot;keyword&quot;&gt;nil&lt;/span&gt;? &lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt; key = &lt;span class=&quot;symbol&quot;&gt;:removed&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;elsif&lt;/span&gt; podfile_dep.compatible?(installed_dep) &lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt; key = &lt;span class=&quot;symbol&quot;&gt;:unchanged&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; key = &lt;span class=&quot;symbol&quot;&gt;:changed&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		result[key] &amp;lt;&amp;lt; name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	result&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上述源码大概意思如下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;:added - Podfile中的依赖库&lt;strong&gt;名字&lt;/strong&gt;在Lockfile没有被描述记载 (仅仅对比名字)&lt;/li&gt;
&lt;li&gt;:removed - Lockfile中已记载的依赖库的&lt;strong&gt;名字&lt;/strong&gt;没有在Podfile文件中写明 (仅仅对比名字)&lt;/li&gt;
&lt;li&gt;:unchanged - 通过&lt;a href=&quot;https://github.com/CocoaPods/Core/blob/0.39.0.beta.4/lib/cocoapods-core/dependency.rb&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Dependency&lt;/a&gt;类的&lt;code&gt;compatible&lt;/code&gt;不为真的时候&lt;/li&gt;
&lt;li&gt;:changed - 不满足上述三个条件其他任意情况&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;好了, 大致的对比方法已经了解了, 就看&lt;a href=&quot;https://github.com/CocoaPods/Core/blob/0.39.0.beta.4/lib/cocoapods-core/dependency.rb#L178&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;compatible&lt;/code&gt;&lt;/a&gt;怎么理解了!&lt;/p&gt;
&lt;p&gt;Dependency 类的&lt;code&gt;compatible&lt;/code&gt;方法&lt;a href=&quot;https://github.com/CocoaPods/Core/blob/0.39.0.beta.4/lib/cocoapods-core/dependency.rb#L178&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;源码:&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;compatible?&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(other)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;unless&lt;/span&gt; name == other.name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;unless&lt;/span&gt; head? == other.head?&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;unless&lt;/span&gt; external_source == other.external_source&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	other.requirement.requirements.all? &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; |_operator, version|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		requirement.satisfied_by? &lt;span class=&quot;constant&quot;&gt;Version&lt;/span&gt;.new(version)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Requirement 类的&lt;code&gt;requirement.satisfied_by&lt;/code&gt;方法&lt;a href=&quot;https://github.com/CocoaPods/Core/blob/0.39.0.beta.4/lib/cocoapods-core/dependency.rb#L178&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;源码:&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;satisfied_by?&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;version&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	raise &lt;span class=&quot;constant&quot;&gt;ArgumentError&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Need a Gem::Version: &lt;span class=&quot;subst&quot;&gt;#&amp;#123;version.inspect&amp;#125;&lt;/span&gt;&quot;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;unless&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;constant&quot;&gt;Gem::Version&lt;/span&gt; === version&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# #28965: syck has a bug with unquoted &#39;=&#39; YAML.loading as YAML::DefaultKey&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	requirements.all? &amp;#123; |op, rv| (&lt;span class=&quot;constant&quot;&gt;OPS&lt;/span&gt;[op] || &lt;span class=&quot;constant&quot;&gt;OPS&lt;/span&gt;[&lt;span class=&quot;string&quot;&gt;&quot;=&quot;&lt;/span&gt;]).call version, rv &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;PS: &lt;a href=&quot;https://github.com/CocoaPods/Core/blob/0.39.0.beta.4/lib/cocoapods-core/vendor/requirement.rb#L18&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;OPS&lt;/a&gt;是一个预先定义的字符和字符对应的lambda操作映射的数组。&lt;/p&gt;
&lt;p&gt;通过上面的方法定义, 我们可以看出&lt;code&gt;compatible&lt;/code&gt;方法实际上是对库名字, ext标志、 head描述和版本操作符进行比较。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ext、head是啥? 哈哈, 可以自己去Podfile里面对应喔~ 也可以下载代码去查找定义哇~ (如果大家没有用过这两个东西, 建议先去熟悉使用CocoaPods工具)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;detect_changes_with_podfile&lt;/code&gt;方法已经将Pods库响应的变化均记录在内存变量中, 供后续修改Podfile.lock, 更新依赖库等各个行为使用。&lt;/p&gt;
&lt;p&gt;因为继续跟踪源码文章篇幅偏长并且可阅读性也不高, 作者就打算偷个懒, 不继续跟踪源码, 如果有需要另起文章跟踪其它部分源码。&lt;/p&gt;
&lt;p&gt;大家可以自己根据上述的思路进行更加深入的跟踪哇~&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;&lt;p&gt;CocoaPods大多数人都会用, 但是并不是每一个人都理解其每一个文件的作用, Podfile.lock就是其中一个典型的例子。一开始我也无意研究Podfile.lock文件的作用, 起因是之前换工作的时候遇到一位面试的朋友对其追问而无法精确回答。&lt;/p&gt;
&lt;p&gt;Podfile.lock文件对团队协作非常作用, 应该添加进入源码依赖。&lt;code&gt;pod install&lt;/code&gt;和&lt;code&gt;pod update&lt;/code&gt;都是基于Podfile.lock进行约束。&lt;strong&gt;install会根据一定的规则和Podfile.lock文件进行依赖库的约束下载, 同时细微更新Podfile.lock文件; update会根据另外一套规则进行约束库的下载和对Podfile.lock的写入更新。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Podfile.lock的作用很明显, 为了相互之间协作更加通畅; 但是, Podfile.lock文件背后的工作以及作用并不是一两句话能够总结的出来, 希望大家能够理解~&lt;/p&gt;
&lt;p&gt;-&lt;br&gt;另: 源码分析是具有时效性, 但是分析的方法和核心的思想不会发生太大的变化, 掌握分析的方法和理解设计的核心思想才是关键~&lt;/p&gt;
&lt;p&gt;PS: 个人水平有限, 如果发现错误之处, 请大家及时指出~~ 谢谢哈~&lt;/p&gt;
&lt;p&gt;PS: 因为本文写的特别凌乱, 如果有啥看不懂的~ 也一定要告诉我哇~~ 会持续修正文章~~&lt;/p&gt;
&lt;h4 id=&quot;参考文献&quot;&gt;参考文献&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://www.devtang.com/blog/2014/05/25/use-cocoapod-to-manage-ios-lib-dependency/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;用CocoaPods做iOS程序的依赖管理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/CocoaPods/CocoaPods/tree/0.39.0.beta.4&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CocoaPods源码库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ibm.com/developerworks/cn/opensource/os-cn-rubysbl/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;IBM developerWorks - 理解 Ruby Symbol，第 1 部分&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;大部分的iOS开发者应该都曾使用过CocoaPods去管理工程的依赖, 但是你们有没有留意一个小小的文件&lt;strong&gt;Podfile.lock&lt;/strong&gt;呢?&lt;/p&gt;
&lt;p&gt;通常我们需要使用CocoaPods去管理依赖, 都会执行一次&lt;code&gt;pod instal
    
    </summary>
    
    
      <category term="CocoaPods" scheme="http://startry.com/tags/CocoaPods/"/>
    
      <category term="Ruby" scheme="http://startry.com/tags/Ruby/"/>
    
      <category term="iOS" scheme="http://startry.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>pod install和pod update背后那点事</title>
    <link href="http://startry.com/2015/09/29/Something-about-Pod-Install-And-Pod-Update/"/>
    <id>http://startry.com/2015/09/29/Something-about-Pod-Install-And-Pod-Update/</id>
    <published>2015-09-29T08:51:07.000Z</published>
    <updated>2015-09-29T08:51:06.000Z</updated>
    
    <content type="html">&lt;p&gt;Cocoapods对于绝大部分的iOS开发者们应该不陌生吧~ 如果你不知道什么是CocoaPods, 请移步&lt;a href=&quot;https://guides.cocoapods.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CocoaPods的官方Guide&lt;/a&gt;去学习使用指南哇~ &lt;/p&gt;
&lt;p&gt;&lt;code&gt;pod install&lt;/code&gt;和&lt;code&gt;pod update&lt;/code&gt;应该大部分iOS以及OSX开发者最常用的两个命令了, 那么大家是否都知道&lt;code&gt;pod install&lt;/code&gt;或&lt;code&gt;pod update&lt;/code&gt;在执行中主要做了哪些事情呢? 我们来一起探究一下呗~&lt;/p&gt;
&lt;h2 id=&quot;初步窥探&quot;&gt;初步窥探&lt;/h2&gt;&lt;p&gt;通过CoocaPods的终端log输出, 我们也可以推测出&lt;code&gt;pod install&lt;/code&gt;的大致行为, 如果需要更多的信息, 可以使用&lt;code&gt;--verbose&lt;/code&gt;参数输出更多的信息, 被提炼后大致输出log如下:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Updating local specs repositories&lt;/code&gt; - 更新本地Spec索引&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CocoaPods xxx is available.&lt;/code&gt; - 新版本试用提示&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Analyzing dependencies&lt;/code&gt; - 分析依赖&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Downloading dependencies&lt;/code&gt; - 下载依赖库&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Generating Pods project&lt;/code&gt; - 生成Pods项目&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Integrating client project&lt;/code&gt; - 整合项目&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;深入窥探&quot;&gt;深入窥探&lt;/h2&gt;&lt;p&gt;其实呢… 深入了解那自然最好看源码啦~ 问题是怎么跟踪去跟踪源码和学习源码… 我写这篇文章的时候CocoaPods最新的Tag是&lt;a href=&quot;https://github.com/CocoaPods/CocoaPods/tree/0.39.0.beta.4&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;0.39.0.beta.4&lt;/a&gt;, 那我基于该tag来进行源码分析和追踪。&lt;/p&gt;
&lt;p&gt;我们想要了解两个命令&lt;code&gt;pod install&lt;/code&gt;和&lt;code&gt;pod update&lt;/code&gt;, 我们可以从命令行入口进行跟踪学习。现在我们以&lt;code&gt;pod install&lt;/code&gt;最为学习入口进行跟踪。&lt;/p&gt;
&lt;p&gt;我们可以用终端自带的&lt;code&gt;which&lt;/code&gt;命令去跟踪&lt;code&gt;pod&lt;/code&gt;命名源码文件所在地作为跟踪入口。执行命令可以发现pod命令原来放置在用户目录下的&lt;code&gt;.rvm&lt;/code&gt;隐藏目录下。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;which&lt;/span&gt; pod&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# output: /Users/[UserName]/.rvm/gems/ruby-2.2.1/bin/pod&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;使用文本编辑器打开&lt;code&gt;pod&lt;/code&gt;脚本文件, 我们可以发现如下代码:&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;load &lt;span class=&quot;constant&quot;&gt;Gem&lt;/span&gt;.bin_path(&lt;span class=&quot;string&quot;&gt;&#39;cocoapods&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;pod&#39;&lt;/span&gt;, version)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;=。= 这脚本只是负责加载一个在源码目录&lt;code&gt;bin&lt;/code&gt;下面的&lt;code&gt;pod&lt;/code&gt;文件, 那么我们继续跟踪源码&lt;code&gt;bin&lt;/code&gt;下面的&lt;code&gt;pod&lt;/code&gt;文件。不多说, 赶紧进入&lt;a href=&quot;https://github.com/CocoaPods/CocoaPods&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CocoaPods项目地址&lt;/a&gt;拉源代码了。&lt;/p&gt;
&lt;p&gt;进入CocoaPods的开源项目可以发现CocoaPods时由下图所示的多个项目组成的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://blog.startry.com/img/blog_pods_subproj.png&quot; alt=&quot;CocoaPods依赖子项目&quot;&gt;&lt;/p&gt;
&lt;p&gt;除去主工程CocoaPods和索引库Master Repo, 还依赖了5个工程。这给源码跟踪增加了不少难度, 不过没关系, 我们不是直接阅读源代码, 只需要关注主工程CocoaPods, 依赖的库在用到或者必须跟踪的时候再去跟踪。&lt;/p&gt;
&lt;p&gt;回归主题哇~&lt;/p&gt;
&lt;p&gt;主工程&lt;a href=&quot;https://github.com/CocoaPods/CocoaPods&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CocoaPods&lt;/a&gt;源码的下的&lt;code&gt;pod&lt;/code&gt;文件做了一些环境变量的条件控制, 主要是区分&lt;code&gt;COCOAPODS_NO_BUNDLER&lt;/code&gt;和&lt;code&gt;PROFILE&lt;/code&gt;环境变量, 这些不是本文的关键, 直接找&lt;a href=&quot;https://github.com/CocoaPods/CocoaPods/blob/0.39.0.beta.4/bin/pod#L44&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;核心代码&lt;/a&gt;:&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;constant&quot;&gt;Pod::Command&lt;/span&gt;.run(&lt;span class=&quot;constant&quot;&gt;ARGV&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;看到这个。。又要继续去跟踪Command的类了, ARGV是前面脚本传进来的参数。&lt;a href=&quot;https://github.com/CocoaPods/CocoaPods/blob/0.39.0.beta.4/lib/cocoapods/command.rb&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Command&lt;/a&gt;类在&lt;code&gt;lib/cocoapods/command.rb&lt;/code&gt;下。&lt;/p&gt;
&lt;p&gt;在Command类下找到初始化函数入口&lt;a href=&quot;https://github.com/CocoaPods/CocoaPods/blob/0.39.0.beta.4/lib/cocoapods/command.rb#L44&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;run&lt;/a&gt;方法。&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Command&lt;/span&gt; &lt;span class=&quot;inheritance&quot;&gt;&amp;lt; &lt;span class=&quot;parent&quot;&gt;CLAide::Command&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;# ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;self&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(argv)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    help! &lt;span class=&quot;string&quot;&gt;&#39;You cannot run CocoaPods as root.&#39;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;constant&quot;&gt;Process&lt;/span&gt;.uid == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    verify_xcode_license_approved!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;(argv)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;ensure&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;constant&quot;&gt;UI&lt;/span&gt;.print_warnings&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;# ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在Command类的&lt;code&gt;run&lt;/code&gt;方法里, 我们可以看到主要是进行了非root用户检验以及验证xcode使用协议是否已经同意, 然后执行了父类的run方法。什么? 父类? Command的父类是CLAide下的Command类, CLAide可是CoocoaPods依赖的另外一个项目啊… 不多说了, 乖乖去拉&lt;a href=&quot;https://github.com/CocoaPods/CLAide&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CLAide项目&lt;/a&gt;的源代码。&lt;/p&gt;
&lt;p&gt;因为前面的CocoaPods主库是基于tag 0.39.0.bete.4分析的, 那么我们要该库对应使用CLAide的Tag分支。在CocoaPods的&lt;a href=&quot;https://github.com/CocoaPods/CocoaPods/blob/0.39.0.beta.4/cocoapods.gemspec#L31&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;cocoapods.gemspec&lt;/a&gt;中有所有CocoaPods依赖的项目的制定版本信息, 通过查看该文件我们可以定位对应的CLAide项目使用版本是0.9.1。&lt;/p&gt;
&lt;p&gt;找到CLAide项目下的Command类的&lt;a href=&quot;https://github.com/CocoaPods/CLAide/blob/0.9.1/lib/claide/command.rb#L302&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;run&lt;/a&gt;方法:&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;self&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(argv = [])&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  plugin_prefixes.each &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; |plugin_prefix|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;constant&quot;&gt;PluginManager&lt;/span&gt;.load_plugins(plugin_prefix)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  argv = &lt;span class=&quot;constant&quot;&gt;ARGV&lt;/span&gt;.coerce(argv)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  command = parse(argv)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;constant&quot;&gt;ANSI&lt;/span&gt;.disabled = !command.ansi_output?&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;unless&lt;/span&gt; command.handle_root_options(argv)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    command.validate!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    command.run&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;rescue&lt;/span&gt; &lt;span class=&quot;constant&quot;&gt;Object&lt;/span&gt; =&amp;gt; exception&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    handle_exception(command, exception)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们可以发现此处主要任务是根据插件前缀预加载插件到管理器中, 通过&lt;a href=&quot;https://github.com/CocoaPods/CLAide/blob/0.9.1/lib/claide/argv.rb#L14&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ARGV类&lt;/a&gt;去转换生产一个参数对象, 然后通过参数对象放置转换函数中转换成为一个实际Command类并执行。&lt;/p&gt;
&lt;p&gt;我们跟踪Command类中的&lt;a href=&quot;https://github.com/CocoaPods/CLAide/blob/0.9.1/lib/claide/command.rb#L325&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;parse&lt;/a&gt;方法, 可以发现parse方法取了参数中的第一个参数去调用[find_subcommand], 即用&lt;code&gt;`install&lt;/code&gt;去匹配command的名字, &lt;a href=&quot;https://github.com/CocoaPods/CLAide/blob/0.9.1/lib/claide/command.rb#L139&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;command属性的定义&lt;/a&gt;中描述如下:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; @return [String] The name of the command. Defaults to a snake-cased &lt;br&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么接下来的任务就是寻找类名为install子类的run方法了。赶紧在CoocaPods主工程中搜索install.rb这个文件，额。。没有找到。。这个源码跟踪的就断线了, 莫非一定要用&lt;strong&gt;Debug&lt;/strong&gt;的方式去跟踪? &lt;/p&gt;
&lt;p&gt;既然直接搜名字不行, 那就试试用别的途径, 从前面的跟踪推测Install总得是个Command的子类吧, 那我们尝试用&lt;code&gt;Install &amp;lt; Command&lt;/code&gt;去搜索。Pingo!! Install类果然被我们找到了, 藏在了project.rb文件下, 原来CocoaPods的开发者们把Install和Update类都放置在了project.rb中了。不多说，继续上代码:&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Install&lt;/span&gt; &lt;span class=&quot;inheritance&quot;&gt;&amp;lt; &lt;span class=&quot;parent&quot;&gt;Command&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;constant&quot;&gt;Project&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;# ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    verify_podfile_exists!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    run_install_with_update(&lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Install类的&lt;a href=&quot;https://github.com/CocoaPods/CocoaPods/blob/0.39.0.beta.4/lib/cocoapods/command/project.rb#L99&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;run&lt;/a&gt;方法终于进入到了前面初探的执行步骤了哇, 前面这么一大堆行为都是为了处理命令哇。&lt;/p&gt;
&lt;p&gt;到这里我们可以猜想一下Update类的run方法是否就是在调用&lt;code&gt;run_install_with_update&lt;/code&gt;方法时候传入参数的不同呢? 哈哈, 其实不是, Update类的&lt;a href=&quot;https://github.com/CocoaPods/CocoaPods/blob/0.39.0.beta.4/lib/cocoapods/command/project.rb#L130&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;run&lt;/a&gt;方法还要检查是否所有的pods都被install过了, 如果没有的话会主动抛错, 检查通过的才会调用&lt;code&gt;run_install_with_update&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;verify_podfile_exists&lt;/code&gt;在这里就不做赘述, 我们直接进入&lt;a href=&quot;https://github.com/CocoaPods/CocoaPods/blob/0.39.0.beta.4/lib/cocoapods/command/project.rb#L68&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;run_install_with_update&lt;/code&gt;&lt;/a&gt;方法。&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;run_install_with_update&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(update)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  installer = &lt;span class=&quot;constant&quot;&gt;Installer&lt;/span&gt;.new(config.sandbox, config.podfile, config.lockfile)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  installer.update = update&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  installer.install!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个大家可能会有个困惑: config是什么时候加载的呢? 这个大家可以自己去发掘喔~ 不然本文就要改名为CocoaPods源码分析之一二三四了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;run_install_with_update&lt;/code&gt;的核心代码是调用了Installer类的&lt;a href=&quot;https://github.com/CocoaPods/CocoaPods/blob/0.39.0.beta.4/lib/cocoapods/installer.rb#L103&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;install&lt;/a&gt;方法, 继续贴代码:&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;install!&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  prepare&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  resolve_dependencies&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  download_dependencies&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  determine_dependency_product_types&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  verify_no_duplicate_framework_names&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  verify_no_static_framework_transitive_dependencies&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  verify_framework_usage&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  generate_pods_project&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  integrate_user_project &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; config.integrate_targets?&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  perform_post_install_actions&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;哇塞, 我要找所有东西都几乎全列在这个方法里了, 大致的行为动作如下哈, 我会每一个都粗略的介绍一番。&lt;/p&gt;
&lt;h2 id=&quot;背后那点事&quot;&gt;背后那点事&lt;/h2&gt;&lt;p&gt;通过签名的代码跟踪，我们可以总结出&lt;code&gt;pod install&lt;/code&gt;命令背后执行了这么十件大事:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;准备工作&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;查找依赖库&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;下载依赖库&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;决定依赖库的类型&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;验证没有重名的framework&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;验证静态库的传递依赖&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;验证framwoke的使用&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;生成工程&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;整合用户项目&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;执行install后的行为&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;准备工作&quot;&gt;准备工作&lt;/h3&gt;&lt;p&gt;准备工作&lt;a href=&quot;https://github.com/CocoaPods/CocoaPods/blob/0.39.0.beta.4/lib/cocoapods/installer.rb#L116&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;(&lt;code&gt;prepare&lt;/code&gt;)&lt;/a&gt;主要做了以下事情:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;沙盒的准备 - 一些文件以及目录的删除以及创建&lt;/li&gt;
&lt;li&gt;确保Podfile指定的插件都已经安装(不然抛错)&lt;/li&gt;
&lt;li&gt;迁移沙盒中部分文件(区分Pods版本迁移地址不同)&lt;/li&gt;
&lt;li&gt;执行pre_install的Hook&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;查找依赖库&quot;&gt;查找依赖库&lt;/h3&gt;&lt;p&gt;查找依赖库&lt;a href=&quot;https://github.com/CocoaPods/CocoaPods/blob/0.39.0.beta.4/lib/cocoapods/installer.rb#L125&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;(&lt;code&gt;resolve_dependencies&lt;/code&gt;&lt;br&gt;)&lt;/a&gt;主要做了以下事情:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过HookManager添加插件源&lt;/li&gt;
&lt;li&gt;如果config的&lt;code&gt;skip_repo_update&lt;/code&gt;参数没有设置的时候执行Analyzer类的&lt;code&gt;update_repositories&lt;/code&gt;方法来更新本地索引库 (这里大家其实可以看出&lt;code&gt;--no-repo-update&lt;/code&gt;的作用了吧)&lt;/li&gt;
&lt;li&gt;验证Build Configurations参数的有效性&lt;/li&gt;
&lt;li&gt;准备版本兼容的遗留问题处理(0.39.0.beta.4属于空方法)&lt;/li&gt;
&lt;li&gt;清理沙盒&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;下载依赖库&quot;&gt;下载依赖库&lt;/h3&gt;&lt;p&gt;下载依赖库&lt;a href=&quot;https://github.com/CocoaPods/CocoaPods/blob/0.39.0.beta.4/lib/cocoapods/installer.rb#L752&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;(&lt;code&gt;run_podfile_pre_install_hooks&lt;/code&gt;)&lt;/a&gt;做了如下事情:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;准备沙盒文件访问器&lt;/li&gt;
&lt;li&gt;下载安装Pods依赖库源文件&lt;/li&gt;
&lt;li&gt;执行Pods依赖库的pre install的执行钩子&lt;/li&gt;
&lt;li&gt;根据Config和Installers参数清理Pods的源文件&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;决定依赖库的类型&quot;&gt;决定依赖库的类型&lt;/h3&gt;&lt;p&gt;决定依赖库的类型&lt;a href=&quot;https://github.com/CocoaPods/CocoaPods/blob/0.39.0.beta.4/lib/cocoapods/installer.rb#L385&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;(&lt;code&gt;determine_dependency_product_types&lt;/code&gt;)&lt;/a&gt;方法的作用主要是预判断库的&lt;code&gt;host_requires_frameworks&lt;/code&gt;存储在&lt;code&gt;pod_target&lt;/code&gt;属性中给后续使用。 那么主要决定什么内容呢? 参考源码中的注释:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Determines if the dependencies need to be built as dynamic frameworks or if they can be built as static libraries by checking for the Swift source presence.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;主要是判断库是否需要支持动态Framework以及是否可以被Swift使用过的静态库。&lt;/p&gt;
&lt;h3 id=&quot;验证没有重名的framework&quot;&gt;验证没有重名的framework&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/CocoaPods/CocoaPods/blob/0.39.0.beta.4/lib/cocoapods/installer.rb#L393&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;(&lt;code&gt;verify_no_duplicate_framework_names&lt;/code&gt;)&lt;/a&gt;主要是验证了目标工程集合和Pods库工程没有命名冲突的Framework, 重点是检查了Framework的名字是否冲突; 如果冲突会抛出&lt;code&gt;frameworks with conflicting names&lt;/code&gt;异常&lt;/p&gt;
&lt;h3 id=&quot;验证静态库的传递依赖&quot;&gt;验证静态库的传递依赖&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/CocoaPods/CocoaPods/blob/0.39.0.beta.4/lib/cocoapods/installer.rb#L410&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;(&lt;code&gt;verify_no_static_framework_transitive_dependencies&lt;/code&gt;)&lt;/a&gt;检查了静态库里是否包含了引用的静态库, 形成传递依赖。静态库的传递依赖如果形成会主动抛出&lt;code&gt;transitive dependencies that include static binaries&lt;/code&gt;异常。&lt;/p&gt;
&lt;h3 id=&quot;验证framework的使用&quot;&gt;验证framework的使用&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/CocoaPods/CocoaPods/blob/0.39.0.beta.4/lib/cocoapods/installer.rb#L429&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;(&lt;code&gt;verify_framework_usage&lt;/code&gt;)&lt;/a&gt;检查是否引用了Switf书写的framework, 并且Podfile中没有指定&lt;code&gt;use framework!&lt;/code&gt;。如果验证不通过, 主动抛出异常。&lt;/p&gt;
&lt;h3 id=&quot;生成工程&quot;&gt;生成工程&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/CocoaPods/CocoaPods/blob/0.39.0.beta.4/lib/cocoapods/installer.rb#L152&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;(generate_pods_project&lt;br&gt;)&lt;/a&gt;指定了八件任务, 执行分析过程相对比较复杂, 并且大部分执行动作都涉及CocoaPods依赖的另外一个工程&lt;a href=&quot;https://github.com/CocoaPods/Xcodeproj&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Xcodeproj&lt;/a&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;准备Pods工程(&lt;code&gt;prepare_pods_project&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;安装文件引用(&lt;code&gt;install_file_references&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;安装库(&lt;code&gt;install_libraries&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;为Target设置依赖(&lt;code&gt;set_target_dependencies&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;执行pod项目的post install的钩子(&lt;code&gt;run_podfile_post_install_hooks&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;执行Project类的Save方法保存配置(&lt;code&gt;write_pod_project&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Pods工程配置共享依赖库的Target Scheme(&lt;code&gt;share_development_pod_schemes&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;修改Pods工程的LockFile文件(&lt;code&gt;write_lockfiles&lt;/code&gt;)&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;整合用户项目&quot;&gt;整合用户项目&lt;/h3&gt;&lt;p&gt;整合项目主要是依赖&lt;code&gt;UserProjectIntegrator&lt;/code&gt;类的&lt;a href=&quot;https://github.com/CocoaPods/CocoaPods/blob/0.39.0.beta.4/lib/cocoapods/installer/user_project_integrator.rb#L49&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;integrate&lt;/a&gt;方法, 该方法主要是做了两件事情:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;负责创建xcode的workspace, 并整合所有的target到新的workspace中. &lt;/li&gt;
&lt;li&gt;抛出Podfile空项目依赖和xcconfig是否被原有的xcconfig所覆盖依赖相关的警告。&lt;font style=&quot;color:orange&quot;&gt;最常见的xcconfig override警告就是这里抛出来的哦&lt;/font&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;执行install后的行为&quot;&gt;执行install后的行为&lt;/h3&gt;&lt;p&gt;install后的行为分为四段:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;unLock Pods库下的文件以便执行post install的钩子逻辑&lt;/li&gt;
&lt;li&gt;执行Post Install的钩子逻辑&lt;/li&gt;
&lt;li&gt;抛出签名执行收集的Spec废弃警告&lt;/li&gt;
&lt;li&gt;重新锁定Lock Pods库下的文件防止用户误修改&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;到目前为止, &lt;code&gt;pod install&lt;/code&gt;背后的十件大事都&lt;em&gt;粗略&lt;/em&gt;的介绍完了哈。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;&lt;p&gt;本文从&lt;code&gt;pod install&lt;/code&gt;作为入口, 跟踪CocoaPods的实现源码, 并粗略根据&lt;code&gt;tag 0.39.0.beta.4&lt;/code&gt;的源码将&lt;code&gt;pod install&lt;/code&gt;背后主要执行的十个任务罗列出来。通过源码跟踪, 能够更深入的去了解Pods背后的工作, 能够更轻易排查因为Pods使用产生的问题。&lt;/p&gt;
&lt;p&gt;另: 源码跟踪还是要自己动手更有效果哇, 因为篇幅问题, 更多细节会在后续文章中补全~~&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PS: 本人水平有限, 如果有错误的地方, 请及时指出纠正, 谢谢哇!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PS: 转载请注明出处哦~~&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;参考文献&quot;&gt;参考文献&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://guides.cocoapods.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CocoaPods官方Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/CocoaPods&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Github CocoaPods源码库&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Cocoapods对于绝大部分的iOS开发者们应该不陌生吧~ 如果你不知道什么是CocoaPods, 请移步&lt;a href=&quot;https://guides.cocoapods.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CocoaPods的官方
    
    </summary>
    
    
      <category term="CocoaPods" scheme="http://startry.com/tags/CocoaPods/"/>
    
      <category term="Ruby" scheme="http://startry.com/tags/Ruby/"/>
    
      <category term="iOS" scheme="http://startry.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS - 创建大量相似App的另外一种选择</title>
    <link href="http://startry.com/2015/09/06/Optional-solutions-for-iOS-multi-target/"/>
    <id>http://startry.com/2015/09/06/Optional-solutions-for-iOS-multi-target/</id>
    <published>2015-09-06T08:15:50.000Z</published>
    <updated>2015-09-06T08:15:50.000Z</updated>
    
    <content type="html">&lt;p&gt;本篇文章主要针对iOS应用开发中, 针对需要创建许多相似的应用App提出一种新颖的解决方案。&lt;/p&gt;
&lt;p&gt;关于如何创建大量相似的App，&lt;a href=&quot;http://weibo.com/tangqiaoboy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;iOS大神@唐巧&lt;/a&gt;曾在他的博文&lt;a href=&quot;http://blog.devtang.com/blog/2013/10/17/the-tech-detail-of-ape-client-1/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《猿题库iOS客户端的技术细节（一）：使用多target来构建大量相似App》&lt;/a&gt;提出了一种可行性非常高的解决方案。我本人也将该实现方案应用到了某二手车应用开发中, 通过创建多个target的方式创建了N个某某拍的应用。但是这种方案真的适用于所有场景么? 除了使用这种方案能否有其它的方式去解决这个问题呢?&lt;/p&gt;
&lt;h3 id=&quot;基于多Target的应用实践&quot;&gt;基于多Target的应用实践&lt;/h3&gt;&lt;p&gt;我刚开始接触到开发多个相似App应用的需求的时候, 也采用了多个target的解决方案。主要做了以下工作:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;建立多个Target (通过Duplicate行为)&lt;/li&gt;
&lt;li&gt;为每一个Target指定LaunchImage和IconImage, LauchImage和IconImage由同一个image assert管理&lt;/li&gt;
&lt;li&gt;为每一个Target指定了&lt;em&gt;Info.Plist&lt;/em&gt;和&lt;em&gt;InfoPlist.strings&lt;/em&gt;, InfoPlist.strings的作用仅仅是为了指定&lt;strong&gt;CFBundleDisplayName&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;为每一个Target创建了一个用于配置应用特征的JSON描述文件, 用于对每个Target的特征进行配置修改。&lt;/li&gt;
&lt;li&gt;部署自动化打包平台，防止有N个Target就手动打N次包。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://blog.startry.com/img/blog_single_proj_muti_target.png&quot; alt=&quot;配置Configuration的各个xcconfig&quot;&gt;&lt;/p&gt;
&lt;p&gt;在上述工作中, 1、2、3均和配置项有关, 5与项目开发无关, 4是和具体的开发业务相关的。每一项的配置都没有什么技术深度和难度, 4的实现和具体需求相关, 对于极度相似的应用更多的行为是换肤和换key。&lt;/p&gt;
&lt;p&gt;这里稍微提以下关于InfoPlist.strings的指定, 每一个Target只能识别一个InfoPlist.strings, 而且还不能重命名。需要为每一个Target创建一个物理文件夹, 然后在对应的文件夹下放置InfoPlist.strings防止命名冲突, 每一个InfoPlist.strings只能指定唯一识别的Target对象。(原理我还没有找到, 找到我就更新下博文哈~)&lt;/p&gt;
&lt;h3 id=&quot;差异性较大的Target处理&quot;&gt;差异性较大的Target处理&lt;/h3&gt;&lt;p&gt;什么? 差异性大你还放在一个工程里? 架构就有问题。是的, 差异性较大的工程就应该拆分成不同的工程, 然后共享的代码通过framework以及静态库引用的方式抽离出去。&lt;font color=&quot;orange&quot;&gt;但是, 时间是道坎!&lt;/font&gt; 假如你时间很紧怎么办? 本文给出一种时间很紧时候的&lt;font color=&quot;red&quot;&gt;临时&lt;/font&gt;解决方案&lt;strong&gt;(注意: 决必是临时的, 时间是海绵, 需要去挤的!)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在时间非常紧的情况下, 可以通过拆分AppDelegate来实现(代价其实非常沉重, 会link好多无用的类)。拆分AppDelegate其实就要在main.m里面赋值不同的AppDelegate即可实现。main函数中argv包含了app的名字, 可以通过该名字去鉴别载入的AppDelegate。&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;#60;UIKit/UIKit.h&amp;#62;&amp;#10;&amp;#10;#import &amp;#34;STAppDelegate.h&amp;#34;&amp;#10;#import &amp;#34;STPAppDelegate.h&amp;#34;&amp;#10;&amp;#10;int main(int argc, char * argv[])&amp;#10;&amp;#123;&amp;#10;    @autoreleasepool &amp;#123;&amp;#10;        char demoStr[] = &amp;#34;/stdemo.app&amp;#34;; // &amp;#26816;&amp;#26597;stdemo target&amp;#10;        char *p= strstr(*argv, demoStr);&amp;#10;        if(NULL != p)&amp;#123;&amp;#10;            return UIApplicationMain(argc, argv, nil, NSStringFromClass([STAppDelegate class]));&amp;#10;        &amp;#125;else&amp;#123;&amp;#10;            return UIApplicationMain(argc, argv, nil, NSStringFromClass([STPAppDelegate class]));&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;PS: 切记, 临时解决方案, 如需根治, &lt;font style=&quot;font-size:1.5em&quot;&gt;拆分工程&lt;/font&gt;!&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;基于多Target实现的好处&quot;&gt;基于多Target实现的好处&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;直观&lt;/p&gt;
&lt;p&gt; 一目了然, 可以看到所有已创建的Target醒目的列在Build列表中。每一个Target都有对应的Tagret配置界面可以看到每一个项目配置图标以及Info.plist对应信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;灵活性高&lt;/p&gt;
&lt;p&gt; 可以根据项目需要Link需要的类, 根据Target来指定链接不同的类和资源文件, 而不用一口气全部都Link进来。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;基于多Target遇到的坑&quot;&gt;基于多Target遇到的坑&lt;/h3&gt;&lt;p&gt;如果没有遇到坑, 那就不会去重新寻找一个更好的解决方案了。基于多Target的方式去创建大量相似的App的坑主要提现在&lt;strong&gt;多人协作&lt;/strong&gt;上。&lt;/p&gt;
&lt;p&gt;个人之前在实现多Target项目的时候遇到的问题不多, 但是随着时间推移, 维护开发遇到了两个比较明显的问题:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;类的Target指定遗漏&lt;/p&gt;
&lt;p&gt; 在多个Target的环境下, 我们每新建一个类文件都要给类文件指定对应的Target, 如果不小心忘记指定对应的Target, 则会会在编译阶段报错。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://blog.startry.com/img/blog_missing_target.png&quot; alt=&quot;配置Configuration的各个xcconfig&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;配置文件描述庞大, 难以修改&lt;/p&gt;
&lt;p&gt;多个Target会导致项目的pbxproj臃肿, 因为pbxproj文件维护了项目的所有文件id和group层级关系, 多一个target就几乎多了一倍的描述信息, 可想而知, 这个pbxporj文件是有多庞大。&lt;/p&gt;
&lt;p&gt;光文件庞大顶多引起Xcode项目的配置文件加载慢, 但是遇到冲突的时候可就头疼了, 几万行的描述文件。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://blog.startry.com/img/blog_pbcproj_too_much.png&quot; alt=&quot;配置Configuration的各个xcconfig&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;配置文件修改不同步&lt;/p&gt;
&lt;p&gt;配置文件修改不同步是基于已创建N个Target的前提下, 因为项目的推进, 需要对每一个项目文件进行固定的修改, 但是存在修改遗漏的情况。&lt;/p&gt;
&lt;p&gt;对于这种场景, 有一种比较好的方案是自己动手写脚本来替换编译配置项, 保证每一个Target的配置项目均被替换。Mac开发工具中自带的&lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man8/PlistBuddy.8.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;PlistBuddy&lt;/a&gt;在处理配置项目替换上绝对是个神器。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;重新思考&quot;&gt;重新思考&lt;/h3&gt;&lt;p&gt;虽然在项目中遇到了不少坑，但是解决这些坑并不需要大量的时间(那是因为时间被打散了, 组合起来估计也不少了)，所以我个人并没有去重新思考怎么去解决遗漏Target编译报错以及项目配置文件不断冲突的问题。&lt;/p&gt;
&lt;p&gt;触发我重新思考是一次机缘, 经过花瓣网某iOS研发高手(我不知道他名字哇)提点, 他问我基于Cocoapods能否有更好的办法去创建大量相似的App。基于Cocoapods本身就是基于Hook, Hook本身就是动态修改项目配置项, 换言之, &lt;font color=&quot;red&quot;&gt;能否通过动态修改Target的项目配置项去创建大量相似的App呢&lt;/font&gt;?&lt;/p&gt;
&lt;p&gt;回到文章前面的&lt;code&gt;基于多Target的应用实践&lt;/code&gt;的5个步骤, 逐一用替换项目的配置文件(pbcproj)的方式去重新审视。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不需要建立多个Target, 只维护一个Target&lt;/li&gt;
&lt;li&gt;主要是icon和launch image的修改, 有两种方案:&lt;ul&gt;
&lt;li&gt;在image.assert预先放置多个不同名字的资源, 通过修改pbxproj来指定不同的图片资源&lt;/li&gt;
&lt;li&gt;所有的icon和launch image都是用相同名字, 通过脚本动态替换image.assert中的资源文件(推荐)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;主要针对info.plist和InfoPlist.strings的修改, InfoPlist.string可以通过&lt;code&gt;sed&lt;/code&gt;命令去动态替换, info.plist也可以采取两种方案来实现:&lt;ul&gt;
&lt;li&gt;预先防止多个Info.plist文件, 通过修改pbxcproj来指定不同的info.plist文件&lt;/li&gt;
&lt;li&gt;target永远指定一个Info.plist, 通过脚本动态替换修改Info.plist(推荐)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;通过JSON描述特性的文件可以单独防止在工程里, 通过脚本拷贝替换, 也可以利用&lt;code&gt;cocoapods-keys&lt;/code&gt;等工具进行外部注入&lt;/li&gt;
&lt;li&gt;前面的4个步骤都是依赖于基本动态替换, 自动化构建平台通过将指定Target的方式, 修改为在编译器执行对应的任务脚本即可完成。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;进一步优化&quot;&gt;进一步优化&lt;/h4&gt;&lt;p&gt;重新思考&lt;strong&gt;&lt;font color=&quot;black&quot;&gt;通过外部修改配置项目和资源文件的方式来实现多个类似应用功能&lt;/font&gt;&lt;/strong&gt;, 省去了维护多个target产生的冲突和配置过大的问题。但是, 外部脚本本身也是一个实现成本, 这里针对替换外部脚本提出一个优化策略(不一定最优)。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;维护每个项目的文件夹&lt;/p&gt;
&lt;p&gt;每一个项目就是指原来的每一个target, 文件夹可以保持和原先的target名字保持同名。该目录文件夹不参与项目引用, 即不在pbxcproj文件中被描述。该目录文件夹纯粹是提供给外部脚本使用, 与逻辑工程保持独立。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在第一步的文件夹中抽离变化项目到同一个JSON文件中&lt;/p&gt;
&lt;p&gt; 该json文件中描述了所有需要替换的内容, 包含image.assert的替换规则以及info.plist替换规则等等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在第一步的文件夹中抽离资源文件&lt;/p&gt;
&lt;p&gt;在该文件夹中防止所有可变化的资源文件, 包含&lt;code&gt;.png&lt;/code&gt;、&lt;code&gt;info.plist&lt;/code&gt;等等所有可变化差异的项目。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://blog.startry.com/img/blog_shell_muti_target_menu.png&quot; alt=&quot;配置Configuration的各个xcconfig&quot;&gt;&lt;/p&gt;
&lt;p&gt;在前面三步的基础下, 主要是为了一个目的, 一行脚本替换所有可变信息。(实际上就是提前将变化项维护在独立的文件夹中了)&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;## 动态变化 demo1 Target&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;./st_muti_target st_demo1/muti_target.json&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;## 动态变化 demo2 Target&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;./st_muti_target st_demo2/muti_target.json&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;想要&lt;code&gt;st_muti_target.sh&lt;/code&gt;的源码? 这个自己写吧。。每个项目都不一样的。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;&lt;p&gt;基于建立多个相似App的需求, 和本人实际在项目应用中遇到的坑, 提出了一种基于脚本不断替换配置项目和资源文件的解决方案。该方案主要解决了多Target所带来的配置文件过大和容易冲突的问题, 但是同时又引入了脚本的维护成本。本文也提供了一种降低脚本使用成本和项目耦合的一种方案, 但是仍需要进一步优化, 并不是最终的解决方案版本。&lt;/p&gt;
&lt;p&gt;多一种方案多一种选择么, 对于擅长书写脚本的童鞋们, 用这种方式做大量类似的App(换肤App)可能会是更好的一种选择喔~&lt;/p&gt;
&lt;p&gt;水平有限, 有错误之处或者有什么地方没有描述清楚, 请大家及时指出哇~&lt;/p&gt;
&lt;p&gt;参考文件:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.devtang.com/blog/2013/10/17/the-tech-detail-of-ape-client-1/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.devtang.com/blog/2013/10/17/the-tech-detail-of-ape-client-1/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章主要针对iOS应用开发中, 针对需要创建许多相似的应用App提出一种新颖的解决方案。&lt;/p&gt;
&lt;p&gt;关于如何创建大量相似的App，&lt;a href=&quot;http://weibo.com/tangqiaoboy&quot; target=&quot;_blank&quot; rel=&quot;external
    
    </summary>
    
    
      <category term="ios" scheme="http://startry.com/tags/ios/"/>
    
      <category term="xcconfig" scheme="http://startry.com/tags/xcconfig/"/>
    
  </entry>
  
  <entry>
    <title>iOS - Umbrella Header在framework中的应用</title>
    <link href="http://startry.com/2015/08/25/Renaming-umbrella-header-for-iOS-framework/"/>
    <id>http://startry.com/2015/08/25/Renaming-umbrella-header-for-iOS-framework/</id>
    <published>2015-08-25T04:52:19.000Z</published>
    <updated>2015-08-25T04:52:19.000Z</updated>
    
    <content type="html">&lt;p&gt;在相对较大的互联网App研发中, framework静态库被广泛应用, 那么在研发framework的时候也产生好多的问题? 其实一个常见的问题的就是umbreall header文件的使用。&lt;/p&gt;
&lt;p&gt;大家是否有遇到过一个常见的错误使用umbrella header的场景: framework的文件明明被主工程引用了, 但是在编译的时候依旧抛出&lt;font color=&quot;orange&quot;&gt;Lexical or Preprocessor Issue - Umbrella header for module ‘xxx’ does not include header ‘xxx.h’&lt;/font&gt;的警告。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那么问题来了, 什么是umbrella header? 什么又是umbrella framework呢?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;参考官方文档&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/MacOSX/Conceptual/BPFrameworks/Frameworks.html#//apple_ref/doc/uid/10000183-SW1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《Introduction to Framework Programming Guide》&lt;/a&gt;学习说明, 可以了解到Framework区分Standard Framework和Umbrella Framework。但是, 我找了半天也没有找到官方文档有对Umberlla framework给出明确的定义(大家找到了记得告诉我)。在官方文档&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/MacOSX/Conceptual/BPFrameworks/Concepts/FrameworkAnatomy.html#//apple_ref/doc/uid/20002253-97623-BAJJHAJC&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《Anatomy of Framework Bundles》&lt;/a&gt;章节中, 我找到三段比较合理说明Umbrella Framework的话:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Umbrella frameworks add minor refinements to the standard framework structure, such as the ability to encompass other frameworks&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;The structure of an umbrella framework is similar to that of a standard framework, and applications do not distinguish between umbrella frameworks and standard frameworks when linking to them. However, two factors distinguish umbrella frameworks from other frameworks. The first is the manner in which they include header files. The second is the fact that they encapsulate subframeworks.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;Physically, umbrella frameworks have a similar structure to standard frameworks. One significant difference is the addition of a Frameworks directory to contain the subframeworks that make up the umbrella framework.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;字面上的意思应该是在标准的Framework做了一些改良的工作, 使其可以嵌套包含Framework。&lt;br&gt;在物理结构上, Umbrella Framework只在包含头文件的方式以及是否包含子Framework和普通的Framework存在区别。&lt;/p&gt;
&lt;p&gt;那么引用头文件的地方又有什么区别呢? 还是参考官方文档引用:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;For most frameworks, you can include header files other than the master header file. You can include any specific header file you want as long as it is available in the framework’s Headers directory. However, if you are including an umbrella framework, you must include the master header file. Umbrella frameworks do not allow you to include the headers of their constituent subframeworks directly. See &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/MacOSX/Conceptual/BPFrameworks/Tasks/IncludingFrameworks.html#//apple_ref/doc/uid/20002257-BAJJBBHJ&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Restrictions on Subframework Linking&lt;/a&gt; for more information.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单翻译一下: &lt;strong&gt;普通的framework可以通过引用对应的heaedr文件而不是Master Header File去引用需要使用的类, 只需要对应的header头文件在Headers文件夹下暴露, 并没有强制要求引用Master Header File。Umbrella Framework要求必须要引用Master Header File, 并且头文件中不能直接引用子Framework的东西。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上述描述已经说了Umbrella Framework一定要引用Master Header File, 而Umbrella Framework的Master Header File就是Umbrella header文件。&lt;/p&gt;
&lt;p&gt;大家是否存在一个疑问, 官方说明中只有强制规定一定要引用Umbrella Header文件, 但是却没有说能不能单独引用Umbrella Framework的其他头文件呢? 我们可以自己试验一下:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在Umbrella Framework新建一个&lt;code&gt;testObject&lt;/code&gt;类, 分别产生了&lt;code&gt;testObject.h&lt;/code&gt;和&lt;code&gt;testObject.m&lt;/code&gt;文件。&lt;/li&gt;
&lt;li&gt;打开Framework配置文件, 在&lt;code&gt;Build Phases&lt;/code&gt;的&lt;code&gt;Headers&lt;/code&gt;里的&lt;code&gt;Public&lt;/code&gt;目录下, 将&lt;code&gt;testObject.h&lt;/code&gt;文件添加进去。&lt;/li&gt;
&lt;li&gt;Build Framework看是否报错。&lt;/li&gt;
&lt;li&gt;在主工程中调用初始化&lt;code&gt;testObject&lt;/code&gt;对象, 看编译是否报错。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;执行结果:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;步骤3&lt;/strong&gt;: 没有编译报错, 但是报出了&lt;font color=&quot;orange&quot;&gt;Lexical or Preprocessor Issue - Umbrella header for module ‘STDemoUI’ does not include header ‘testObject.h’&lt;/font&gt;的警告。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;步骤4&lt;/strong&gt;: 执行正常。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么我们来总结一下:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Standard Framework不能包含Sub Framework; Umbrella Framework可以包含子Framework;&lt;/li&gt;
&lt;li&gt;Standard Framework可以直接引用需要使用的头, 也可以通过引用Master Header file来引用需要使用的类; Umbrella Framework需要通过引用Master Header File(Umbrella Header)来引用需要使用的类;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;规范的写法&quot;&gt;规范的写法&lt;/h3&gt;&lt;p&gt;Umbrella Framework默认会创建一个同名.h文件最为Umbrella Header文件。规范的写法当然是遵从默认的模式, 将所有需要暴露的头文件都写在Umbrella Header文件中。&lt;/p&gt;
&lt;p&gt;例如: &lt;code&gt;STDemoUI.framework&lt;/code&gt;工程包含了&lt;strong&gt;STClassOne&lt;/strong&gt;、&lt;strong&gt;STClassTwo&lt;/strong&gt;和&lt;strong&gt;STClassThree&lt;/strong&gt;三个类。&lt;code&gt;STDemoUI&lt;/code&gt;会生成一个默认的伞头文件(直译Umbrella Header, 不专业)&lt;code&gt;STDemoUI.h&lt;/code&gt;。假设该framework的三个类均需要在外部调用使用, 则&lt;code&gt;STDemoUI.h&lt;/code&gt;需要将三个类的引用均写入伞头文件中。&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// STDemoUI.h&amp;#10;// ...&amp;#10;&amp;#10;#import &amp;#60;STDemoUI/STClassOne.h&amp;#62;&amp;#10;#import &amp;#60;STDemoUI/STClassTwo.h&amp;#62;&amp;#10;#import &amp;#60;STDemoUI/STClassThree.h&amp;#62;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在需要调用的主工程中, 仅仅只要将Umbrella Header引用即可调用所有在Umbrella Header中包含的类了。&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// &amp;#22312;&amp;#20027;&amp;#24037;&amp;#31243;&amp;#38656;&amp;#35201;&amp;#24212;&amp;#29992;&amp;#30340;&amp;#31867;&amp;#20013;&amp;#21253;&amp;#21547;Umbrella Header&amp;#10;#import &amp;#60;STDemoUI/STDemoUI.h&amp;#62;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;如何重命名umbrella_header&quot;&gt;如何重命名umbrella header&lt;/h3&gt;&lt;p&gt;如果大家都遵从默认的Umbrella Framework的写法, 在同名头文件中写需要暴露的引用头文件, 那么就不需要考虑怎么重命名Umbrella header了。&lt;/p&gt;
&lt;p&gt;很多时候, 理想和现实是有差距的, 程序员写代码多数是在二次接手进行开发的。假设公司的前辈已经将Framework的同名文件用作了一个逻辑类, 给同名文件创建了.m文件, 并已经书写了逻辑并应用了各个工程里面去了。那么显然迁移头文件功能代码是不可能的, 因为很多依赖该Framework的业务部门都需要针对库进行代码优化。&lt;/p&gt;
&lt;p&gt;在这种不能将同名文件作为Umbrella header的情况下, 我们又不想通过Public强制暴露头文件的情况下(&lt;strong&gt;不写在Umbrella Header中会有警告&lt;/strong&gt;)。我们就需要对Umbrella Header进行指定了。&lt;/p&gt;
&lt;h4 id=&quot;指定Umbrella_Header入口在哪里呢?&quot;&gt;指定Umbrella Header入口在哪里呢?&lt;/h4&gt;&lt;p&gt;万事开头难, 我们想要指定Umbrella Header, 但是在哪里指定呢? 通过文章搜索, 都没有找到一个比较合理的方案, 那就只能自己摸索了。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在工程全局搜索&lt;code&gt;umbrella&lt;/code&gt;关键字 - &lt;font color=&quot;red&quot;&gt;Failed&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;在Build Settings里搜索&lt;code&gt;umbrella&lt;/code&gt;关键字 - &lt;font color=&quot;red&quot;&gt;Failed&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;在打包好的&lt;code&gt;STDemoUI.framework&lt;/code&gt;中搜索&lt;code&gt;umbrella&lt;/code&gt;关键字 - &lt;font color=&quot;green&quot;&gt;Bingo&lt;/font&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;既然搜索到了关键字就好办了, 双击点开STDemo.framework, 我们可以看到如下图所示五个文件(夹)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://blog.startry.com/img/blog_framework_structure.png&quot; alt=&quot;Framework内部结构&quot;&gt;&lt;/p&gt;
&lt;p&gt;初略看名称可以推测出每个文件以及文件夹所承担的作用:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;_CodeSignature: 保存签名相关文件&lt;/li&gt;
&lt;li&gt;Headers: framework暴露的所有头文件&lt;/li&gt;
&lt;li&gt;Info.plist: 描述了该framework所包含的项目配置信息&lt;/li&gt;
&lt;li&gt;STDemo: 编译后的核心库文件&lt;/li&gt;
&lt;li&gt;Modules: 模块相关文件夹, 目测只包含了&lt;code&gt;module.modulemap&lt;/code&gt;文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们在&lt;code&gt;module.modulemap&lt;/code&gt;文件中找到了&lt;code&gt;umbrella&lt;/code&gt;关键字。文件内容如下:&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;framework module STDemoUI &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  umbrella header &quot;STDemoUI.h&quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  export *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  module * &amp;#123; export * &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;原来Framework的umbrella header是在这个位置被指定的, 但是这个已经是编译好的工程, 我们总不能每次编译好了再进到包里面修改下。既然我们已经找到umbrella header是在module中去指定, 那么我们就用&lt;code&gt;module&lt;/code&gt;作为关键字再去&lt;code&gt;Build Settings&lt;/code&gt;里重新搜索下呗~ &lt;/p&gt;
&lt;p&gt;这回我们在&lt;code&gt;Kernel Module&lt;/code&gt;和&lt;code&gt;Packaging&lt;/code&gt;中均找到了&lt;code&gt;Module&lt;/code&gt;关键字, 在&lt;code&gt;Packaging&lt;/code&gt;标签中, 有一项&lt;code&gt;Module Map File&lt;/code&gt;属性, 看名字应该是用来指定modulemap文件的, 这不解决了么?&lt;/p&gt;
&lt;h4 id=&quot;指定Modulemap文件&quot;&gt;指定Modulemap文件&lt;/h4&gt;&lt;p&gt;找到了解决方案, 那么接下来就要动手去解决问题了&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建一个新的.h文件; ex: STHeader.h&lt;ul&gt;
&lt;li&gt;将所有需要暴露的头文件均写入STHeader.h&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;创建一个新的modulemap文件; ex: stdemoalt.modulemap&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在新的modulemap中指定&lt;code&gt;umbrella header&lt;/code&gt;&lt;/p&gt;
 &lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;framework module STDemoUI &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    umbrella header &quot;STHeader.h&quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    export *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    module * &amp;#123; export * &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;在framework的&lt;code&gt;Build Settings&lt;/code&gt;中的&lt;code&gt;Module Map File&lt;/code&gt;指定新建的modulemap文件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;好了, 准备工作完毕, CMD+B, 编译完了, 打开framework包中的Module文件夹, 看是否包含了新指定的modulemap。&lt;/p&gt;
&lt;p&gt;抛出两个疑问: &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Module是什么?&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;Defines Module&lt;/code&gt;指定为&lt;code&gt;NO&lt;/code&gt;, 那会发生什么事情呢? &lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;题外话&quot;&gt;题外话&lt;/h3&gt;&lt;p&gt;这里我要引用官网Guidelins for Creating Frameworks的一个子标题&lt;strong&gt;Don’t Create Umbrella Frameworks&lt;/strong&gt;。原文如下:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;While it is possible to create umbrella frameworks using Xcode, doing so is unnecessary for most developers and is not recommended. Apple uses umbrella frameworks to mask some of the interdependencies between libraries in the operating system. In nearly all cases, you should be able to include your code in a single, standard framework bundle. Alternatively, if your code was sufficiently modular, you could create multiple frameworks, but in that case, the dependencies between modules would be minimal or nonexistent and should not warrant the creation of an umbrella for them&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在大多数情况下, 苹果是不建议手动创建Umbrella Framework。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;&lt;p&gt;本文简单的梳理了官方文章关于Umbrella Framework和Umbrella Header的介绍说明, 产生警告的原因是没有引用umbrella header或者暴露头没有写在umbrella header中。在umbrella header被已使用的前提下, 本文提供了一种通过重命名Umbrella Header文件的方式来消除警告的解决方案。&lt;/p&gt;
&lt;p&gt;虽然引用警告可以被消除, 但是建议大家还是采用规范的做法: 尽量不要在同名头文件中写业务逻辑代码, 用同名文件作为Umbrella库的Master Header File。&lt;/p&gt;
&lt;p&gt;水平有限, 有错误请大家及时指出哈~&lt;br&gt;转载请注明出处哦~&lt;/p&gt;
&lt;p&gt;参考文献:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/MacOSX/Conceptual/BPFrameworks/Frameworks.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://developer.apple.com/library/ios/documentation/MacOSX/Conceptual/BPFrameworks/Frameworks.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/32153131/renaming-umbrella-header/32153383#32153383&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://stackoverflow.com/questions/32153131/renaming-umbrella-header/32153383#32153383&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在相对较大的互联网App研发中, framework静态库被广泛应用, 那么在研发framework的时候也产生好多的问题? 其实一个常见的问题的就是umbreall header文件的使用。&lt;/p&gt;
&lt;p&gt;大家是否有遇到过一个常见的错误使用umbrella header的
    
    </summary>
    
    
      <category term="framework" scheme="http://startry.com/tags/framework/"/>
    
      <category term="ios" scheme="http://startry.com/tags/ios/"/>
    
      <category term="umbrella header" scheme="http://startry.com/tags/umbrella-header/"/>
    
  </entry>
  
  <entry>
    <title>iOS开发必备 - 环境变量配置(Debug &amp; Release)</title>
    <link href="http://startry.com/2015/07/24/iOS_EnvWithXcconfig/"/>
    <id>http://startry.com/2015/07/24/iOS_EnvWithXcconfig/</id>
    <published>2015-07-24T11:38:07.000Z</published>
    <updated>2015-08-25T01:47:17.000Z</updated>
    
    <content type="html">&lt;p&gt;本篇文章主要讲述了如何使用&lt;a href=&quot;https://developer.apple.com/library/ios/recipes/xcode_help-project_editor/Articles/BasingBuildConfigurationsonConfigurationFiles.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;(Xcode配置文件xcconfig)&lt;/a&gt;去动态配置开发或者生产网络环境, 以及在多项目和运行中如何切换环境。&lt;/p&gt;
&lt;p&gt;关于xcconfig文件, 目前在官方很难找到一篇专门的指南介绍, 但是国外有篇非官方指南&lt;a href=&quot;http://pewpewthespells.com/blog/xcconfig_guide.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《The Unofficial Guide to xcconfig files》&lt;/a&gt;详细的介绍了xcconfig。估计很多新入门的iOS开发对xcconfig文件都不是很熟悉, 但是大家可能都用过Cocoapods, 其实Cocoapods的项目配置管理很多都是依赖xcconfig文件去实现的。&lt;/p&gt;
&lt;h3 id=&quot;Debug宏应该在哪里定义?&quot;&gt;Debug宏应该在哪里定义?&lt;/h3&gt;&lt;p&gt;iOS系统本身就区分了Configurations选项让开发者去修改对应的开发环境配置, 但是因为很多开发者却又在同一个Configuration环境中自定义了开发环境配置的开发, 使得iOS系统本身的配置成为了摆设, &lt;em&gt;仅仅用于区分打包方式选项和证书配置&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;网络环境切换&lt;/strong&gt;是每一个互联网App开发者都会频繁用到的功能, 那么大家都是用什么样的方式在切换环境的呢?我本人接触的项目中最多的就是在预编译头文件里面写一行宏定义, 然后根据宏定义去判断当前的环境。&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;orange&quot;&gt;最典型的例子&lt;/font&gt;是在预编译头pch文件中添加一行代码&lt;code&gt;#define DEBUG 1&lt;/code&gt;。然后通过这个&lt;code&gt;DEBUG&lt;/code&gt;参数去判断当前环境是否处于开发网络或者生产网络环境。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;DEBUG&lt;/code&gt;宏去判断判断开发环境还是生产环境没有任何问题, 关键的问题是我们在什么时候去定义这个宏和怎么去动态配置这个宏。&lt;/p&gt;
&lt;h2 id=&quot;动态配置不同的网络开发环境&quot;&gt;动态配置不同的网络开发环境&lt;/h2&gt;&lt;p&gt;开发环境的切换在代码中最实用的还是宏定义, 那么我们怎么样才能够让宏定义&lt;font color=&quot;red&quot;&gt;动态&lt;/font&gt;可配置呢?&lt;br&gt;&lt;br&gt;其中一种办法就是使用GCC预编译头参数&lt;code&gt;GCC_PREPROCESSOR_DEFINITIONS&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;通常我们可以在Project文件下的Build Settings对预编译宏定义进行默认赋值。在Xcode6下的路径为&lt;code&gt;Build Settings&lt;/code&gt;-&amp;gt;&lt;code&gt;Apple LLVM 6.x Preprocessing&lt;/code&gt;-&amp;gt;&lt;code&gt;Preprocessor Macros&lt;/code&gt;&lt;br&gt;&lt;img src=&quot;http://blog.startry.com/img/blog_setting_pcm_demo.png&quot; alt=&quot;预编译Setting示例&quot;&gt;&lt;/p&gt;
&lt;p&gt;想必大家看这个宏的名字已经知道它的作用了, 实际上就是和在pch头文件中添加宏定义没有太大的区别, 实际上还是有一些好处:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Xcode的Project的Build Settings是由一个plist文件进行描述的, plist本质上是一个XML配置文件, 通过外部的脚本比较容易去修改。&lt;/li&gt;
&lt;li&gt;Preprocessor Macros可以按照Configuration选项进行默认配置, 也就是说可以根据不同的环境预先制定不同定义的宏&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;xcconfig配置Build_Settings&quot;&gt;xcconfig配置Build Settings&lt;/h5&gt;&lt;p&gt;Xcode Project的Build Settings属性有很多, 如果每一个属性都在配置项改过去比较麻烦, 而且容易忘记, 而且Build Settings用源码的打开可阅读性也不是很高, 这个时候, 我们可以使用xcconfig文件去配置Build Settings参数。&lt;/p&gt;
&lt;p&gt;xcconifg支持可以根据不同的Configuration选项配置不同的文件。不同的xcconfig可以指定不同的Build Settings里的属性值, 这样子我们就可以通过项目xcconifg去修改&lt;code&gt;GCC_PREPROCESSOR_DEFINITIONS&lt;/code&gt;的值了(最终目的就达到了)。&lt;/p&gt;
&lt;p&gt;利用xcconfig配置Build Settings的方式比直接在项目Build Settings修改对应的属性值要优雅的多, 英国的iOS大神&lt;a href=&quot;https://github.com/jspahrsummers&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Justin Spahr-Summers&lt;/a&gt;书写的开源库&lt;a href=&quot;https://github.com/jspahrsummers/xcconfigs&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;xcconfigs&lt;/a&gt;提供了一个类权威的模板, 大家可以参考编写以及学习使用xcconfig。&lt;/p&gt;
&lt;h3 id=&quot;Object-C下配置的支持&quot;&gt;Object-C下配置的支持&lt;/h3&gt;&lt;p&gt;在项目中的Info类目下, 大家可以配置Configuration对应的选项的xcconfig, 通过xcconfig来配置Build Setting中的参数(见下图)。&lt;br&gt;&lt;img src=&quot;http://blog.startry.com/img/blog_xcconfig_configurations.png&quot; alt=&quot;配置Configuration的各个xcconfig&quot;&gt;&lt;/p&gt;
&lt;p&gt;PS: 如果大家对Cocoapods比较熟悉的话, 你会发现其实Pods也是通过xcconfig文件去修改项目配置参数的。&lt;/p&gt;
&lt;h3 id=&quot;Swift下配置的支持&quot;&gt;Swift下配置的支持&lt;/h3&gt;&lt;p&gt;这里区分Object-C和Swift没有太大的意义。只不过因为C语言使用一些非常不安全的预处理器指令能力，Swift则只使用预处理器指令的安全子集。因此预编译头参数在Swift并不会生效, 需要增加&lt;code&gt;OTHER_SWIFT_FLAGS&lt;/code&gt;标记才能够将&lt;code&gt;Debug&lt;/code&gt;作用于Swift的条件式判断。标记书写方式参考下方示例:&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;OTHER_SWIFT_FLAGS = -D DEBUG&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;动态修改配置文件&quot;&gt;动态修改配置文件&lt;/h2&gt;&lt;p&gt;环境切换的标志位宏被提取到Build Setting中的&lt;code&gt;GCC_PROCESSOR_DEFINTIONS&lt;/code&gt;有什么好处呢?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;外部修改只需要修改工程的&lt;code&gt;project.pbxproj&lt;/code&gt;即可对&lt;code&gt;GCC_PROCESSOR_DEFINTIONS&lt;/code&gt;参数进行操作修改&lt;/li&gt;
&lt;li&gt;可以通过xcconfig去配置参数, 而配有xcconfig的Configuration可以通过&lt;code&gt;xcodebuild&lt;/code&gt;命令指定&lt;/li&gt;
&lt;li&gt;可以避免将最基础的Debug和Release网络环境切换书写在代码中&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;自动化脚本支持(便于自动化构建)&quot;&gt;自动化脚本支持(便于自动化构建)&lt;/h3&gt;&lt;p&gt;一个优秀的iOS工程师一定会使用自动化构建应用去解放自己的打包时间。&lt;a href=&quot;http://blog.startry.com/2015/06/23/iOS_CI_With_Jenkins/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《搭建自动化构建服务》&lt;/a&gt;讲述了如何搭建一个自动化构建程序, 可以作为参考。&lt;/p&gt;
&lt;p&gt;自动化构建的核心在于使用xcodebuild命令和各类脚本, 本文讲述2个场景:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;场景1: 环境变量由宏定义并且书写在项目的预编译头文件中或者在预编译头文件引用的&lt;code&gt;.h&lt;/code&gt;文件中; &lt;ul&gt;
&lt;li&gt;通过脚本动态替换行, 可以采用sed命令来替换, 最典型的实例如下:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sed -i &lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;s/^#define Debug 1/\/\/#define Debug 1/&#39;&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;./Demo/STSwitch.h&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;场景2: 环境变量由宏定义但是配置在&lt;code&gt;GCC_PREPROCESSOR_DEFINITIONS&lt;/code&gt;编译选项中。&lt;ul&gt;
&lt;li&gt;如果&lt;code&gt;GCC_PREPROCESSOR_DEFINITIONS&lt;/code&gt;由xcconfig文件指定并配置对应的Configuration中, 直接通过&lt;code&gt;xcodebuild&lt;/code&gt;命令指定&lt;code&gt;-configuration&lt;/code&gt;参数来选择。&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;GCC_PREPROCESSOR_DEFINITIONS&lt;/code&gt;需要在Build Settings中动态修改, 可以在Podfile中书写Hook代码或者用脚本解析配置文件进行动态修改。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Cocoapods下支持&quot;&gt;Cocoapods下支持&lt;/h3&gt;&lt;p&gt;如果大家对Cocoapods比较熟悉的话, 就会知道每次执行完&lt;code&gt;pod install&lt;/code&gt;之后, Cocoapods都会对每一个工程的Configuration配置一个xcconfig文件。&lt;/p&gt;
&lt;p&gt;默认情况下, 如果配置项已经存在了xcconfig文件, Cocoapods是不会将生产的xcconfig文件设置入配置项的。Cocoapods是通过xcconfig文件去修改外部链接依赖的, 因此如果没有正常替换配置文件, 有肯能会导致整个工程无法编译通过(缺少依赖库能通过才怪啦)。&lt;/p&gt;
&lt;p&gt;解决方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果自己修改的xcconfig文件内容&lt;strong&gt;不多&lt;/strong&gt;, 可以通过在Podfile中编写hook去实现修改对应的项目参数, 参考示例如下:&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;post_install &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; |installer|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    installer.pods_project.targets.each &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; |target|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        target.build_configurations.each &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; |config|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; config.name == &lt;span class=&quot;string&quot;&gt;&#39;Debug&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                config.build_settings[&lt;span class=&quot;string&quot;&gt;&#39;GCC_PREPROCESSOR_DEFINITIONS&#39;&lt;/span&gt;] = &lt;span class=&quot;string&quot;&gt;&#39;Debug=1&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;如果自己修改的xcconfig文件内容&lt;strong&gt;较多&lt;/strong&gt;, 可以在自己的编写的xcconfig include Cocoapods生产的xcconfig文件的方式进行处理, 参考示例如下:&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// 自定义的xcconfig (例如: st.debug)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#include &quot;../Pods.debug&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// 自定义的xcconfig (例如: st.release)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#include &quot;../Pods.release&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;多项目环境下支持&quot;&gt;多项目环境下支持&lt;/h3&gt;&lt;p&gt;多项目的环境配置往往是比较麻烦的, 比如有B、C、D三个子工程, A工程引用了B、C、D三个子工程。怎么把统一的环境变量怎么应用到A、B、C、D三个工程里呢?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;做法1: 建立一个公有引用的项目(无论Pods还是手动), 所有的项目均引用这个公有的项目, 公有的项目暴露一个头文件里面定义了所有的环境变量。&lt;/li&gt;
&lt;li&gt;做法2: 每一个项目均维护自己的初始值, 通过外部的脚本一次性修改所有项目的初始值保持统一。&lt;/li&gt;
&lt;li&gt;做法3: 每一个项目维护自己的初始值, 通过上文描述的GCC编译属性或者xcconfig控制, 通过脚本或者Podfile控制每一个项目初始值&lt;/li&gt;
&lt;li&gt;做法4: 每个项目的维护自己的初始值, 但是所有环境变量动态维护, 在主工程的AppDelegate中加载A项目的初始值并通过接口赋值给每一个子工程。(该方式宏定义智能作为初始值, 参考下文&lt;code&gt;动态切换配置&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;动态切换配置&quot;&gt;动态切换配置&lt;/h3&gt;&lt;p&gt;文章前面所述均少了一个关键字&lt;code&gt;初始值&lt;/code&gt;, 前面所添加的环境变量的方式都是在添加&lt;code&gt;初始环境变量常量&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;假设有一个运营或者测试需求, 需要能够用户自己去选择网络配置或者环境基础变量, 按照文章前面描述的方法, 是无法实现的。 因此, 上述的方式都只能提供一个初始默认值, 并无法在运行中去修改, 因为上述配置的方式都是通过&lt;strong&gt;预编译&lt;/strong&gt;去实现的。&lt;/p&gt;
&lt;p&gt;在App运行时切换环境, 那配置参数都不能简单的用宏或者常量来控制了, 需要讲环境配置参数存储在变量中, 通常是用&lt;code&gt;NSUserDefault&lt;/code&gt;或者&lt;code&gt;Singleton&lt;/code&gt;去维护环境变量集合。通过开发配置页面对维护的变量进行动态的修改。(建议在Debug模式下开启放置在系统的Setting界面下)&lt;/p&gt;
&lt;h2 id=&quot;另外一种选择&quot;&gt;另外一种选择&lt;/h2&gt;&lt;p&gt;除了通过宏初始化, 是否还有其它的读取配置文件的方式初始化呢?&lt;/p&gt;
&lt;p&gt;我们可以维护一个单例去管理所有的初始值, 在iOS应用开发中用属性值去管理开发环境和生产环境(坏处很明显, 控制力度没有&lt;code&gt;宏&lt;/code&gt;这么大)。&lt;/p&gt;
&lt;p&gt;资源文件加载其实就是把参数写在资源文件中, 然后通过代码在AppDelegate启动的时候去加载初始值到全局维护的单例中, 然后在工程中到处使用单例的实例变量去判断环境。&lt;/p&gt;
&lt;h3 id=&quot;Cocoapods-keys&quot;&gt;Cocoapods-keys&lt;/h3&gt;&lt;p&gt;通过配置加载环境配置环境变量是否能够做到工程依赖无关呢? 换言之就是在不同的安装目录或者不同的机器环境下配置不一样的环境变量, 让环境变量不与工程直接关联而与工程所在目录环境关联起来呢?&lt;/p&gt;
&lt;p&gt;做过服务端开发的童鞋们应该熟悉有一种config配置的方式, 让config在外部注入, 而不是在开发工程中写死, 即使写死也只是个初始值。&lt;/p&gt;
&lt;p&gt;Cocoapods提供了一款插件&lt;a href=&quot;https://github.com/orta/cocoapods-keys&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Cocoapods-keys&lt;/a&gt;, 提供了外部注入键值对的功能, 通过Cocoapods-keys插件, 我们可以在工程中调用外部注入的键值对, 通过外部的键值对工程进行一定力度的控制。&lt;/p&gt;
&lt;p&gt;Cocoapods-keys注入的键值对均存储在&lt;code&gt;~/.cocoapods/keys&lt;/code&gt;下, 是以yml的格式保存的, yml中描述了已经添加的键值对和对应项目路径。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;&lt;p&gt;文章想表达的核心思想是将环境切换初始化提取到配置文件处, 方便外部脚本修改(例如Podfile、自己写的Bash Shell等等)。在多项目环境下, 配置文件修改配置项更加容易可控, 防止多处修改代码或者使用脚本动态修改代码。&lt;/p&gt;
&lt;p&gt;文章的作用是给我本人备忘用的哈~ 水平有限, 有错误支持请大家及时指出哈~&lt;br&gt;转载请注明出处哦~&lt;/p&gt;
&lt;p&gt;参考文章:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://pewpewthespells.com/blog/xcconfig_guide.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://pewpewthespells.com/blog/xcconfig_guide.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/44c82630bd50&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/44c82630bd50&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章主要讲述了如何使用&lt;a href=&quot;https://developer.apple.com/library/ios/recipes/xcode_help-project_editor/Articles/BasingBuildConfigurationsonConfi
    
    </summary>
    
    
      <category term="ios" scheme="http://startry.com/tags/ios/"/>
    
      <category term="xcconfig" scheme="http://startry.com/tags/xcconfig/"/>
    
  </entry>
  
  <entry>
    <title>iOS开发必备 - 搭建自动化构建服务</title>
    <link href="http://startry.com/2015/06/23/iOS_CI_With_Jenkins/"/>
    <id>http://startry.com/2015/06/23/iOS_CI_With_Jenkins/</id>
    <published>2015-06-23T11:24:07.000Z</published>
    <updated>2015-08-12T02:07:09.000Z</updated>
    
    <content type="html">&lt;p&gt;本篇文章讲述了如何使用&lt;a href=&quot;https://jenkins-ci.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Jenkins&lt;/a&gt;搭建iOS的自动化构建环境。&lt;/p&gt;
&lt;p&gt;iOS自动化构建&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/xcode_guide-continuous_integration/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方有篇文章介绍Xcode持续集成&lt;/a&gt;, 是基于Xcode Server以及Xcode Bots去实现, 但是系统依赖和版本依赖过于严重, 并且需要在Xcode中配置Target的Shared属性, 耦合性太强, 因此不建议使用。&lt;/p&gt;
&lt;h2 id=&quot;为什么客户端需要自动化构建&quot;&gt;为什么客户端需要自动化构建&lt;/h2&gt;&lt;p&gt;个人觉得最主要的原因是需要&lt;em&gt;提高编码效率&lt;/em&gt;, 其次是&lt;em&gt;方便测试与集成&lt;/em&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;font size=&quot;4&quot;&gt;场景: 开发过程中, 不断的有产品或者测试介入, 需要你不定时的打包给他们提供体验与测试。&lt;/font&gt;&lt;br&gt;对于小工程来说, build一下可能就是几秒钟的事情, 但是对于大工程来说, 一次打包可能耗费5分钟乃至10分钟的开发时间。开发者一天中的有效开发时间是有限的, 在不断被打断的情况下, 开发者的产能实际上十分低效的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;font size=&quot;4&quot;&gt;场景: 联调过程中, 需要有第三方的SDK接入联调, 需要不断的为对方更改SDK, 然后重新编译打包。&lt;/font&gt;&lt;br&gt;这种场景一般发生在多个公司协作的时候, 本人在开发某二手车批发软件的时候, 就曾遇到与第三方支付平台接入联调的问题, 一天中80%时间为对方提供打包服务, 生产效能过低。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;font size=&quot;4&quot;&gt;场景: 用户预览&amp;amp;客户演示。&lt;/font&gt;&lt;br&gt;这个场景比较类似第一个场景, 不过是面向不专业的人事或者客户, 需要不定时更新版本然后提供&lt;em&gt;企业证书&lt;/em&gt;打包的预览版给老板和客户。严格意义上来说, 与第一个场景是同样一个场景。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;font size=&quot;4&quot;&gt;场景: 测试集成。&lt;/font&gt;&lt;br&gt;自动化构建和持续集成本来就是一码事, 如果你是个喜欢写集成测试的开发者, 那么在每一次打包编译的时候都要运行一次集成测试是很浪费时间的(PS: 集成测试不通过这个场景除外哦`)。将测试集成在构建步骤里面, 可以让自动化集成的所有行为在另外一台机器上工作, 工程师该干嘛还是干嘛去。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;还有其他很多应用场景, 不过我个人暂时为了上述目的而搭建CI环境。最主要的目的是解放打包时间, 防止开发工作被打断。&lt;/p&gt;
&lt;h2 id=&quot;准备工作&quot;&gt;准备工作&lt;/h2&gt;&lt;h3 id=&quot;硬件环境&quot;&gt;硬件环境&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;font size=&quot;4&quot;&gt;搭载Macintosh系统的一台硬件设备或虚拟机。&lt;/font&gt;&lt;br&gt;既然是编译&lt;em&gt;iOS&lt;/em&gt;应用, 那自然少不了苹果一系列的机器啦,  一台搭载Macintosh OS操作系统的电脑还是必须的, 目前本人采用的硬件方案是Mac mini。&lt;br&gt;需要Macintosh是因为Xcode运行环境在该系统上, 因此如果你想利用脚本编译iOS应用, 你就需要Xcode, 如果你需要Xcode, 那你又必须处于Macintosh OS环境(哎~ 苹果的生态链)。&lt;br&gt;鉴于目前国内的云服务器均为windows或者Linux, 您如果想用Geek的方式去搭建iOS的自动化构建方式, 可以尝试在云服务器上安装虚拟机然后运行Mac OS环境的方案。&lt;/li&gt;
&lt;li&gt;在准备做CI的机器上安装Java SDK环境 &amp;amp; Xcode。&lt;br&gt;Xcode可以用过App Store直接安装, Xcode体积非常大, 但是因为iOS编译脚本xcodebuile命令依赖于Xcode,因此Xcode是必须安装的。&lt;br&gt;Java运行环境是Jenkins需要, 因为Jenkins是基于Java实现的一套构建系统, Java SDK可以通过Oracle的官网去下载最新的适用版本, 在本文书写的时候, 最新的Java SDK是JDK8, 下载地址为 &lt;a href=&quot;http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;安装Jenkins&quot;&gt;安装Jenkins&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在Mac OS环境下, 建议采用Homebrew来安装, 获取Homebrew建议采用官网的方式。通过&lt;a href=&quot;http://brew.sh&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Homebrew官网&lt;/a&gt;获取homebrew后执行如下命令:&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ brew install jenkins&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;利用homebrew安装完毕后, 可以在终端执行&lt;code&gt;which jenkins&lt;/code&gt;查看是否已经安装成功。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;在终端执行&lt;code&gt;jenkins&lt;/code&gt;命令启动Jenkins(PS: 默认占用8080端口会导致启动失败), 此处有可能会出现Jenkins ssl证书过期的问题, 可以通过修改os系统时间, 调整为ssl支持的时间来解决, 否则安装Jenkins插件可能会失败。(jenkins命令依赖Java开发环境, 旧版本的Jenkins需要自己去配置bash alias)&lt;/li&gt;
&lt;li&gt;打开浏览器, 访问&lt;a href=&quot;http://localhost:8080&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://localhost:8080&lt;/a&gt;, 查看Jenkins是否正常启动(默认端口8080)。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;配置工作&quot;&gt;配置工作&lt;/h2&gt;&lt;h3 id=&quot;Jenkins插件配置&quot;&gt;Jenkins插件配置&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://blog.startry.com/img/blog_jenkins.png&quot; alt=&quot;Jenkins项目&quot;&gt;&lt;/p&gt;
&lt;p&gt;Jenkins是个生态比较完善的自动化构建系统, 提供了各种的可扩展插件给用户下载, 同时又开放接口, 让大家自主开发对应的插件。插件管理路径是&lt;code&gt;系统管理&lt;/code&gt;-&amp;gt;&lt;code&gt;管理插件&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;插件索引默认并不是最新的, 需要大家手动更新, 在&lt;code&gt;管理插件&lt;/code&gt;-&amp;gt;&lt;code&gt;可选插件&lt;/code&gt;的右下角有个&lt;code&gt;立即获取&lt;/code&gt;按钮, 点击即可获取最新的插件索引。&lt;/p&gt;
&lt;p&gt;PS: &lt;font color=&quot;red&quot;&gt;有时候官方索引的地址ssl证书过期导致索引会更新失败, 大家可以通过浏览器调试获取证书到期时间, 然后将本机时间调整为过期以前的时间即可解决该问题。&lt;/font&gt;(apache有时候也不靠谱啊。。)&lt;/p&gt;
&lt;p&gt;每个开发者根据不同的业务场景需要用到不同的插件, 本文就不在这里赘述, 大家自由发挥吧。&lt;/p&gt;
&lt;h3 id=&quot;Jenkins账户权限配置&quot;&gt;Jenkins账户权限配置&lt;/h3&gt;&lt;p&gt;Jenkins用户权限配置和本文主题无关, 主要是方便大家对Jenkins用户进行访问控制。可以参考文章”&lt;a href=&quot;http://my.oschina.net/donhui/blog/424980&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Jenkins安全配置/访问控制/审计&lt;/a&gt;“或文章”&lt;a href=&quot;http://bookong.iteye.com/blog/1964182&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Jenkins使用经验谈5(用户的登录与权限设定等)&lt;/a&gt;“进行配置。&lt;/p&gt;
&lt;p&gt;我个人是比较喜欢采用安全域里的&lt;code&gt;Jenkins专有用户数据库&lt;/code&gt;进行配置, 因为自带的比较方便, 而且在不复杂的企业环境里面已经够用, 负责的企业环境就另当别论了。大致流程如下:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在Jenkins页面上注册一个新用户(当然可以导入)&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;系统管理&lt;/code&gt;-&amp;gt;&lt;code&gt;Configure Global Security&lt;/code&gt;里的授权策略进行定向配置, 个人偏好采用&lt;code&gt;项目矩阵授权策略&lt;/code&gt;进行管理。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;项目&amp;amp;脚本配置&quot;&gt;项目&amp;amp;脚本配置&lt;/h3&gt;&lt;p&gt;本文重点是如何自动化编译iOS项目, 这个其实大家应该很熟悉了, 就是利用&lt;code&gt;xcodebuild&lt;/code&gt;命令和&lt;code&gt;xcrun&lt;/code&gt;组合进行脚本编译和签名。编译脚本的编写本质上不缺分环境(Jenkins服务器环境or本机环境), 因此我们需要确保本机环境的脚本能够正常的工作, 个人偏好使用bash环境(因为不用安装其它的依赖), 然后使用下述的模板进行填空。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;shebang&quot;&gt;#!/bin/bash&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;projAbbr=&lt;span class=&quot;string&quot;&gt;&#39;iOS_Bash_Build_Demo&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;autoBuild&lt;/span&gt;&lt;/span&gt;()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	prepareBuildEnv&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	updatePodsDeps&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	clearProjs&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	buildProjs&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	signProjs&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	uploadAppFile&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;$&amp;#123;projAbbr&amp;#125;&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;- ALL Action Completed!&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;prepareBuildEnv&lt;/span&gt;&lt;/span&gt;()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;# TODO - 执行编译器准备工作, 可以调整项目配置等执行任务&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;# eg: mkdir xxx&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;updatePodsDeps&lt;/span&gt;&lt;/span&gt;()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;# TODO - 更新Pod依赖&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;# eg: pod install &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;clearProjs&lt;/span&gt;&lt;/span&gt;()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;# TODO - clean项目&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;# eg: xcodebuild -workspace &quot;demo.xcworkspace&quot;  -scheme &quot;targetName&quot;  -configuration &#39;Release Adhoc&#39; clean&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;buildProjs&lt;/span&gt;&lt;/span&gt;()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;# TODO - 编译项目, 生产带证书签名的App文件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;# eg: xcodebuild -workspace &quot;demo.xcworkspace&quot; -sdk iphoneos -scheme &quot;targetName&quot; -configuration &#39;Release Adhoc&#39; SYMROOT=&#39;$(PWD)&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;# eg: xcodebuild -workspace &quot;demo.xcworkspace&quot; -sdk iphoneos -scheme &quot;targetName&quot; -configuration &#39;Release Adhoc&#39; CODE_SIGN_IDENTITY=&quot;keychain中证书代号名称&quot; SYMROOT=&#39;$(PWD)&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;signProjs&lt;/span&gt;&lt;/span&gt;()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;# TODO - 填充签名脚本, 用于签名编译到的App, 打包成ipa文件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;# eg: xcrun -sdk iphoneos PackageApplication -v &quot;demo.app&quot; -o &quot;demo.ipa&quot; &amp;gt; $logPath&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;uploadAppFile&lt;/span&gt;&lt;/span&gt;()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;# TODO - 上传App文件到发布平台&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;# 蒲公英、Fir.im都是不错的选择哦&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 如果使用第三方平台, 一般不需要createPlist, 因为第三方平台都已经集成&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;createPlist&lt;/span&gt;&lt;/span&gt;()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;# TODO - 创建Plist文件, 用于企业证书下载&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;autoBuild&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上述脚本将编译步骤拆分为&lt;code&gt;准备环境&lt;/code&gt;、&lt;code&gt;更新Cocoapods&lt;/code&gt;、&lt;code&gt;clean项目&lt;/code&gt;、&lt;code&gt;build项目&lt;/code&gt;、&lt;code&gt;签名项目&lt;/code&gt;和&lt;code&gt;上传ipa文件&lt;/code&gt;六大步骤。脚本的每一个步骤其实都可以在Jenkins需找对应的插件进行图形化控制, 但是我本人喜欢编写脚本来轻量化Jenkins的依赖, 除非需要本地上传一些依赖配置的文件。&lt;/p&gt;
&lt;p&gt;上述脚本的执行任务也可以通过组合&lt;code&gt;CocoaPods Jenkins Integration&lt;/code&gt;插件、&lt;code&gt;Xcode integration&lt;/code&gt;插件以及其他上传插件进行组合。但是我并不太喜欢过渡依赖Jenkins的图形界面, 因此并没有深度整合这两个插件。&lt;/p&gt;
&lt;font style=&quot;bold&quot; color=&quot;black&quot;&gt;脚本的核心代码注释在代码里的eg, xcodebuild命令进行clean以及build, 然后通过xcrun进行签名app生成ipa文件&lt;/font&gt;

&lt;p&gt;clean清理脚本示例:&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;xcodebuild -workspace &lt;span class=&quot;string&quot;&gt;&quot;demo.xcworkspace&quot;&lt;/span&gt;  -scheme &lt;span class=&quot;string&quot;&gt;&quot;targetName&quot;&lt;/span&gt;  -configuration &lt;span class=&quot;string&quot;&gt;&#39;Release Adhoc&#39;&lt;/span&gt; clean&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;build编译脚本示例:&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;xcodebuild -workspace &lt;span class=&quot;string&quot;&gt;&quot;demo.xcworkspace&quot;&lt;/span&gt; -sdk iphoneos -scheme &lt;span class=&quot;string&quot;&gt;&quot;targetName&quot;&lt;/span&gt; -configuration &lt;span class=&quot;string&quot;&gt;&#39;Release Adhoc&#39;&lt;/span&gt; CODE_SIGN_IDENTITY=&lt;span class=&quot;string&quot;&gt;&quot;keychain中证书代号名称&quot;&lt;/span&gt; SYMROOT=&lt;span class=&quot;string&quot;&gt;&#39;$(PWD)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;xcodebuild是Xcode Command Tool工具集里的一个命令, 可以通过&lt;code&gt;-workspace&lt;/code&gt;指定固定的xcode工作空间或者通过&lt;code&gt;-project&lt;/code&gt;指定固定的xcode项目。详细的参数可以参考&lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man1/xcodebuild.1.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;sign签名脚本示例:&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;xcrun -sdk iphoneos PackageApplication -v &lt;span class=&quot;string&quot;&gt;&quot;demo.app&quot;&lt;/span&gt; -o &lt;span class=&quot;string&quot;&gt;&quot;demo.ipa&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;xcrun命令可以将app文件打包成ipa文件, 主要依赖xcodebuild命令中指定的证书, 如果没有有效证书的话, 只能在越狱的环境中安装ipa。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;大家可以尝试填充这个脚本, 来进行本地编译, 如果本地编译不通过, 那放在Jenkins上是肯定通过不了的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;具体的脚本内容每个人各不相同, Github上有个叫&lt;strong&gt;BashShell&lt;/strong&gt;的项目里包含一个脚本示例&lt;a href=&quot;https://github.com/heyuan110&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;build_install.sh&lt;/a&gt;, 该项目作者编写的脚本非常详细, 大家可以参考编写。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;xcodebuild命令可以指定对应的签名文件, 可以通过预先上传签名文件到编译服务器的keychains中或者将证书存放于代码托管库中方便指定。&lt;/li&gt;
&lt;li&gt;通过Jenkins执行的脚本会默认注入一些全局环境变量, 例如&lt;code&gt;${PWD}&lt;/code&gt;、&lt;code&gt;${CHANGES}&lt;/code&gt;等等。通过这些全局参数可以在执行脚本或者邮件等任务中打印动态数据。&lt;/li&gt;
&lt;li&gt;Jenkins默认将返回值&lt;strong&gt;-1&lt;/strong&gt;作为失败条件, 因此如果需要主动在脚本终止任务, &lt;code&gt;return -1&lt;/code&gt;就可以触发Jenkins任务失败了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;好了, 准备工作已经差不多了, 可以先将自己的脚本本地测试下了哦~ 编译通过了就可以开始配置Jenkins任务啦~&lt;/p&gt;
&lt;h2 id=&quot;开始自动化之旅&quot;&gt;开始自动化之旅&lt;/h2&gt;&lt;h3 id=&quot;新建任务&quot;&gt;新建任务&lt;/h3&gt;&lt;p&gt;编译脚本、编译环境都准备好, Jenkins也正常运行了, 接下来就是创建Jenkins任务了。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过&lt;code&gt;新建&lt;/code&gt;构建一个自由风格的软件项目。(同一个分支不同的任务也需要建立多个不同的Job, 每一个Job在服务器Home目录下的.jenkins文件夹下面会创建一个独立的job和workspace)&lt;/li&gt;
&lt;li&gt;在配置界面配置对应的&lt;code&gt;源码管理&lt;/code&gt;, 现在国内大部分开发者的开发项目应该依托于&lt;code&gt;gitlab&lt;/code&gt;的吧。(gitlab需要制定对应的版本号)&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设定自动执行循环时间: 在&lt;code&gt;构建触发器&lt;/code&gt;勾选&lt;code&gt;Poll SCM&lt;/code&gt;, 可以通过特定的表达式进行触发设定。点击输入框后方问号会提示触发表达式的规则与书写方式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;例如12小时检查一次源码库更新可以表达如下:&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;H H/&lt;span class=&quot;number&quot;&gt;12&lt;/span&gt; * * *&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;例如30分钟检查一次源码库更新可以表达如下:&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;H/&lt;span class=&quot;number&quot;&gt;30&lt;/span&gt; * * * *&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在&lt;code&gt;构建&lt;/code&gt;栏点击&lt;code&gt;增加构建步骤&lt;/code&gt;, 选择&lt;code&gt;Execute Shell&lt;/code&gt;, 在Command栏里面执行预先保存的脚本文件。假如默认保存在项目根目录下的脚本文件名为jenkins.sh, 则输入如下代码:&lt;/p&gt;
 &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sh jenkins.sh&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;PS: 此处如果使用图形插件的同学们, 可以在这里添加对应的插件。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;构建后任务可以添加邮件提醒以及上传FTP等执行动作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;自动发送邮件&quot;&gt;自动发送邮件&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;Jenkins默认提供了编译错误时候的自动邮件发送功能。 简易邮件功能需要在&lt;code&gt;系统管理&lt;/code&gt;中的&lt;code&gt;系统设置&lt;/code&gt;中的&lt;code&gt;邮件通知&lt;/code&gt;栏进行设置。设置了邮件通知全局配置后, 在Jenkins Job配置的&lt;code&gt;增加构建后步骤&lt;/code&gt;中可以配置简易的邮件通知, 简易版本的邮件通知仅仅支持在系统不稳定的时候通知相关的责任人与固定的邮件接收者。&lt;/li&gt;
&lt;li&gt;Email Extension Plugin: Jenkins一个很强大的邮件系统, 可以配置各种各样的邮件内容, 也可以定制不同的触发条件以及接受者。配置使用可以参考其他博文, 例如这篇&lt;a href=&quot;http://p.primeton.com/articles/54c1d470be20aa1bf9000066&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《Jenkins中配置ESB构建后自动发邮件》&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;自动化测试&quot;&gt;自动化测试&lt;/h3&gt;&lt;p&gt;自动化测试可以参考构建脚本的使用方式, 单独书写shell任务去执行对应的测试任务, 也可以在构建脚本中提前穿插测试任务。本文中自动化测试并不是重点, 再这里不讨论, 后期更新相关内容。&lt;/p&gt;
&lt;h3 id=&quot;自动上传&quot;&gt;自动上传&lt;/h3&gt;&lt;p&gt;自动化的最后一步就是提供方便的下载地址给需要安装App的测试体验人员。需要一个平台提供一个方便苹果app下载的平台, 目前市面上以&lt;a href=&quot;http://fir.im&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;fir.im&lt;/a&gt;以及&lt;a href=&quot;http://www.pgyer.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;蒲公英&lt;/a&gt;使用率最广。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;第三方平台: 以&lt;code&gt;fir.im&lt;/code&gt;为例子, fir.im平台集成了ipa文件下载所需要plist文件以及一张优美的下载页。ipa文件第一次需要自己上传产生一个对应url地址。因为该平台本身依赖于七牛云存储, 因此使用该平台的上传脚本可以使用七牛的&lt;code&gt;qrsync&lt;/code&gt;脚本实现, 具体怎么上传请参考fir.im的&lt;a href=&quot;http://fir.im/docs&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方指南文档&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;自建平台: 自建平台比较麻烦, 需要产生对应的plist文件以及下载页面, 但是在很多高保密的企业下是不允许使用第三方平台的, 个人建议为公司搭建一个简易版本的fir.im, 方便以后使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构建平台主要是承担的工作是企业证书下载环境的搭建以及历史版本的维护。企业证书下载环境最关键的部分是plist描述文件的生产以及https服务的支持&lt;strong&gt;(iOS7以后的items-service服务需要ssl且不接受伪造证书)&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;Bryce Zhange的博文里面有一篇教大家使用Apache和PHP搭建一个服务器的博文&lt;a href=&quot;http://www.cnblogs.com/brycezhang/p/4097487.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《iOS自动化编译》&lt;/a&gt;, 大家可以参考。该博文包含了如何使用Bruce(heyuan110)的编译脚本以及如何采用&lt;code&gt;cat&lt;/code&gt;&amp;amp;&lt;code&gt;EOF&lt;/code&gt;&amp;amp;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;去动态生成plist文件。&lt;br&gt;&lt;br&gt;PS: 个人不建议采用Apache搭建服务器, 可以试试Ngnix~ 其实最好是不要自己搭建了~&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;&lt;p&gt;本文主要是总结了我个人喜爱的方式, 使用Jenkins+Bash脚本在Mac OS X环境下搭建一个自动化构建环境。通过自动化构建环境来将自己从体验人员和测试人员不断要求安装包的麻烦中解放出来专心编写工程代码。Bash主要在于&lt;code&gt;xcodebuild&lt;/code&gt;和&lt;code&gt;xcrun&lt;/code&gt;命令的使用, 以及提供了本人比较爱好的一套模板方便大家快速编写。Jenkins主要用于定时轮询代码和邮件通知。&lt;/p&gt;
&lt;p&gt;文章的作用是给我本人备忘用的哈~ 水平有限, 有错误之处请大家及时指出哈~&lt;/p&gt;
&lt;h5 id=&quot;参考文献:&quot;&gt;参考文献:&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://p.primeton.com/articles/54c1d470be20aa1bf9000066&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://p.primeton.com/articles/54c1d470be20aa1bf9000066&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/brycezhang/p/4097487.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/brycezhang/p/4097487.html&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章讲述了如何使用&lt;a href=&quot;https://jenkins-ci.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Jenkins&lt;/a&gt;搭建iOS的自动化构建环境。&lt;/p&gt;
&lt;p&gt;iOS自动化构建&lt;a href=&quot;https://dev
    
    </summary>
    
    
      <category term="Jenkins" scheme="http://startry.com/tags/Jenkins/"/>
    
      <category term="ios" scheme="http://startry.com/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://startry.com/2015/06/09/hello-world/"/>
    <id>http://startry.com/2015/06/09/hello-world/</id>
    <published>2015-06-09T14:19:45.000Z</published>
    <updated>2015-06-09T14:19:45.000Z</updated>
    
    <content type="html">&lt;p&gt;Welcome to &lt;a href=&quot;http://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;http://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;http://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick_Start&quot;&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create_a_new_post&quot;&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;http://hexo.io/docs/writing.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Writing&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Run_server&quot;&gt;Run server&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo server&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;http://hexo.io/docs/server.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Server&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Generate_static_files&quot;&gt;Generate static files&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo generate&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;http://hexo.io/docs/generating.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Generating&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Deploy_to_remote_sites&quot;&gt;Deploy to remote sites&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo deploy&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;http://hexo.io/docs/deployment.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Deployment&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;http://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;http://hexo.io
    
    </summary>
    
    
  </entry>
  
</feed>
