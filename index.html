<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Startry Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Startry Blog">
<meta property="og:url" content="http://startry.com/index.html">
<meta property="og:site_name" content="Startry Blog">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Startry Blog">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="Startry Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <script src="http://libs.baidu.com/jquery/1.9.0/jquery.js"></script>
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="https://avatars2.githubusercontent.com/u/3454027?v=3&amp;s=460" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Startry</a></h1>
		</hgroup>

		
		<p class="header-subtitle">随便乱写</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="http://github.com/startry" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/chenxingstartry" title="weibo">weibo</a>
					        
								<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/startry" title="zhihu">zhihu</a>
					        
								<a class="mail" target="_blank" href="mailto:chenxingfl#gmail.com" title="mail">mail</a>
					        
								<a class="twitter" target="_blank" href="https://twitter.com/xStartry" title="twitter">twitter</a>
					        
								<a class="stackoverflow" target="_blank" href="http://stackoverflow.com/users/5238614/startry" title="stackoverflow">stackoverflow</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/CocoaPods/" style="font-size: 10px;">CocoaPods</a> <a href="/tags/Jenkins/" style="font-size: 10px;">Jenkins</a> <a href="/tags/Ruby/" style="font-size: 10px;">Ruby</a> <a href="/tags/framework/" style="font-size: 10px;">framework</a> <a href="/tags/iOS/" style="font-size: 10px;">iOS</a> <a href="/tags/ios/" style="font-size: 20px;">ios</a> <a href="/tags/umbrella-header/" style="font-size: 10px;">umbrella header</a> <a href="/tags/xcconfig/" style="font-size: 15px;">xcconfig</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://github.com/startry">空荡荡的github</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">思考中...</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Startry</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="https://avatars2.githubusercontent.com/u/3454027?v=3&amp;s=460" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">Startry</h1>
			</hgroup>
			
			<p class="header-subtitle">随便乱写</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="http://github.com/startry" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/chenxingstartry" title="weibo">weibo</a>
			        
						<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/startry" title="zhihu">zhihu</a>
			        
						<a class="mail" target="_blank" href="mailto:chenxingfl#gmail.com" title="mail">mail</a>
			        
						<a class="twitter" target="_blank" href="https://twitter.com/xStartry" title="twitter">twitter</a>
			        
						<a class="stackoverflow" target="_blank" href="http://stackoverflow.com/users/5238614/startry" title="stackoverflow">stackoverflow</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-Something-about-Pod-Install-And-Pod-Update" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/24/Something-about-Pod-Install-And-Pod-Update/" class="article-date">
  	<time datetime="2015-09-24T12:11:19.000Z" itemprop="datePublished">2015-09-24</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/24/Something-about-Pod-Install-And-Pod-Update/">pod install和pod update背后那点事</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Cocoapods对于绝大部分的iOS开发者们应该不陌生吧~ 如果你不知道什么是CocoaPods, 请移步<a href="https://guides.cocoapods.org/" target="_blank" rel="external">CocoaPods的官方Guide</a>去学习使用指南哇~ </p>
<p><code>pod install</code>和<code>pod update</code>应该大部分iOS以及OSX开发者最常用的两个命令了, 那么大家是否都知道<code>pod install</code>或<code>pod update</code>在执行中主要做了哪些事情呢? 我们来一起探究一下呗~</p>
<h2 id="初步窥探">初步窥探</h2><p>通过CoocaPods的终端log输出, 我们也可以推测出<code>pod install</code>的大致行为, 如果需要更多的信息, 可以使用<code>--verbose</code>参数输出更多的信息, 被提炼后大致输出log如下:</p>
<ol>
<li><code>Updating local specs repositories</code> - 更新本地Spec索引</li>
<li><code>CocoaPods xxx is available.</code> - 新版本试用提示</li>
<li><code>Analyzing dependencies</code> - 分析依赖</li>
<li><code>Downloading dependencies</code> - 下载依赖库</li>
<li><code>Generating Pods project</code> - 生成Pods项目</li>
<li><code>Integrating client project</code> - 整合项目</li>
</ol>
<h2 id="深入窥探">深入窥探</h2><p>其实呢… 深入了解那自然最好看源码啦~ 问题是怎么跟踪去跟踪源码和学习源码… 我写这篇文章的时候CocoaPods最新的Tag是<a href="https://github.com/CocoaPods/CocoaPods/tree/0.39.0.beta.4" target="_blank" rel="external">0.39.0.beta.4</a>, 那我基于该tag来进行源码分析和追踪。</p>
<p>我们想要了解两个命令<code>pod install</code>和<code>pod update</code>, 我们可以从命令行入口进行跟踪学习。现在我们以<code>pod install</code>最为学习入口进行跟踪。</p>
<p>我们可以用终端自带的<code>which</code>命令去跟踪<code>pod</code>命名源码文件所在地作为跟踪入口。执行命令可以发现pod命令原来放置在用户目录下的<code>.rvm</code>隐藏目录下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">which</span> pod</span><br><span class="line"><span class="comment"># output: /Users/[UserName]/.rvm/gems/ruby-2.2.1/bin/pod</span></span><br></pre></td></tr></table></figure>
<p>使用文本编辑器打开<code>pod</code>脚本文件, 我们可以发现如下代码:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load <span class="constant">Gem</span>.bin_path(<span class="string">'cocoapods'</span>, <span class="string">'pod'</span>, version)</span><br></pre></td></tr></table></figure>
<p>=。= 这脚本只是负责加载一个在源码目录<code>bin</code>下面的<code>pod</code>文件, 那么我们继续跟踪源码<code>bin</code>下面的<code>pod</code>文件。不多说, 赶紧进入<a href="https://github.com/CocoaPods/CocoaPods" target="_blank" rel="external">CocoaPods项目地址</a>拉源代码了。</p>
<p>源码的下的<code>pod</code>文件做了一些环境变量的条件控制, 主要是区分<code>COCOAPODS_NO_BUNDLER</code>和<code>PROFILE</code>环境变量, 这些不是本文的关键, 直接找<a href="https://github.com/CocoaPods/CocoaPods/blob/0.39.0.beta.4/bin/pod#L44" target="_blank" rel="external">核心代码</a>:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="constant">Pod::Command</span>.run(<span class="constant">ARGV</span>)</span><br></pre></td></tr></table></figure>
<p>看到这个。。又要继续去跟踪Command的类了, ARGV是前面脚本传进来的参数。<a href="https://github.com/CocoaPods/CocoaPods/blob/0.39.0.beta.4/lib/cocoapods/command.rb" target="_blank" rel="external">Command</a>类在<code>lib/cocoapods/command.rb</code>下。</p>
<p>在Command类下找到初始化函数入口<a href="https://github.com/CocoaPods/CocoaPods/blob/0.39.0.beta.4/lib/cocoapods/command.rb#L44" target="_blank" rel="external">run</a>方法。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Command</span> <span class="inheritance">&lt; <span class="parent">CLAide::Command</span></span></span></span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> </span><span class="keyword">self</span>.run(argv)</span><br><span class="line">    help! <span class="string">'You cannot run CocoaPods as root.'</span> <span class="keyword">if</span> <span class="constant">Process</span>.uid == <span class="number">0</span></span><br><span class="line">    verify_xcode_license_approved!</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>(argv)</span><br><span class="line">  <span class="keyword">ensure</span></span><br><span class="line">    <span class="constant">UI</span>.print_warnings</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>在Command类的<code>run</code>方法里, 我们可以看到主要是进行了非root用户检验以及验证xcode使用协议是否已经同意, 然后执行了父类的run方法。什么? 父类? Command的父类是CLAide下的Command类, CLAide可是CoocoaPods依赖的另外一个项目啊… 不多说了, 乖乖去拉<a href="https://github.com/CocoaPods/CLAide" target="_blank" rel="external">CLAide项目</a>的源代码。</p>
<p>因为前面的CocoaPods主库是基于tag 0.39.0.bete.4分析的, 那么我们要该库对应使用CLAide的Tag分支。在CocoaPods的<a href="https://github.com/CocoaPods/CocoaPods/blob/0.39.0.beta.4/cocoapods.gemspec#L31" target="_blank" rel="external">cocoapods.gemspec</a>中有所有CocoaPods依赖的项目的制定版本信息, 通过查看该文件我们可以定位对应的CLAide项目使用版本是0.9.1。</p>
<p>找到CLAide项目下的Command类的<a href="https://github.com/CocoaPods/CLAide/blob/0.9.1/lib/claide/command.rb#L302" target="_blank" rel="external">run</a>方法:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> </span><span class="keyword">self</span>.run(argv = [])</span><br><span class="line">  plugin_prefixes.each <span class="keyword">do</span> |plugin_prefix|</span><br><span class="line">    <span class="constant">PluginManager</span>.load_plugins(plugin_prefix)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">      </span><br><span class="line">  argv = <span class="constant">ARGV</span>.coerce(argv)</span><br><span class="line">  command = parse(argv)</span><br><span class="line">  <span class="constant">ANSI</span>.disabled = !command.ansi_output?</span><br><span class="line">  <span class="keyword">unless</span> command.handle_root_options(argv)</span><br><span class="line">    command.validate!</span><br><span class="line">    command.run</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">rescue</span> <span class="constant">Object</span> =&gt; exception</span><br><span class="line">    handle_exception(command, exception)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>我们可以发现此处主要任务是根据插件前缀预加载插件到管理器中, 通过<a href="https://github.com/CocoaPods/CLAide/blob/0.9.1/lib/claide/argv.rb#L14" target="_blank" rel="external">ARGV类</a>去转换生产一个参数对象, 然后通过参数对象放置转换函数中转换成为一个实际Command类并执行。</p>
<p>我们跟踪Command类中的<a href="https://github.com/CocoaPods/CLAide/blob/0.9.1/lib/claide/command.rb#L325" target="_blank" rel="external">parse</a>方法, 可以发现parse方法取了参数中的第一个参数去调用[find_subcommand], 即用<code>`install</code>去匹配command的名字, <a href="https://github.com/CocoaPods/CLAide/blob/0.9.1/lib/claide/command.rb#L139" target="_blank" rel="external">command属性的定义</a>中描述如下:</p>
<blockquote>
<p> @return [String] The name of the command. Defaults to a snake-cased <br></p>
</blockquote>
<p>那么接下来的任务就是寻找类名为install子类的run方法了。赶紧在CoocaPods主工程中搜索install.rb这个文件，额。。没有找到。。这个源码跟踪的就断线了, 莫非一定要用<strong>Debug</strong>的方式去跟踪? </p>
<p>既然直接搜名字不行, 那就试试用别的途径, 从前面的跟踪推测Install总得是个Command的子类吧, 那我们尝试用<code>Install &lt; Command</code>去搜索。Pingo!! Install类果然被我们找到了, 藏在了project.rb文件下, 原来CocoaPods的开发者们把Install和Update类都放置在了project.rb中了。不多说，继续上代码:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Install</span> <span class="inheritance">&lt; <span class="parent">Command</span></span></span></span><br><span class="line">  <span class="keyword">include</span> <span class="constant">Project</span></span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> </span>run</span><br><span class="line">    verify_podfile_exists!</span><br><span class="line">    run_install_with_update(<span class="keyword">false</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>Install类的<a href="https://github.com/CocoaPods/CocoaPods/blob/0.39.0.beta.4/lib/cocoapods/command/project.rb#L99" target="_blank" rel="external">run</a>方法终于进入到了前面初探的执行步骤了哇, 前面这么一大堆行为都是为了处理命令哇。</p>
<p>到这里我们可以猜想一下Update类的run方法是否就是在调用<code>run_install_with_update</code>方法时候传入参数的不同呢? 哈哈, 其实不是, Update类的<a href="https://github.com/CocoaPods/CocoaPods/blob/0.39.0.beta.4/lib/cocoapods/command/project.rb#L130" target="_blank" rel="external">run</a>方法还要检查是否所有的pods都被install过了, 如果没有的话会主动抛错, 检查通过的才会调用<code>run_install_with_update</code>方法。</p>
<p><code>verify_podfile_exists</code>在这里就不做赘述, 我们直接进入<a href="https://github.com/CocoaPods/CocoaPods/blob/0.39.0.beta.4/lib/cocoapods/command/project.rb#L68" target="_blank" rel="external"><code>run_install_with_update</code></a>方法。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> </span>run_install_with_update(update)</span><br><span class="line">  installer = <span class="constant">Installer</span>.new(config.sandbox, config.podfile, config.lockfile)</span><br><span class="line">  installer.update = update</span><br><span class="line">  installer.install!</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这个大家可能会有个困惑: config是什么时候加载的呢? 这个大家可以自己去发掘喔~ 不然本文就要改名为CocoaPods源码分析之一二三四了。</p>
<p><code>run_install_with_update</code>的核心代码是调用了Installer类的<a href="https://github.com/CocoaPods/CocoaPods/blob/0.39.0.beta.4/lib/cocoapods/installer.rb#L103" target="_blank" rel="external">install</a>方法, 继续贴代码:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> </span>install!</span><br><span class="line">  prepare</span><br><span class="line">  resolve_dependencies</span><br><span class="line">  download_dependencies</span><br><span class="line">  determine_dependency_product_types</span><br><span class="line">  verify_no_duplicate_framework_names</span><br><span class="line">  verify_no_static_framework_transitive_dependencies</span><br><span class="line">  verify_framework_usage</span><br><span class="line">  generate_pods_project</span><br><span class="line">  integrate_user_project <span class="keyword">if</span> config.integrate_targets?</span><br><span class="line">  perform_post_install_actions</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>哇塞, 我要找所有东西都几乎全列在这个方法里了, 大致的行为动作如下哈, 我会每一个都粗略的介绍一番。</p>
<h2 id="背后那点事">背后那点事</h2><p>通过签名的代码跟踪，我们可以总结出<code>pod install</code>命令背后执行了这么十件大事:</p>
<ol>
<li><strong>准备工作</strong></li>
<li><strong>查找依赖库</strong></li>
<li><strong>下载依赖库</strong></li>
<li><strong>决定依赖库的类型</strong></li>
<li><strong>验证没有重名的framework</strong></li>
<li><strong>验证静态库的传递依赖</strong></li>
<li><strong>验证framwoke的使用</strong></li>
<li><strong>生成工程</strong></li>
<li><strong>整合用户项目</strong></li>
<li><strong>执行install后的行为</strong></li>
</ol>
<h3 id="准备工作">准备工作</h3><p>准备工作<a href="https://github.com/CocoaPods/CocoaPods/blob/0.39.0.beta.4/lib/cocoapods/installer.rb#L116" target="_blank" rel="external">(<code>prepare</code>)</a>主要做了以下事情:</p>
<ol>
<li>沙盒的准备 - 一些文件以及目录的删除以及创建</li>
<li>确保Podfile指定的插件都已经安装(不然抛错)</li>
<li>迁移沙盒中部分文件(区分Pods版本迁移地址不同)</li>
<li>执行pre_install的Hook</li>
</ol>
<h3 id="查找依赖库">查找依赖库</h3><p>查找依赖库<a href="https://github.com/CocoaPods/CocoaPods/blob/0.39.0.beta.4/lib/cocoapods/installer.rb#L125" target="_blank" rel="external">(<code>resolve_dependencies</code><br>)</a>主要做了以下事情:</p>
<ol>
<li>通过HookManager添加插件源</li>
<li>如果config的<code>skip_repo_update</code>参数没有设置的时候执行Analyzer类的<code>update_repositories</code>方法来更新本地索引库 (这里大家其实可以看出<code>--no-repo-update</code>的作用了吧)</li>
<li>验证Build Configurations参数的有效性</li>
<li>准备版本兼容的遗留问题处理(0.39.0.beta.4属于空方法)</li>
<li>清理沙盒</li>
</ol>
<h3 id="下载依赖库">下载依赖库</h3><p>下载依赖库<a href="https://github.com/CocoaPods/CocoaPods/blob/0.39.0.beta.4/lib/cocoapods/installer.rb#L752" target="_blank" rel="external">(<code>run_podfile_pre_install_hooks</code>)</a>做了如下事情:</p>
<ol>
<li>准备沙盒文件访问器</li>
<li>下载安装Pods依赖库源文件</li>
<li>执行Pods依赖库的pre install的执行钩子</li>
<li>根据Config和Installers参数清理Pods的源文件</li>
</ol>
<h3 id="决定依赖库的类型">决定依赖库的类型</h3><p>决定依赖库的类型<a href="https://github.com/CocoaPods/CocoaPods/blob/0.39.0.beta.4/lib/cocoapods/installer.rb#L385" target="_blank" rel="external">(<code>determine_dependency_product_types</code>)</a>方法的作用主要是预判断库的<code>host_requires_frameworks</code>存储在<code>pod_target</code>属性中给后续使用。 那么主要决定什么内容呢? 参考源码中的注释:</p>
<blockquote>
<p>Determines if the dependencies need to be built as dynamic frameworks or if they can be built as static libraries by checking for the Swift source presence.</p>
</blockquote>
<p>主要是判断库是否需要支持动态Framework以及是否可以被Swift使用过的静态库。</p>
<h3 id="验证没有重名的framework">验证没有重名的framework</h3><p><a href="https://github.com/CocoaPods/CocoaPods/blob/0.39.0.beta.4/lib/cocoapods/installer.rb#L393" target="_blank" rel="external">(<code>verify_no_duplicate_framework_names</code>)</a>主要是验证了目标工程集合和Pods库工程没有命名冲突的Framework, 重点是检查了Framework的名字是否冲突; 如果冲突会抛出<code>frameworks with conflicting names</code>异常</p>
<h3 id="验证静态库的传递依赖">验证静态库的传递依赖</h3><p><a href="https://github.com/CocoaPods/CocoaPods/blob/0.39.0.beta.4/lib/cocoapods/installer.rb#L410" target="_blank" rel="external">(<code>verify_no_static_framework_transitive_dependencies</code>)</a>检查了静态库里是否包含了引用的静态库, 形成传递依赖。静态库的传递依赖如果形成会主动抛出<code>transitive dependencies that include static binaries</code>异常。</p>
<h3 id="验证framework的使用">验证framework的使用</h3><p><a href="https://github.com/CocoaPods/CocoaPods/blob/0.39.0.beta.4/lib/cocoapods/installer.rb#L429" target="_blank" rel="external">(<code>verify_framework_usage</code>)</a>检查是否引用了Switf书写的framework, 并且Podfile中没有指定<code>use framework!</code>。如果验证不通过, 主动抛出异常。</p>
<h3 id="生成工程">生成工程</h3><p><a href="https://github.com/CocoaPods/CocoaPods/blob/0.39.0.beta.4/lib/cocoapods/installer.rb#L152" target="_blank" rel="external">(generate_pods_project<br>)</a>指定了八件任务, 执行分析过程相对比较复杂, 并且大部分执行动作都涉及CocoaPods依赖的另外一个工程<a href="https://github.com/CocoaPods/Xcodeproj" target="_blank" rel="external">Xcodeproj</a>。</p>
<ol>
<li>准备Pods工程(<code>prepare_pods_project</code>)</li>
<li>安装文件引用(<code>install_file_references</code>)</li>
<li>安装库(<code>install_libraries</code>)</li>
<li>为Target设置依赖(<code>set_target_dependencies</code>)</li>
<li>执行pod项目的post install的钩子(<code>run_podfile_post_install_hooks</code>)</li>
<li>执行Project类的Save方法保存配置(<code>write_pod_project</code>)</li>
<li>Pods工程配置共享依赖库的Target Scheme(<code>share_development_pod_schemes</code>)</li>
<li>修改Pods工程的LockFile文件(<code>write_lockfiles</code>)</li>
</ol>
<h3 id="整合用户项目">整合用户项目</h3><p>整合项目主要是依赖<code>UserProjectIntegrator</code>类的<a href="https://github.com/CocoaPods/CocoaPods/blob/0.39.0.beta.4/lib/cocoapods/installer/user_project_integrator.rb#L49" target="_blank" rel="external">integrate</a>方法, 该方法主要是做了两件事情:</p>
<ol>
<li>负责创建xcode的workspace, 并整合所有的target到新的workspace中. </li>
<li>抛出Podfile空项目依赖和xcconfig是否被原有的xcconfig所覆盖依赖相关的警告。<font style="color:orange">最常见的xcconfig override警告就是这里抛出来的哦</font></li>
</ol>
<h3 id="执行install后的行为">执行install后的行为</h3><p>install后的行为分为四段:</p>
<ol>
<li>unLock Pods库下的文件以便执行post install的钩子逻辑</li>
<li>执行Post Install的钩子逻辑</li>
<li>抛出签名执行收集的Spec废弃警告</li>
<li>重新锁定Lock Pods库下的文件防止用户误修改</li>
</ol>
<p>到目前为止, <code>pod install</code>背后的十件大事都<em>粗略</em>的介绍完了哈。</p>
<h2 id="总结">总结</h2><p>本文从<code>pod install</code>作为入口, 跟踪CocoaPods的实现源码, 并粗略根据<code>tag 0.39.0.beta.4</code>的源码将<code>pod install</code>背后主要执行的十个任务罗列出来。通过源码跟踪, 能够更深入的去了解Pods背后的工作, 能够更轻易排查因为Pods使用产生的问题。</p>
<p>另: 源码跟踪还是要自己动手更有效果wow~~~</p>
<p><strong>PS: 本人水平有限, 如果有错误的地方, 请及时指出纠正, 谢谢哇!</strong><br><br><strong>PS: 转载请注明出处哦~~</strong></p>
<h4 id="参考文献">参考文献</h4><ol>
<li><a href="https://guides.cocoapods.org" target="_blank" rel="external">CocoaPods官方Docs</a></li>
<li><a href="https://github.com/CocoaPods" target="_blank" rel="external">Github CocoaPods源码库</a></li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CocoaPods/">CocoaPods</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Ruby/">Ruby</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-Optional-solutions-for-iOS-multi-target" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/06/Optional-solutions-for-iOS-multi-target/" class="article-date">
  	<time datetime="2015-09-06T08:15:50.000Z" itemprop="datePublished">2015-09-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/06/Optional-solutions-for-iOS-multi-target/">iOS - 创建大量相似App的另外一种选择</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本篇文章主要针对iOS应用开发中, 针对需要创建许多相似的应用App提出一种新颖的解决方案。</p>
<p>关于如何创建大量相似的App，<a href="http://weibo.com/tangqiaoboy" target="_blank" rel="external">iOS大神@唐巧</a>曾在他的博文<a href="http://blog.devtang.com/blog/2013/10/17/the-tech-detail-of-ape-client-1/" target="_blank" rel="external">《猿题库iOS客户端的技术细节（一）：使用多target来构建大量相似App》</a>提出了一种可行性非常高的解决方案。我本人也将该实现方案应用到了某二手车应用开发中, 通过创建多个target的方式创建了N个某某拍的应用。但是这种方案真的适用于所有场景么? 除了使用这种方案能否有其它的方式去解决这个问题呢?</p>
<h3 id="基于多Target的应用实践">基于多Target的应用实践</h3><p>我刚开始接触到开发多个相似App应用的需求的时候, 也采用了多个target的解决方案。主要做了以下工作:</p>
<ol>
<li>建立多个Target (通过Duplicate行为)</li>
<li>为每一个Target指定LaunchImage和IconImage, LauchImage和IconImage由同一个image assert管理</li>
<li>为每一个Target指定了<em>Info.Plist</em>和<em>InfoPlist.strings</em>, InfoPlist.strings的作用仅仅是为了指定<strong>CFBundleDisplayName</strong></li>
<li>为每一个Target创建了一个用于配置应用特征的JSON描述文件, 用于对每个Target的特征进行配置修改。</li>
<li>部署自动化打包平台，防止有N个Target就手动打N次包。</li>
</ol>
<p><img src="http://blog.startry.com/img/blog_single_proj_muti_target.png" alt="配置Configuration的各个xcconfig"></p>
<p>在上述工作中, 1、2、3均和配置项有关, 5与项目开发无关, 4是和具体的开发业务相关的。每一项的配置都没有什么技术深度和难度, 4的实现和具体需求相关, 对于极度相似的应用更多的行为是换肤和换key。</p>
<p>这里稍微提以下关于InfoPlist.strings的指定, 每一个Target只能识别一个InfoPlist.strings, 而且还不能重命名。需要为每一个Target创建一个物理文件夹, 然后在对应的文件夹下放置InfoPlist.strings防止命名冲突, 每一个InfoPlist.strings只能指定唯一识别的Target对象。(原理我还没有找到, 找到我就更新下博文哈~)</p>
<h3 id="差异性较大的Target处理">差异性较大的Target处理</h3><p>什么? 差异性大你还放在一个工程里? 架构就有问题。是的, 差异性较大的工程就应该拆分成不同的工程, 然后共享的代码通过framework以及静态库引用的方式抽离出去。<font color="orange">但是, 时间是道坎!</font> 假如你时间很紧怎么办? 本文给出一种时间很紧时候的<font color="red">临时</font>解决方案<strong>(注意: 决必是临时的, 时间是海绵, 需要去挤的!)</strong></p>
<p>在时间非常紧的情况下, 可以通过拆分AppDelegate来实现(代价其实非常沉重, 会link好多无用的类)。拆分AppDelegate其实就要在main.m里面赋值不同的AppDelegate即可实现。main函数中argv包含了app的名字, 可以通过该名字去鉴别载入的AppDelegate。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &#60;UIKit/UIKit.h&#62;&#10;&#10;#import &#34;STAppDelegate.h&#34;&#10;#import &#34;STPAppDelegate.h&#34;&#10;&#10;int main(int argc, char * argv[])&#10;&#123;&#10;    @autoreleasepool &#123;&#10;        char demoStr[] = &#34;/stdemo.app&#34;; // &#26816;&#26597;stdemo target&#10;        char *p= strstr(*argv, demoStr);&#10;        if(NULL != p)&#123;&#10;            return UIApplicationMain(argc, argv, nil, NSStringFromClass([STAppDelegate class]));&#10;        &#125;else&#123;&#10;            return UIApplicationMain(argc, argv, nil, NSStringFromClass([STPAppDelegate class]));&#10;        &#125;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>PS: 切记, 临时解决方案, 如需根治, <font style="font-size:1.5em">拆分工程</font>!</strong></p>
<h3 id="基于多Target实现的好处">基于多Target实现的好处</h3><ol>
<li><p>直观</p>
<p> 一目了然, 可以看到所有已创建的Target醒目的列在Build列表中。每一个Target都有对应的Tagret配置界面可以看到每一个项目配置图标以及Info.plist对应信息。</p>
</li>
<li><p>灵活性高</p>
<p> 可以根据项目需要Link需要的类, 根据Target来指定链接不同的类和资源文件, 而不用一口气全部都Link进来。</p>
</li>
</ol>
<h3 id="基于多Target遇到的坑">基于多Target遇到的坑</h3><p>如果没有遇到坑, 那就不会去重新寻找一个更好的解决方案了。基于多Target的方式去创建大量相似的App的坑主要提现在<strong>多人协作</strong>上。</p>
<p>个人之前在实现多Target项目的时候遇到的问题不多, 但是随着时间推移, 维护开发遇到了两个比较明显的问题:</p>
<ol>
<li><p>类的Target指定遗漏</p>
<p> 在多个Target的环境下, 我们每新建一个类文件都要给类文件指定对应的Target, 如果不小心忘记指定对应的Target, 则会会在编译阶段报错。</p>
<p> <img src="http://blog.startry.com/img/blog_missing_target.png" alt="配置Configuration的各个xcconfig"></p>
</li>
<li><p>配置文件描述庞大, 难以修改</p>
<p>多个Target会导致项目的pbxproj臃肿, 因为pbxproj文件维护了项目的所有文件id和group层级关系, 多一个target就几乎多了一倍的描述信息, 可想而知, 这个pbxporj文件是有多庞大。</p>
<p>光文件庞大顶多引起Xcode项目的配置文件加载慢, 但是遇到冲突的时候可就头疼了, 几万行的描述文件。</p>
<p> <img src="http://blog.startry.com/img/blog_pbcproj_too_much.png" alt="配置Configuration的各个xcconfig"></p>
</li>
<li><p>配置文件修改不同步</p>
<p>配置文件修改不同步是基于已创建N个Target的前提下, 因为项目的推进, 需要对每一个项目文件进行固定的修改, 但是存在修改遗漏的情况。</p>
<p>对于这种场景, 有一种比较好的方案是自己动手写脚本来替换编译配置项, 保证每一个Target的配置项目均被替换。Mac开发工具中自带的<a href="https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man8/PlistBuddy.8.html" target="_blank" rel="external">PlistBuddy</a>在处理配置项目替换上绝对是个神器。</p>
</li>
</ol>
<h3 id="重新思考">重新思考</h3><p>虽然在项目中遇到了不少坑，但是解决这些坑并不需要大量的时间(那是因为时间被打散了, 组合起来估计也不少了)，所以我个人并没有去重新思考怎么去解决遗漏Target编译报错以及项目配置文件不断冲突的问题。</p>
<p>触发我重新思考是一次机缘, 经过花瓣网某iOS研发高手(我不知道他名字哇)提点, 他问我基于Cocoapods能否有更好的办法去创建大量相似的App。基于Cocoapods本身就是基于Hook, Hook本身就是动态修改项目配置项, 换言之, <font color="red">能否通过动态修改Target的项目配置项去创建大量相似的App呢</font>?</p>
<p>回到文章前面的<code>基于多Target的应用实践</code>的5个步骤, 逐一用替换项目的配置文件(pbcproj)的方式去重新审视。</p>
<ol>
<li>不需要建立多个Target, 只维护一个Target</li>
<li>主要是icon和launch image的修改, 有两种方案:<ul>
<li>在image.assert预先放置多个不同名字的资源, 通过修改pbxproj来指定不同的图片资源</li>
<li>所有的icon和launch image都是用相同名字, 通过脚本动态替换image.assert中的资源文件(推荐)</li>
</ul>
</li>
<li>主要针对info.plist和InfoPlist.strings的修改, InfoPlist.string可以通过<code>sed</code>命令去动态替换, info.plist也可以采取两种方案来实现:<ul>
<li>预先防止多个Info.plist文件, 通过修改pbxcproj来指定不同的info.plist文件</li>
<li>target永远指定一个Info.plist, 通过脚本动态替换修改Info.plist(推荐)</li>
</ul>
</li>
<li>通过JSON描述特性的文件可以单独防止在工程里, 通过脚本拷贝替换, 也可以利用<code>cocoapods-keys</code>等工具进行外部注入</li>
<li>前面的4个步骤都是依赖于基本动态替换, 自动化构建平台通过将指定Target的方式, 修改为在编译器执行对应的任务脚本即可完成。</li>
</ol>
<h4 id="进一步优化">进一步优化</h4><p>重新思考<strong><font color="black">通过外部修改配置项目和资源文件的方式来实现多个类似应用功能</font></strong>, 省去了维护多个target产生的冲突和配置过大的问题。但是, 外部脚本本身也是一个实现成本, 这里针对替换外部脚本提出一个优化策略(不一定最优)。</p>
<ol>
<li><p>维护每个项目的文件夹</p>
<p>每一个项目就是指原来的每一个target, 文件夹可以保持和原先的target名字保持同名。该目录文件夹不参与项目引用, 即不在pbxcproj文件中被描述。该目录文件夹纯粹是提供给外部脚本使用, 与逻辑工程保持独立。</p>
</li>
<li><p>在第一步的文件夹中抽离变化项目到同一个JSON文件中</p>
<p> 该json文件中描述了所有需要替换的内容, 包含image.assert的替换规则以及info.plist替换规则等等。</p>
</li>
<li><p>在第一步的文件夹中抽离资源文件</p>
<p>在该文件夹中防止所有可变化的资源文件, 包含<code>.png</code>、<code>info.plist</code>等等所有可变化差异的项目。</p>
</li>
</ol>
<p><img src="http://blog.startry.com/img/blog_shell_muti_target_menu.png" alt="配置Configuration的各个xcconfig"></p>
<p>在前面三步的基础下, 主要是为了一个目的, 一行脚本替换所有可变信息。(实际上就是提前将变化项维护在独立的文件夹中了)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 动态变化 demo1 Target</span></span><br><span class="line">./st_muti_target st_demo1/muti_target.json</span><br><span class="line"></span><br><span class="line"><span class="comment">## 动态变化 demo2 Target</span></span><br><span class="line">./st_muti_target st_demo2/muti_target.json</span><br></pre></td></tr></table></figure>
<p>想要<code>st_muti_target.sh</code>的源码? 这个自己写吧。。每个项目都不一样的。</p>
<h3 id="总结">总结</h3><p>基于建立多个相似App的需求, 和本人实际在项目应用中遇到的坑, 提出了一种基于脚本不断替换配置项目和资源文件的解决方案。该方案主要解决了多Target所带来的配置文件过大和容易冲突的问题, 但是同时又引入了脚本的维护成本。本文也提供了一种降低脚本使用成本和项目耦合的一种方案, 但是仍需要进一步优化, 并不是最终的解决方案版本。</p>
<p>多一种方案多一种选择么, 对于擅长书写脚本的童鞋们, 用这种方式做大量类似的App(换肤App)可能会是更好的一种选择喔~</p>
<p>水平有限, 有错误之处或者有什么地方没有描述清楚, 请大家及时指出哇~</p>
<p>参考文件:</p>
<ol>
<li><a href="http://blog.devtang.com/blog/2013/10/17/the-tech-detail-of-ape-client-1/" target="_blank" rel="external">http://blog.devtang.com/blog/2013/10/17/the-tech-detail-of-ape-client-1/</a></li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ios/">ios</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/xcconfig/">xcconfig</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-Renaming-umbrella-header-for-iOS-framework" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/25/Renaming-umbrella-header-for-iOS-framework/" class="article-date">
  	<time datetime="2015-08-25T04:52:19.000Z" itemprop="datePublished">2015-08-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/25/Renaming-umbrella-header-for-iOS-framework/">iOS - Umbrella Header在framework中的应用</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在相对较大的互联网App研发中, framework静态库被广泛应用, 那么在研发framework的时候也产生好多的问题? 其实一个常见的问题的就是umbreall header文件的使用。</p>
<p>大家是否有遇到过一个常见的错误使用umbrella header的场景: framework的文件明明被主工程引用了, 但是在编译的时候依旧抛出<font color="orange">Lexical or Preprocessor Issue - Umbrella header for module ‘xxx’ does not include header ‘xxx.h’</font>的警告。</p>
<p><strong>那么问题来了, 什么是umbrella header? 什么又是umbrella framework呢?</strong></p>
<p>参考官方文档<a href="https://developer.apple.com/library/ios/documentation/MacOSX/Conceptual/BPFrameworks/Frameworks.html#//apple_ref/doc/uid/10000183-SW1" target="_blank" rel="external">《Introduction to Framework Programming Guide》</a>学习说明, 可以了解到Framework区分Standard Framework和Umbrella Framework。但是, 我找了半天也没有找到官方文档有对Umberlla framework给出明确的定义(大家找到了记得告诉我)。在官方文档<a href="https://developer.apple.com/library/ios/documentation/MacOSX/Conceptual/BPFrameworks/Concepts/FrameworkAnatomy.html#//apple_ref/doc/uid/20002253-97623-BAJJHAJC" target="_blank" rel="external">《Anatomy of Framework Bundles》</a>章节中, 我找到三段比较合理说明Umbrella Framework的话:</p>
<blockquote>
<p>Umbrella frameworks add minor refinements to the standard framework structure, such as the ability to encompass other frameworks</p>
</blockquote>
<hr>
<blockquote>
<p>The structure of an umbrella framework is similar to that of a standard framework, and applications do not distinguish between umbrella frameworks and standard frameworks when linking to them. However, two factors distinguish umbrella frameworks from other frameworks. The first is the manner in which they include header files. The second is the fact that they encapsulate subframeworks.</p>
</blockquote>
<hr>
<blockquote>
<p>Physically, umbrella frameworks have a similar structure to standard frameworks. One significant difference is the addition of a Frameworks directory to contain the subframeworks that make up the umbrella framework.</p>
</blockquote>
<p>字面上的意思应该是在标准的Framework做了一些改良的工作, 使其可以嵌套包含Framework。<br>在物理结构上, Umbrella Framework只在包含头文件的方式以及是否包含子Framework和普通的Framework存在区别。</p>
<p>那么引用头文件的地方又有什么区别呢? 还是参考官方文档引用:</p>
<blockquote>
<p>For most frameworks, you can include header files other than the master header file. You can include any specific header file you want as long as it is available in the framework’s Headers directory. However, if you are including an umbrella framework, you must include the master header file. Umbrella frameworks do not allow you to include the headers of their constituent subframeworks directly. See <a href="https://developer.apple.com/library/ios/documentation/MacOSX/Conceptual/BPFrameworks/Tasks/IncludingFrameworks.html#//apple_ref/doc/uid/20002257-BAJJBBHJ" target="_blank" rel="external">Restrictions on Subframework Linking</a> for more information.</p>
</blockquote>
<p>简单翻译一下: <strong>普通的framework可以通过引用对应的heaedr文件而不是Master Header File去引用需要使用的类, 只需要对应的header头文件在Headers文件夹下暴露, 并没有强制要求引用Master Header File。Umbrella Framework要求必须要引用Master Header File, 并且头文件中不能直接引用子Framework的东西。</strong></p>
<p>上述描述已经说了Umbrella Framework一定要引用Master Header File, 而Umbrella Framework的Master Header File就是Umbrella header文件。</p>
<p>大家是否存在一个疑问, 官方说明中只有强制规定一定要引用Umbrella Header文件, 但是却没有说能不能单独引用Umbrella Framework的其他头文件呢? 我们可以自己试验一下:</p>
<ol>
<li>在Umbrella Framework新建一个<code>testObject</code>类, 分别产生了<code>testObject.h</code>和<code>testObject.m</code>文件。</li>
<li>打开Framework配置文件, 在<code>Build Phases</code>的<code>Headers</code>里的<code>Public</code>目录下, 将<code>testObject.h</code>文件添加进去。</li>
<li>Build Framework看是否报错。</li>
<li>在主工程中调用初始化<code>testObject</code>对象, 看编译是否报错。</li>
</ol>
<p>执行结果:</p>
<ul>
<li><strong>步骤3</strong>: 没有编译报错, 但是报出了<font color="orange">Lexical or Preprocessor Issue - Umbrella header for module ‘STDemoUI’ does not include header ‘testObject.h’</font>的警告。</li>
<li><strong>步骤4</strong>: 执行正常。</li>
</ul>
<p>那么我们来总结一下:</p>
<ol>
<li>Standard Framework不能包含Sub Framework; Umbrella Framework可以包含子Framework;</li>
<li>Standard Framework可以直接引用需要使用的头, 也可以通过引用Master Header file来引用需要使用的类; Umbrella Framework需要通过引用Master Header File(Umbrella Header)来引用需要使用的类;</li>
</ol>
<h3 id="规范的写法">规范的写法</h3><p>Umbrella Framework默认会创建一个同名.h文件最为Umbrella Header文件。规范的写法当然是遵从默认的模式, 将所有需要暴露的头文件都写在Umbrella Header文件中。</p>
<p>例如: <code>STDemoUI.framework</code>工程包含了<strong>STClassOne</strong>、<strong>STClassTwo</strong>和<strong>STClassThree</strong>三个类。<code>STDemoUI</code>会生成一个默认的伞头文件(直译Umbrella Header, 不专业)<code>STDemoUI.h</code>。假设该framework的三个类均需要在外部调用使用, 则<code>STDemoUI.h</code>需要将三个类的引用均写入伞头文件中。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// STDemoUI.h&#10;// ...&#10;&#10;#import &#60;STDemoUI/STClassOne.h&#62;&#10;#import &#60;STDemoUI/STClassTwo.h&#62;&#10;#import &#60;STDemoUI/STClassThree.h&#62;</span><br></pre></td></tr></table></figure>
<p>在需要调用的主工程中, 仅仅只要将Umbrella Header引用即可调用所有在Umbrella Header中包含的类了。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#22312;&#20027;&#24037;&#31243;&#38656;&#35201;&#24212;&#29992;&#30340;&#31867;&#20013;&#21253;&#21547;Umbrella Header&#10;#import &#60;STDemoUI/STDemoUI.h&#62;</span><br></pre></td></tr></table></figure>
<h3 id="如何重命名umbrella_header">如何重命名umbrella header</h3><p>如果大家都遵从默认的Umbrella Framework的写法, 在同名头文件中写需要暴露的引用头文件, 那么就不需要考虑怎么重命名Umbrella header了。</p>
<p>很多时候, 理想和现实是有差距的, 程序员写代码多数是在二次接手进行开发的。假设公司的前辈已经将Framework的同名文件用作了一个逻辑类, 给同名文件创建了.m文件, 并已经书写了逻辑并应用了各个工程里面去了。那么显然迁移头文件功能代码是不可能的, 因为很多依赖该Framework的业务部门都需要针对库进行代码优化。</p>
<p>在这种不能将同名文件作为Umbrella header的情况下, 我们又不想通过Public强制暴露头文件的情况下(<strong>不写在Umbrella Header中会有警告</strong>)。我们就需要对Umbrella Header进行指定了。</p>
<h4 id="指定Umbrella_Header入口在哪里呢?">指定Umbrella Header入口在哪里呢?</h4><p>万事开头难, 我们想要指定Umbrella Header, 但是在哪里指定呢? 通过文章搜索, 都没有找到一个比较合理的方案, 那就只能自己摸索了。</p>
<ol>
<li>在工程全局搜索<code>umbrella</code>关键字 - <font color="red">Failed</font></li>
<li>在Build Settings里搜索<code>umbrella</code>关键字 - <font color="red">Failed</font></li>
<li>在打包好的<code>STDemoUI.framework</code>中搜索<code>umbrella</code>关键字 - <font color="green">Bingo</font></li>
</ol>
<p>既然搜索到了关键字就好办了, 双击点开STDemo.framework, 我们可以看到如下图所示五个文件(夹)。</p>
<p><img src="http://blog.startry.com/img/blog_framework_structure.png" alt="Framework内部结构"></p>
<p>初略看名称可以推测出每个文件以及文件夹所承担的作用:</p>
<ul>
<li>_CodeSignature: 保存签名相关文件</li>
<li>Headers: framework暴露的所有头文件</li>
<li>Info.plist: 描述了该framework所包含的项目配置信息</li>
<li>STDemo: 编译后的核心库文件</li>
<li>Modules: 模块相关文件夹, 目测只包含了<code>module.modulemap</code>文件</li>
</ul>
<p>我们在<code>module.modulemap</code>文件中找到了<code>umbrella</code>关键字。文件内容如下:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">framework module STDemoUI &#123;</span><br><span class="line">  umbrella header "STDemoUI.h"</span><br><span class="line"></span><br><span class="line">  export *</span><br><span class="line">  module * &#123; export * &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原来Framework的umbrella header是在这个位置被指定的, 但是这个已经是编译好的工程, 我们总不能每次编译好了再进到包里面修改下。既然我们已经找到umbrella header是在module中去指定, 那么我们就用<code>module</code>作为关键字再去<code>Build Settings</code>里重新搜索下呗~ </p>
<p>这回我们在<code>Kernel Module</code>和<code>Packaging</code>中均找到了<code>Module</code>关键字, 在<code>Packaging</code>标签中, 有一项<code>Module Map File</code>属性, 看名字应该是用来指定modulemap文件的, 这不解决了么?</p>
<h4 id="指定Modulemap文件">指定Modulemap文件</h4><p>找到了解决方案, 那么接下来就要动手去解决问题了</p>
<ol>
<li>创建一个新的.h文件; ex: STHeader.h<ul>
<li>将所有需要暴露的头文件均写入STHeader.h</li>
</ul>
</li>
<li>创建一个新的modulemap文件; ex: stdemoalt.modulemap</li>
<li><p>在新的modulemap中指定<code>umbrella header</code></p>
 <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">framework module STDemoUI &#123;</span><br><span class="line">    umbrella header "STHeader.h"</span><br><span class="line">    </span><br><span class="line">    export *</span><br><span class="line">    module * &#123; export * &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li>在framework的<code>Build Settings</code>中的<code>Module Map File</code>指定新建的modulemap文件</li>
</ol>
<p>好了, 准备工作完毕, CMD+B, 编译完了, 打开framework包中的Module文件夹, 看是否包含了新指定的modulemap。</p>
<p>抛出两个疑问: </p>
<ol>
<li>Module是什么?</li>
<li>如果<code>Defines Module</code>指定为<code>NO</code>, 那会发生什么事情呢? </li>
</ol>
<h3 id="题外话">题外话</h3><p>这里我要引用官网Guidelins for Creating Frameworks的一个子标题<strong>Don’t Create Umbrella Frameworks</strong>。原文如下:</p>
<blockquote>
<p>While it is possible to create umbrella frameworks using Xcode, doing so is unnecessary for most developers and is not recommended. Apple uses umbrella frameworks to mask some of the interdependencies between libraries in the operating system. In nearly all cases, you should be able to include your code in a single, standard framework bundle. Alternatively, if your code was sufficiently modular, you could create multiple frameworks, but in that case, the dependencies between modules would be minimal or nonexistent and should not warrant the creation of an umbrella for them</p>
</blockquote>
<p>在大多数情况下, 苹果是不建议手动创建Umbrella Framework。</p>
<h3 id="总结">总结</h3><p>本文简单的梳理了官方文章关于Umbrella Framework和Umbrella Header的介绍说明, 产生警告的原因是没有引用umbrella header或者暴露头没有写在umbrella header中。在umbrella header被已使用的前提下, 本文提供了一种通过重命名Umbrella Header文件的方式来消除警告的解决方案。</p>
<p>虽然引用警告可以被消除, 但是建议大家还是采用规范的做法: 尽量不要在同名头文件中写业务逻辑代码, 用同名文件作为Umbrella库的Master Header File。</p>
<p>水平有限, 有错误请大家及时指出哈~<br>转载请注明出处哦~</p>
<p>参考文献:</p>
<ol>
<li><a href="https://developer.apple.com/library/ios/documentation/MacOSX/Conceptual/BPFrameworks/Frameworks.html" target="_blank" rel="external">https://developer.apple.com/library/ios/documentation/MacOSX/Conceptual/BPFrameworks/Frameworks.html</a></li>
<li><a href="http://stackoverflow.com/questions/32153131/renaming-umbrella-header/32153383#32153383" target="_blank" rel="external">http://stackoverflow.com/questions/32153131/renaming-umbrella-header/32153383#32153383</a></li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/framework/">framework</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ios/">ios</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/umbrella-header/">umbrella header</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-iOS_EnvWithXcconfig" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/07/24/iOS_EnvWithXcconfig/" class="article-date">
  	<time datetime="2015-07-24T11:38:07.000Z" itemprop="datePublished">2015-07-24</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/24/iOS_EnvWithXcconfig/">iOS开发必备 - 环境变量配置(Debug &amp; Release)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本篇文章主要讲述了如何使用<a href="https://developer.apple.com/library/ios/recipes/xcode_help-project_editor/Articles/BasingBuildConfigurationsonConfigurationFiles.html" target="_blank" rel="external">(Xcode配置文件xcconfig)</a>去动态配置开发或者生产网络环境, 以及在多项目和运行中如何切换环境。</p>
<p>关于xcconfig文件, 目前在官方很难找到一篇专门的指南介绍, 但是国外有篇非官方指南<a href="http://pewpewthespells.com/blog/xcconfig_guide.html" target="_blank" rel="external">《The Unofficial Guide to xcconfig files》</a>详细的介绍了xcconfig。估计很多新入门的iOS开发对xcconfig文件都不是很熟悉, 但是大家可能都用过Cocoapods, 其实Cocoapods的项目配置管理很多都是依赖xcconfig文件去实现的。</p>
<h3 id="Debug宏应该在哪里定义?">Debug宏应该在哪里定义?</h3><p>iOS系统本身就区分了Configurations选项让开发者去修改对应的开发环境配置, 但是因为很多开发者却又在同一个Configuration环境中自定义了开发环境配置的开发, 使得iOS系统本身的配置成为了摆设, <em>仅仅用于区分打包方式选项和证书配置</em>。</p>
<p><strong>网络环境切换</strong>是每一个互联网App开发者都会频繁用到的功能, 那么大家都是用什么样的方式在切换环境的呢?我本人接触的项目中最多的就是在预编译头文件里面写一行宏定义, 然后根据宏定义去判断当前的环境。</p>
<p><font color="orange">最典型的例子</font>是在预编译头pch文件中添加一行代码<code>#define DEBUG 1</code>。然后通过这个<code>DEBUG</code>参数去判断当前环境是否处于开发网络或者生产网络环境。</p>
<p>使用<code>DEBUG</code>宏去判断判断开发环境还是生产环境没有任何问题, 关键的问题是我们在什么时候去定义这个宏和怎么去动态配置这个宏。</p>
<h2 id="动态配置不同的网络开发环境">动态配置不同的网络开发环境</h2><p>开发环境的切换在代码中最实用的还是宏定义, 那么我们怎么样才能够让宏定义<font color="red">动态</font>可配置呢?<br><br>其中一种办法就是使用GCC预编译头参数<code>GCC_PREPROCESSOR_DEFINITIONS</code>。</p>
<p>通常我们可以在Project文件下的Build Settings对预编译宏定义进行默认赋值。在Xcode6下的路径为<code>Build Settings</code>-&gt;<code>Apple LLVM 6.x Preprocessing</code>-&gt;<code>Preprocessor Macros</code><br><img src="http://blog.startry.com/img/blog_setting_pcm_demo.png" alt="预编译Setting示例"></p>
<p>想必大家看这个宏的名字已经知道它的作用了, 实际上就是和在pch头文件中添加宏定义没有太大的区别, 实际上还是有一些好处:</p>
<ul>
<li>Xcode的Project的Build Settings是由一个plist文件进行描述的, plist本质上是一个XML配置文件, 通过外部的脚本比较容易去修改。</li>
<li>Preprocessor Macros可以按照Configuration选项进行默认配置, 也就是说可以根据不同的环境预先制定不同定义的宏</li>
</ul>
<h5 id="xcconfig配置Build_Settings">xcconfig配置Build Settings</h5><p>Xcode Project的Build Settings属性有很多, 如果每一个属性都在配置项改过去比较麻烦, 而且容易忘记, 而且Build Settings用源码的打开可阅读性也不是很高, 这个时候, 我们可以使用xcconfig文件去配置Build Settings参数。</p>
<p>xcconifg支持可以根据不同的Configuration选项配置不同的文件。不同的xcconfig可以指定不同的Build Settings里的属性值, 这样子我们就可以通过项目xcconifg去修改<code>GCC_PREPROCESSOR_DEFINITIONS</code>的值了(最终目的就达到了)。</p>
<p>利用xcconfig配置Build Settings的方式比直接在项目Build Settings修改对应的属性值要优雅的多, 英国的iOS大神<a href="https://github.com/jspahrsummers" target="_blank" rel="external">Justin Spahr-Summers</a>书写的开源库<a href="https://github.com/jspahrsummers/xcconfigs" target="_blank" rel="external">xcconfigs</a>提供了一个类权威的模板, 大家可以参考编写以及学习使用xcconfig。</p>
<h3 id="Object-C下配置的支持">Object-C下配置的支持</h3><p>在项目中的Info类目下, 大家可以配置Configuration对应的选项的xcconfig, 通过xcconfig来配置Build Setting中的参数(见下图)。<br><img src="http://blog.startry.com/img/blog_xcconfig_configurations.png" alt="配置Configuration的各个xcconfig"></p>
<p>PS: 如果大家对Cocoapods比较熟悉的话, 你会发现其实Pods也是通过xcconfig文件去修改项目配置参数的。</p>
<h3 id="Swift下配置的支持">Swift下配置的支持</h3><p>这里区分Object-C和Swift没有太大的意义。只不过因为C语言使用一些非常不安全的预处理器指令能力，Swift则只使用预处理器指令的安全子集。因此预编译头参数在Swift并不会生效, 需要增加<code>OTHER_SWIFT_FLAGS</code>标记才能够将<code>Debug</code>作用于Swift的条件式判断。标记书写方式参考下方示例:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OTHER_SWIFT_FLAGS = -D DEBUG</span><br></pre></td></tr></table></figure>
<h2 id="动态修改配置文件">动态修改配置文件</h2><p>环境切换的标志位宏被提取到Build Setting中的<code>GCC_PROCESSOR_DEFINTIONS</code>有什么好处呢?</p>
<ul>
<li>外部修改只需要修改工程的<code>project.pbxproj</code>即可对<code>GCC_PROCESSOR_DEFINTIONS</code>参数进行操作修改</li>
<li>可以通过xcconfig去配置参数, 而配有xcconfig的Configuration可以通过<code>xcodebuild</code>命令指定</li>
<li>可以避免将最基础的Debug和Release网络环境切换书写在代码中</li>
</ul>
<h3 id="自动化脚本支持(便于自动化构建)">自动化脚本支持(便于自动化构建)</h3><p>一个优秀的iOS工程师一定会使用自动化构建应用去解放自己的打包时间。<a href="http://blog.startry.com/2015/06/23/iOS_CI_With_Jenkins/" target="_blank" rel="external">《搭建自动化构建服务》</a>讲述了如何搭建一个自动化构建程序, 可以作为参考。</p>
<p>自动化构建的核心在于使用xcodebuild命令和各类脚本, 本文讲述2个场景:</p>
<ul>
<li>场景1: 环境变量由宏定义并且书写在项目的预编译头文件中或者在预编译头文件引用的<code>.h</code>文件中; <ul>
<li>通过脚本动态替换行, 可以采用sed命令来替换, 最典型的实例如下:</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">''</span> <span class="string">'s/^#define Debug 1/\/\/#define Debug 1/'</span> <span class="string">"./Demo/STSwitch.h"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>场景2: 环境变量由宏定义但是配置在<code>GCC_PREPROCESSOR_DEFINITIONS</code>编译选项中。<ul>
<li>如果<code>GCC_PREPROCESSOR_DEFINITIONS</code>由xcconfig文件指定并配置对应的Configuration中, 直接通过<code>xcodebuild</code>命令指定<code>-configuration</code>参数来选择。</li>
<li>如果<code>GCC_PREPROCESSOR_DEFINITIONS</code>需要在Build Settings中动态修改, 可以在Podfile中书写Hook代码或者用脚本解析配置文件进行动态修改。</li>
</ul>
</li>
</ul>
<h3 id="Cocoapods下支持">Cocoapods下支持</h3><p>如果大家对Cocoapods比较熟悉的话, 就会知道每次执行完<code>pod install</code>之后, Cocoapods都会对每一个工程的Configuration配置一个xcconfig文件。</p>
<p>默认情况下, 如果配置项已经存在了xcconfig文件, Cocoapods是不会将生产的xcconfig文件设置入配置项的。Cocoapods是通过xcconfig文件去修改外部链接依赖的, 因此如果没有正常替换配置文件, 有肯能会导致整个工程无法编译通过(缺少依赖库能通过才怪啦)。</p>
<p>解决方法</p>
<ul>
<li>如果自己修改的xcconfig文件内容<strong>不多</strong>, 可以通过在Podfile中编写hook去实现修改对应的项目参数, 参考示例如下:</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">post_install <span class="keyword">do</span> |installer|</span><br><span class="line">    installer.pods_project.targets.each <span class="keyword">do</span> |target|</span><br><span class="line">        target.build_configurations.each <span class="keyword">do</span> |config|</span><br><span class="line">            <span class="keyword">if</span> config.name == <span class="string">'Debug'</span></span><br><span class="line">                config.build_settings[<span class="string">'GCC_PREPROCESSOR_DEFINITIONS'</span>] = <span class="string">'Debug=1'</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果自己修改的xcconfig文件内容<strong>较多</strong>, 可以在自己的编写的xcconfig include Cocoapods生产的xcconfig文件的方式进行处理, 参考示例如下:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 自定义的xcconfig (例如: st.debug)</span><br><span class="line"><span class="comment">#include "../Pods.debug"</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 自定义的xcconfig (例如: st.release)</span><br><span class="line"><span class="comment">#include "../Pods.release"</span></span><br></pre></td></tr></table></figure>
<h3 id="多项目环境下支持">多项目环境下支持</h3><p>多项目的环境配置往往是比较麻烦的, 比如有B、C、D三个子工程, A工程引用了B、C、D三个子工程。怎么把统一的环境变量怎么应用到A、B、C、D三个工程里呢?</p>
<ul>
<li>做法1: 建立一个公有引用的项目(无论Pods还是手动), 所有的项目均引用这个公有的项目, 公有的项目暴露一个头文件里面定义了所有的环境变量。</li>
<li>做法2: 每一个项目均维护自己的初始值, 通过外部的脚本一次性修改所有项目的初始值保持统一。</li>
<li>做法3: 每一个项目维护自己的初始值, 通过上文描述的GCC编译属性或者xcconfig控制, 通过脚本或者Podfile控制每一个项目初始值</li>
<li>做法4: 每个项目的维护自己的初始值, 但是所有环境变量动态维护, 在主工程的AppDelegate中加载A项目的初始值并通过接口赋值给每一个子工程。(该方式宏定义智能作为初始值, 参考下文<code>动态切换配置</code>)</li>
</ul>
<h3 id="动态切换配置">动态切换配置</h3><p>文章前面所述均少了一个关键字<code>初始值</code>, 前面所添加的环境变量的方式都是在添加<code>初始环境变量常量</code>。</p>
<p>假设有一个运营或者测试需求, 需要能够用户自己去选择网络配置或者环境基础变量, 按照文章前面描述的方法, 是无法实现的。 因此, 上述的方式都只能提供一个初始默认值, 并无法在运行中去修改, 因为上述配置的方式都是通过<strong>预编译</strong>去实现的。</p>
<p>在App运行时切换环境, 那配置参数都不能简单的用宏或者常量来控制了, 需要讲环境配置参数存储在变量中, 通常是用<code>NSUserDefault</code>或者<code>Singleton</code>去维护环境变量集合。通过开发配置页面对维护的变量进行动态的修改。(建议在Debug模式下开启放置在系统的Setting界面下)</p>
<h2 id="另外一种选择">另外一种选择</h2><p>除了通过宏初始化, 是否还有其它的读取配置文件的方式初始化呢?</p>
<p>我们可以维护一个单例去管理所有的初始值, 在iOS应用开发中用属性值去管理开发环境和生产环境(坏处很明显, 控制力度没有<code>宏</code>这么大)。</p>
<p>资源文件加载其实就是把参数写在资源文件中, 然后通过代码在AppDelegate启动的时候去加载初始值到全局维护的单例中, 然后在工程中到处使用单例的实例变量去判断环境。</p>
<h3 id="Cocoapods-keys">Cocoapods-keys</h3><p>通过配置加载环境配置环境变量是否能够做到工程依赖无关呢? 换言之就是在不同的安装目录或者不同的机器环境下配置不一样的环境变量, 让环境变量不与工程直接关联而与工程所在目录环境关联起来呢?</p>
<p>做过服务端开发的童鞋们应该熟悉有一种config配置的方式, 让config在外部注入, 而不是在开发工程中写死, 即使写死也只是个初始值。</p>
<p>Cocoapods提供了一款插件<a href="https://github.com/orta/cocoapods-keys" target="_blank" rel="external">Cocoapods-keys</a>, 提供了外部注入键值对的功能, 通过Cocoapods-keys插件, 我们可以在工程中调用外部注入的键值对, 通过外部的键值对工程进行一定力度的控制。</p>
<p>Cocoapods-keys注入的键值对均存储在<code>~/.cocoapods/keys</code>下, 是以yml的格式保存的, yml中描述了已经添加的键值对和对应项目路径。</p>
<h2 id="总结">总结</h2><p>文章想表达的核心思想是将环境切换初始化提取到配置文件处, 方便外部脚本修改(例如Podfile、自己写的Bash Shell等等)。在多项目环境下, 配置文件修改配置项更加容易可控, 防止多处修改代码或者使用脚本动态修改代码。</p>
<p>文章的作用是给我本人备忘用的哈~ 水平有限, 有错误支持请大家及时指出哈~<br>转载请注明出处哦~</p>
<p>参考文章:</p>
<ol>
<li><a href="http://pewpewthespells.com/blog/xcconfig_guide.html" target="_blank" rel="external">http://pewpewthespells.com/blog/xcconfig_guide.html</a></li>
<li><a href="http://www.jianshu.com/p/44c82630bd50" target="_blank" rel="external">http://www.jianshu.com/p/44c82630bd50</a></li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ios/">ios</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/xcconfig/">xcconfig</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-iOS_CI_With_Jenkins" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/06/23/iOS_CI_With_Jenkins/" class="article-date">
  	<time datetime="2015-06-23T11:24:07.000Z" itemprop="datePublished">2015-06-23</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/23/iOS_CI_With_Jenkins/">iOS开发必备 - 搭建自动化构建服务</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本篇文章讲述了如何使用<a href="https://jenkins-ci.org/" target="_blank" rel="external">Jenkins</a>搭建iOS的自动化构建环境。</p>
<p>iOS自动化构建<a href="https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/xcode_guide-continuous_integration/" target="_blank" rel="external">官方有篇文章介绍Xcode持续集成</a>, 是基于Xcode Server以及Xcode Bots去实现, 但是系统依赖和版本依赖过于严重, 并且需要在Xcode中配置Target的Shared属性, 耦合性太强, 因此不建议使用。</p>
<h2 id="为什么客户端需要自动化构建">为什么客户端需要自动化构建</h2><p>个人觉得最主要的原因是需要<em>提高编码效率</em>, 其次是<em>方便测试与集成</em></p>
<ol>
<li><p><font size="4">场景: 开发过程中, 不断的有产品或者测试介入, 需要你不定时的打包给他们提供体验与测试。</font><br>对于小工程来说, build一下可能就是几秒钟的事情, 但是对于大工程来说, 一次打包可能耗费5分钟乃至10分钟的开发时间。开发者一天中的有效开发时间是有限的, 在不断被打断的情况下, 开发者的产能实际上十分低效的。</p>
</li>
<li><p><font size="4">场景: 联调过程中, 需要有第三方的SDK接入联调, 需要不断的为对方更改SDK, 然后重新编译打包。</font><br>这种场景一般发生在多个公司协作的时候, 本人在开发某二手车批发软件的时候, 就曾遇到与第三方支付平台接入联调的问题, 一天中80%时间为对方提供打包服务, 生产效能过低。</p>
</li>
<li><p><font size="4">场景: 用户预览&amp;客户演示。</font><br>这个场景比较类似第一个场景, 不过是面向不专业的人事或者客户, 需要不定时更新版本然后提供<em>企业证书</em>打包的预览版给老板和客户。严格意义上来说, 与第一个场景是同样一个场景。</p>
</li>
<li><p><font size="4">场景: 测试集成。</font><br>自动化构建和持续集成本来就是一码事, 如果你是个喜欢写集成测试的开发者, 那么在每一次打包编译的时候都要运行一次集成测试是很浪费时间的(PS: 集成测试不通过这个场景除外哦`)。将测试集成在构建步骤里面, 可以让自动化集成的所有行为在另外一台机器上工作, 工程师该干嘛还是干嘛去。</p>
</li>
</ol>
<p>还有其他很多应用场景, 不过我个人暂时为了上述目的而搭建CI环境。最主要的目的是解放打包时间, 防止开发工作被打断。</p>
<h2 id="准备工作">准备工作</h2><h3 id="硬件环境">硬件环境</h3><ol>
<li><font size="4">搭载Macintosh系统的一台硬件设备或虚拟机。</font><br>既然是编译<em>iOS</em>应用, 那自然少不了苹果一系列的机器啦,  一台搭载Macintosh OS操作系统的电脑还是必须的, 目前本人采用的硬件方案是Mac mini。<br>需要Macintosh是因为Xcode运行环境在该系统上, 因此如果你想利用脚本编译iOS应用, 你就需要Xcode, 如果你需要Xcode, 那你又必须处于Macintosh OS环境(哎~ 苹果的生态链)。<br>鉴于目前国内的云服务器均为windows或者Linux, 您如果想用Geek的方式去搭建iOS的自动化构建方式, 可以尝试在云服务器上安装虚拟机然后运行Mac OS环境的方案。</li>
<li>在准备做CI的机器上安装Java SDK环境 &amp; Xcode。<br>Xcode可以用过App Store直接安装, Xcode体积非常大, 但是因为iOS编译脚本xcodebuile命令依赖于Xcode,因此Xcode是必须安装的。<br>Java运行环境是Jenkins需要, 因为Jenkins是基于Java实现的一套构建系统, Java SDK可以通过Oracle的官网去下载最新的适用版本, 在本文书写的时候, 最新的Java SDK是JDK8, 下载地址为 <a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="external">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></li>
</ol>
<h3 id="安装Jenkins">安装Jenkins</h3><ol>
<li><p>在Mac OS环境下, 建议采用Homebrew来安装, 获取Homebrew建议采用官网的方式。通过<a href="http://brew.sh" target="_blank" rel="external">Homebrew官网</a>获取homebrew后执行如下命令:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install jenkins</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用homebrew安装完毕后, 可以在终端执行<code>which jenkins</code>查看是否已经安装成功。</p>
</li>
<li>在终端执行<code>jenkins</code>命令启动Jenkins(PS: 默认占用8080端口会导致启动失败), 此处有可能会出现Jenkins ssl证书过期的问题, 可以通过修改os系统时间, 调整为ssl支持的时间来解决, 否则安装Jenkins插件可能会失败。(jenkins命令依赖Java开发环境, 旧版本的Jenkins需要自己去配置bash alias)</li>
<li>打开浏览器, 访问<a href="http://localhost:8080" target="_blank" rel="external">http://localhost:8080</a>, 查看Jenkins是否正常启动(默认端口8080)。</li>
</ol>
<h2 id="配置工作">配置工作</h2><h3 id="Jenkins插件配置">Jenkins插件配置</h3><p><img src="http://blog.startry.com/img/blog_jenkins.png" alt="Jenkins项目"></p>
<p>Jenkins是个生态比较完善的自动化构建系统, 提供了各种的可扩展插件给用户下载, 同时又开放接口, 让大家自主开发对应的插件。插件管理路径是<code>系统管理</code>-&gt;<code>管理插件</code></p>
<p>插件索引默认并不是最新的, 需要大家手动更新, 在<code>管理插件</code>-&gt;<code>可选插件</code>的右下角有个<code>立即获取</code>按钮, 点击即可获取最新的插件索引。</p>
<p>PS: <font color="red">有时候官方索引的地址ssl证书过期导致索引会更新失败, 大家可以通过浏览器调试获取证书到期时间, 然后将本机时间调整为过期以前的时间即可解决该问题。</font>(apache有时候也不靠谱啊。。)</p>
<p>每个开发者根据不同的业务场景需要用到不同的插件, 本文就不在这里赘述, 大家自由发挥吧。</p>
<h3 id="Jenkins账户权限配置">Jenkins账户权限配置</h3><p>Jenkins用户权限配置和本文主题无关, 主要是方便大家对Jenkins用户进行访问控制。可以参考文章”<a href="http://my.oschina.net/donhui/blog/424980" target="_blank" rel="external">Jenkins安全配置/访问控制/审计</a>“或文章”<a href="http://bookong.iteye.com/blog/1964182" target="_blank" rel="external">Jenkins使用经验谈5(用户的登录与权限设定等)</a>“进行配置。</p>
<p>我个人是比较喜欢采用安全域里的<code>Jenkins专有用户数据库</code>进行配置, 因为自带的比较方便, 而且在不复杂的企业环境里面已经够用, 负责的企业环境就另当别论了。大致流程如下:</p>
<ol>
<li>在Jenkins页面上注册一个新用户(当然可以导入)</li>
<li>在<code>系统管理</code>-&gt;<code>Configure Global Security</code>里的授权策略进行定向配置, 个人偏好采用<code>项目矩阵授权策略</code>进行管理。</li>
</ol>
<h3 id="项目&amp;脚本配置">项目&amp;脚本配置</h3><p>本文重点是如何自动化编译iOS项目, 这个其实大家应该很熟悉了, 就是利用<code>xcodebuild</code>命令和<code>xcrun</code>组合进行脚本编译和签名。编译脚本的编写本质上不缺分环境(Jenkins服务器环境or本机环境), 因此我们需要确保本机环境的脚本能够正常的工作, 个人偏好使用bash环境(因为不用安装其它的依赖), 然后使用下述的模板进行填空。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#!/bin/bash</span></span><br><span class="line">projAbbr=<span class="string">'iOS_Bash_Build_Demo'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">autoBuild</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">	prepareBuildEnv</span><br><span class="line">	updatePodsDeps</span><br><span class="line">	clearProjs</span><br><span class="line">	buildProjs</span><br><span class="line">	signProjs</span><br><span class="line">	uploadAppFile</span><br><span class="line">	<span class="built_in">echo</span> <span class="variable">$&#123;projAbbr&#125;</span> <span class="string">'- ALL Action Completed!'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">prepareBuildEnv</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment"># <span class="doctag"><span class="keyword">TODO</span></span> - 执行编译器准备工作, 可以调整项目配置等执行任务</span></span><br><span class="line">	<span class="comment"># eg: mkdir xxx</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">updatePodsDeps</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment"># <span class="doctag"><span class="keyword">TODO</span></span> - 更新Pod依赖</span></span><br><span class="line">	<span class="comment"># eg: pod install </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">clearProjs</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment"># <span class="doctag"><span class="keyword">TODO</span></span> - clean项目</span></span><br><span class="line">	<span class="comment"># eg: xcodebuild -workspace "demo.xcworkspace"  -scheme "targetName"  -configuration 'Release Adhoc' clean</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">buildProjs</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment"># <span class="doctag"><span class="keyword">TODO</span></span> - 编译项目, 生产带证书签名的App文件</span></span><br><span class="line">	<span class="comment"># eg: xcodebuild -workspace "demo.xcworkspace" -sdk iphoneos -scheme "targetName" -configuration 'Release Adhoc' SYMROOT='$(PWD)'</span></span><br><span class="line">	<span class="comment"># eg: xcodebuild -workspace "demo.xcworkspace" -sdk iphoneos -scheme "targetName" -configuration 'Release Adhoc' CODE_SIGN_IDENTITY="keychain中证书代号名称" SYMROOT='$(PWD)'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">signProjs</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment"># <span class="doctag"><span class="keyword">TODO</span></span> - 填充签名脚本, 用于签名编译到的App, 打包成ipa文件</span></span><br><span class="line">	<span class="comment"># eg: xcrun -sdk iphoneos PackageApplication -v "demo.app" -o "demo.ipa" &gt; $logPath</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">uploadAppFile</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment"># <span class="doctag"><span class="keyword">TODO</span></span> - 上传App文件到发布平台</span></span><br><span class="line">	<span class="comment"># 蒲公英、Fir.im都是不错的选择哦</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果使用第三方平台, 一般不需要createPlist, 因为第三方平台都已经集成</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">createPlist</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment"># <span class="doctag"><span class="keyword">TODO</span></span> - 创建Plist文件, 用于企业证书下载</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">autoBuild</span><br></pre></td></tr></table></figure>
<p>上述脚本将编译步骤拆分为<code>准备环境</code>、<code>更新Cocoapods</code>、<code>clean项目</code>、<code>build项目</code>、<code>签名项目</code>和<code>上传ipa文件</code>六大步骤。脚本的每一个步骤其实都可以在Jenkins需找对应的插件进行图形化控制, 但是我本人喜欢编写脚本来轻量化Jenkins的依赖, 除非需要本地上传一些依赖配置的文件。</p>
<p>上述脚本的执行任务也可以通过组合<code>CocoaPods Jenkins Integration</code>插件、<code>Xcode integration</code>插件以及其他上传插件进行组合。但是我并不太喜欢过渡依赖Jenkins的图形界面, 因此并没有深度整合这两个插件。</p>
<font style="bold" color="black">脚本的核心代码注释在代码里的eg, xcodebuild命令进行clean以及build, 然后通过xcrun进行签名app生成ipa文件</font>

<p>clean清理脚本示例:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcodebuild -workspace <span class="string">"demo.xcworkspace"</span>  -scheme <span class="string">"targetName"</span>  -configuration <span class="string">'Release Adhoc'</span> clean</span><br></pre></td></tr></table></figure>
<p>build编译脚本示例:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcodebuild -workspace <span class="string">"demo.xcworkspace"</span> -sdk iphoneos -scheme <span class="string">"targetName"</span> -configuration <span class="string">'Release Adhoc'</span> CODE_SIGN_IDENTITY=<span class="string">"keychain中证书代号名称"</span> SYMROOT=<span class="string">'$(PWD)</span></span><br></pre></td></tr></table></figure></p>
<p>xcodebuild是Xcode Command Tool工具集里的一个命令, 可以通过<code>-workspace</code>指定固定的xcode工作空间或者通过<code>-project</code>指定固定的xcode项目。详细的参数可以参考<a href="https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man1/xcodebuild.1.html" target="_blank" rel="external">官方文档</a>。</p>
<p>sign签名脚本示例:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun -sdk iphoneos PackageApplication -v <span class="string">"demo.app"</span> -o <span class="string">"demo.ipa"</span></span><br></pre></td></tr></table></figure></p>
<p>xcrun命令可以将app文件打包成ipa文件, 主要依赖xcodebuild命令中指定的证书, 如果没有有效证书的话, 只能在越狱的环境中安装ipa。</p>
<p><strong>大家可以尝试填充这个脚本, 来进行本地编译, 如果本地编译不通过, 那放在Jenkins上是肯定通过不了的。</strong></p>
<p>具体的脚本内容每个人各不相同, Github上有个叫<strong>BashShell</strong>的项目里包含一个脚本示例<a href="https://github.com/heyuan110" target="_blank" rel="external">build_install.sh</a>, 该项目作者编写的脚本非常详细, 大家可以参考编写。</p>
<ul>
<li>xcodebuild命令可以指定对应的签名文件, 可以通过预先上传签名文件到编译服务器的keychains中或者将证书存放于代码托管库中方便指定。</li>
<li>通过Jenkins执行的脚本会默认注入一些全局环境变量, 例如<code>${PWD}</code>、<code>${CHANGES}</code>等等。通过这些全局参数可以在执行脚本或者邮件等任务中打印动态数据。</li>
<li>Jenkins默认将返回值<strong>-1</strong>作为失败条件, 因此如果需要主动在脚本终止任务, <code>return -1</code>就可以触发Jenkins任务失败了。</li>
</ul>
<p>好了, 准备工作已经差不多了, 可以先将自己的脚本本地测试下了哦~ 编译通过了就可以开始配置Jenkins任务啦~</p>
<h2 id="开始自动化之旅">开始自动化之旅</h2><h3 id="新建任务">新建任务</h3><p>编译脚本、编译环境都准备好, Jenkins也正常运行了, 接下来就是创建Jenkins任务了。</p>
<ol>
<li>通过<code>新建</code>构建一个自由风格的软件项目。(同一个分支不同的任务也需要建立多个不同的Job, 每一个Job在服务器Home目录下的.jenkins文件夹下面会创建一个独立的job和workspace)</li>
<li>在配置界面配置对应的<code>源码管理</code>, 现在国内大部分开发者的开发项目应该依托于<code>gitlab</code>的吧。(gitlab需要制定对应的版本号)</li>
<li><p>设定自动执行循环时间: 在<code>构建触发器</code>勾选<code>Poll SCM</code>, 可以通过特定的表达式进行触发设定。点击输入框后方问号会提示触发表达式的规则与书写方式。</p>
<ul>
<li><p>例如12小时检查一次源码库更新可以表达如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">H H/<span class="number">12</span> * * *</span><br></pre></td></tr></table></figure>
</li>
<li><p>例如30分钟检查一次源码库更新可以表达如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">H/<span class="number">30</span> * * * *</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>在<code>构建</code>栏点击<code>增加构建步骤</code>, 选择<code>Execute Shell</code>, 在Command栏里面执行预先保存的脚本文件。假如默认保存在项目根目录下的脚本文件名为jenkins.sh, 则输入如下代码:</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh jenkins.sh</span><br></pre></td></tr></table></figure>
<ul>
<li>PS: 此处如果使用图形插件的同学们, 可以在这里添加对应的插件。</li>
</ul>
</li>
<li><p>构建后任务可以添加邮件提醒以及上传FTP等执行动作。</p>
</li>
</ol>
<h3 id="自动发送邮件">自动发送邮件</h3><ol>
<li>Jenkins默认提供了编译错误时候的自动邮件发送功能。 简易邮件功能需要在<code>系统管理</code>中的<code>系统设置</code>中的<code>邮件通知</code>栏进行设置。设置了邮件通知全局配置后, 在Jenkins Job配置的<code>增加构建后步骤</code>中可以配置简易的邮件通知, 简易版本的邮件通知仅仅支持在系统不稳定的时候通知相关的责任人与固定的邮件接收者。</li>
<li>Email Extension Plugin: Jenkins一个很强大的邮件系统, 可以配置各种各样的邮件内容, 也可以定制不同的触发条件以及接受者。配置使用可以参考其他博文, 例如这篇<a href="http://p.primeton.com/articles/54c1d470be20aa1bf9000066" target="_blank" rel="external">《Jenkins中配置ESB构建后自动发邮件》</a></li>
</ol>
<h3 id="自动化测试">自动化测试</h3><p>自动化测试可以参考构建脚本的使用方式, 单独书写shell任务去执行对应的测试任务, 也可以在构建脚本中提前穿插测试任务。本文中自动化测试并不是重点, 再这里不讨论, 后期更新相关内容。</p>
<h3 id="自动上传">自动上传</h3><p>自动化的最后一步就是提供方便的下载地址给需要安装App的测试体验人员。需要一个平台提供一个方便苹果app下载的平台, 目前市面上以<a href="http://fir.im" target="_blank" rel="external">fir.im</a>以及<a href="http://www.pgyer.com/" target="_blank" rel="external">蒲公英</a>使用率最广。</p>
<ol>
<li><p>第三方平台: 以<code>fir.im</code>为例子, fir.im平台集成了ipa文件下载所需要plist文件以及一张优美的下载页。ipa文件第一次需要自己上传产生一个对应url地址。因为该平台本身依赖于七牛云存储, 因此使用该平台的上传脚本可以使用七牛的<code>qrsync</code>脚本实现, 具体怎么上传请参考fir.im的<a href="http://fir.im/docs" target="_blank" rel="external">官方指南文档</a>。</p>
</li>
<li><p>自建平台: 自建平台比较麻烦, 需要产生对应的plist文件以及下载页面, 但是在很多高保密的企业下是不允许使用第三方平台的, 个人建议为公司搭建一个简易版本的fir.im, 方便以后使用。</p>
<ul>
<li>构建平台主要是承担的工作是企业证书下载环境的搭建以及历史版本的维护。企业证书下载环境最关键的部分是plist描述文件的生产以及https服务的支持<strong>(iOS7以后的items-service服务需要ssl且不接受伪造证书)</strong>。</li>
<li>Bryce Zhange的博文里面有一篇教大家使用Apache和PHP搭建一个服务器的博文<a href="http://www.cnblogs.com/brycezhang/p/4097487.html" target="_blank" rel="external">《iOS自动化编译》</a>, 大家可以参考。该博文包含了如何使用Bruce(heyuan110)的编译脚本以及如何采用<code>cat</code>&amp;<code>EOF</code>&amp;<code>&gt;&gt;</code>去动态生成plist文件。<br><br>PS: 个人不建议采用Apache搭建服务器, 可以试试Ngnix~ 其实最好是不要自己搭建了~</li>
</ul>
</li>
</ol>
<h2 id="总结">总结</h2><p>本文主要是总结了我个人喜爱的方式, 使用Jenkins+Bash脚本在Mac OS X环境下搭建一个自动化构建环境。通过自动化构建环境来将自己从体验人员和测试人员不断要求安装包的麻烦中解放出来专心编写工程代码。Bash主要在于<code>xcodebuild</code>和<code>xcrun</code>命令的使用, 以及提供了本人比较爱好的一套模板方便大家快速编写。Jenkins主要用于定时轮询代码和邮件通知。</p>
<p>文章的作用是给我本人备忘用的哈~ 水平有限, 有错误之处请大家及时指出哈~</p>
<h5 id="参考文献:">参考文献:</h5><ol>
<li><a href="http://p.primeton.com/articles/54c1d470be20aa1bf9000066" target="_blank" rel="external">http://p.primeton.com/articles/54c1d470be20aa1bf9000066</a></li>
<li><a href="http://www.cnblogs.com/brycezhang/p/4097487.html" target="_blank" rel="external">http://www.cnblogs.com/brycezhang/p/4097487.html</a></li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Jenkins/">Jenkins</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ios/">ios</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/06/09/hello-world/" class="article-date">
  	<time datetime="2015-06-09T14:19:45.000Z" itemprop="datePublished">2015-06-09</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/09/hello-world/">Hello World</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start">Quick Start</h2><h3 id="Create_a_new_post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2015 Startry
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
  <div style="display:none">
    <span id="busuanzi_container_site_pv" style="display:hidden;">本站总访问量<span id="busuanzi_value_site_pv"></span>次
    </span>
    <span id="busuanzi_container_site_uv">本站访客数<span id="busuanzi_value_site_uv"></span>人次
    </span>
  </div>
</footer>
<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-67055063-1', 'auto');
  ga('send', 'pageview');
</script>

    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>